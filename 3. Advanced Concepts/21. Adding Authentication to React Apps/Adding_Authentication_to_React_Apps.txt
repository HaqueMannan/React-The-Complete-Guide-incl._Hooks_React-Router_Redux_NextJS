Adding Authentication to React Apps - Summary:
1. Introduction to Authentication (the What, How & Why?)
2. Adding User Signup & Login
3. Managing the Auth State with Context
4. Using the Token for Requests to Protected Resources

------------------------------------------------------------------------------------
1. Introduction to Authentication (the What, How & Why?):
------------------------------------------------------------------------------------
   > Authentication is needed if content should be protected (i.e. not accessible by everyone).
   > Protected content can mean different things. Sometimes you would have pages on your site that should be locked if users are not authenticated for example a user's change password page. Proected content could also be data that you are storing to a backend database i.e. API enpoints which the React application might be sending requests on certain pages that should be locked for non-authenticated users. There are many other examples for what proected content could mean for your application.
   > Therefore, authentication is all about making your application secure from unauthoised access and does not necessarily have to be in relation to pages but also protected endpoint API URLs to prevent any unaythorised user access/changes to the database.
   > Now that we know why we need authentication, how does authentication work in general?
   > Authentication in general is a two-step process: 1) Get Access/Permission and 2) Send request to the protected resource(s).
   > To get the permission you always provide your credentials on a login form. This data is sent to a server to lookup a database to match the username and password combination stored on the database. Only if the credentials are valid the server will grant permission to the restricted resource content. You can send more requests to other secure enpoints with the permission attached. This is how authenticated generally works.

   Getting Permission:
               --------------Request with User Credentials---------------
               |                                                        |
      [Client (Browser)]                                             [Server]
               ^--------------------Response (Yes/No--------------------|

   > Is this permission enough? A "Yes" or "No" response alone is not enough to then access protected resources (API endpoints). It is not enough because a "Yes" or "No" response is easy enough to fake to a server i.e. you could skip the step of getting permission and sending a fake "Yes" permission to request for protected resources.
   > Authentication is a lot more elaborate than just sending and checking credentials. The response that is sent back by the server to the client must be more than just a "Yes" or "No" response.
   > There are two main approaches commonly used in Authentication:
      1) Working with Server-Side sessions
      2) Working with Authentication Tokens

   > Server-Side Sesssions are a traditional approach of handling authentication and are a great approach for handling authentication. Once a server grants you access that server stores a unique identifier for the specific client (i.e. the user who was granted access). Therefore, every visitor of a website who authenticates has their own identifier stored on the server. This identifier is also sent back to the client.
   > Both Server and Client knows this identifier. This identifier is attached to future requests to the server and since the server knows this identifier it cannot be faked.
   > Server-Side Sessions work great if your backend and frontend are tightly coupled. The one disadvantage of this approach is where you have decoupled ends i.e. the frontend is served on server A and the backend API is on server B then there is no tight coupling. You may want an API that should be used by many websites then the API cannot be tightly coupled and focused on one specific front end and instead needs to stay flexible. Therefore, you do not want to store an identifier on a server. The server should be stateless i.e. it should not store this kind of data about the connected clients.
   > You may have to deal with decoupled frontend and backend situations especially when building Single Page Applications.

   > Authentication Tokens are the same as Server-Side Sessions but with one key difference. The client sends their credentials to a server and the server validates the credential combination, if valid the server creates a permission token which is a very long string with some data encoded into that string (using some algorithm). The token can be decoded back into the individual pieces of data.
   > The token is generated by the server using a specific algorithm along with a key which is used for hashing that data into a string which is only known by the server and not by the client. The token is not stored by the server but it is sent back to the client but only the server knows how to create that token because of the key that is involved to create the token. The client can use this token to attach it to future requrests to grant permission to protected resources on the server.
   > Even though the server has not stored the identifier (as it would with Server-Side Sessions approach) the server is still able to verify that the token was created by the server and was not faked. Only the server knows the key and the incoming token attached to the request for some protected resource can be validates by the server i.e. the server can check if that token could be created by the server.
   > This approach allows for decoupling of frontend and backend.
   > When working with "Authentication Tokens", these tokens are typically created in the "JSON Web Token" Format (JWT). Those "tokens" are really just long strings which are constructed by an algorithm that encodes data into a string (with help of a private key, only known by the server).You can learn more about JSON Web Tokens (JWTs) on this link https://jwt.io/.

------------------------------------------------------------------------------------
2. Adding User Signup & Login:
------------------------------------------------------------------------------------
   > To learn about authentication we will use the Google Firebase service which has a easy authentication API. You can use any backend and are not limited to Firebase but the implementation of authentication will vary from provider to provider. However this will provide the necessary knowledge to understand how you could implement authentication.
   > Login to your Firebase account and for a project overview sidebar you will notice a "Authentication" option under the Build options. You need to unlock authentication for your project in order to use authentication in your application. Click on the "Get Started" button.
   > You should be redirected to a screen which will provide various different authentication options. To simulate your own API with your own database select the "Email/Password" Authentication method and "Enable" the option (do not enable the "Email link (passwordless signin)" option). Once that is done you can now signup new users and then login with user accounts.
   > Your application should have some signup to allow users to signup to your application with an email and password combination. The signup form should be used to extract entered values and then check whether the user is in a login or signup mode and if within signup mode, send the data across to the backend database via the appropriate API endpoint for registering a new user.
   > You should validate the user input on both the client and server side before setting up a new user to your application. This is to ensure valid data are passed in as well as to prevent duplicate accounts being setup within the systems users backend.
   > Firestore documentations shows how you can use their REST API to signup new users - https://cloud.google.com/identity-platform/docs/use-rest-api#section-create-email-password.
   > the '[API-KEY]' should be replaced with your firebase project API Key provided by Firebase. You get the API key from going into your project and clicking on the gear icon and selecting Project Settings. Under Your Project you will see the Web API Key for your Firebase project.
   > You can use the Fetch API to send a HTTP POST request to the Firebase API endpoint to post a new user sign up data to the firebase store (i.e. backend database).
   > You will see all signed up users with their email and password in the Firebase application Authentication under the Users tab.
   > You should always provide some feedback to the user when signing up or logging into your application for a better user experience (especially when something goes wrong). Firebase provides an error message property on the response object which you can use to print to the screen or drill into the error message and provide your own custom error messages.
   > The Login form should submit a HTTP request to a different REST API endpoint which validates users against the backend database (https://cloud.google.com/identity-platform/docs/use-rest-api#section-sign-in-email-password). The Login endpoint is exactly the same format as the Signup endpoint but just with a different URL to distinguish between the two operations.
   > Both the Signup and Login responses provide a response which contains an idToken. This idToken will be importantly for the signed in users future requests to protected resources. If you get this kind of response then you would know that the user has validly signed into their account because a idToken is only provided by the Firebase backend on successful login.
   > Below is an example of a Signup and Login Form that shares the same fetch code logic but provides different outputs depending on the response provided from the API endpoints.

   Adding Signup & Login Example:
      src/components/Auth/AuthForm.js:
         import React, { useState, useRef } from 'react';
         import classes from './AuthForm.module.css';
         const AuthForm = () => {
            const emailInputRef = useRef();
            const passwordInputRef = useRef();
            const [isLogin, setIsLogin] = useState(true);
            const [isLoading, setIsLoading] = useState(false);
            const switchAuthModeHandler = () => { setIsLogin((prevState) => !prevState) };
            const submitHandler = (event) => {
               event.preventDefault();
               const enteredEmail = emailInputRef.current.value;
               const enteredPassword = passwordInputRef.current.value;
               // Optional: Add Validation
               setIsLoading(true);
               let url;
               if(isLogin) {
                  url = 'https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=AIzaSyAv_ELkr2S7sOfDKPi1d9Jd39kmLFzRvHo'
               } else {
                  url = 'https://identitytoolkit.googleapis.com/v1/accounts:signUp?key=AIzaSyAv_ELkr2S7sOfDKPi1d9Jd39kmLFzRvHo'
               };
               fetch(url, {
                  method: 'post',
                  body: JSON.stringify({ email: enteredEmail, password: enteredPassword, returnSecureToken: true }),
                  headers: { 'Content-Type': 'application/json' }
               }).then(res => {
                  setIsLoading(false);
                  if(res.ok) { return res.json() } else {
                     return res.json().then(data => {
                        let errorMessage = 'Authentication Failed!';
                        if(data && data.error && data.error.message) { errorMessage = data.error.message };
                        throw new Error(errorMessage);
                     });
                  };
               }).then(data => { console.log(data) }).catch(err => { alert(err.message) });
            };
            return (
               <section className={classes.auth}>
                  <h1>{isLogin ? 'Login' : 'Sign Up'}</h1>
                  <form onSubmit={submitHandler}>
                     <div className={classes.control}>
                        <label htmlFor='email'>Your Email</label>
                        <input type='email' id='email' required ref={emailInputRef} />
                     </div>
                     <div className={classes.control}>
                        <label htmlFor='password'>Your Password</label>
                        <input type='password' id='password' required ref={passwordInputRef} />
                     </div>
                     <div className={classes.actions}>
                        {!isLoading && <button>{isLogin ? 'Login' : 'Create Account'}</button>}
                        {isLoading && <p>Sending Request...</p>}
                        <button type='button' className={classes.toggle} onClick={switchAuthModeHandler}>
                           {isLogin ? 'Create new account' : 'Login with existing account'}
                        </button>
                     </div>
                  </form>
               </section>
            );
         };
         export default AuthForm;

------------------------------------------------------------------------------------
3. Managing the Auth State with Context:
------------------------------------------------------------------------------------
   > When a user has signed in and is authenticated you need to store this authentication token somewhere in the running React application where it can be used from all kinds of Components. For example, the header Component would need it to display menu items applicable for the logged in user as well as other areas of the application. Therefore, the token should be stored in an App-Wide State.
   > There are two main options for managing App-Wide State: the Context API or Redux. It is entirely up to you which two option you prefer for your project.
   > Below is an example using the Context API to store the authentication token.

   Managing Auth State with Context API Example:
      src/store/auth-context.js:
         import React, { useState } from 'react';
         const AuthContext = React.createContext({
            token: '',
            isLoggedIn: false,
            login: (token) => {},
            logout: () => {}
         });
         export const AuthContextProvider = (props) => {
            const [token, setToken] = useState(null);
            const userIsLoggedIn = !!token;
            const loginHandler = (token) => { setToken(token) };
            const logoutHandler = () => { setToken(null) };
            const contextValue = {
               token: token,
               isLoggedIn: userIsLoggedIn,
               login: loginHandler,
               logout: logoutHandler
            };
            return(
               <AuthContext.Provider value={contextValue}>{props.children}</AuthContext.Provider>
            );
         };
         export default AuthContext;
      src/index.js:
         import React from 'react';
         import ReactDOM from 'react-dom';
         import { BrowserRouter } from 'react-router-dom';
         import './index.css';
         import App from './App';
         import { AuthContextProvider } from './store/auth-context';
         ReactDOM.render(
            <React.StrictMode>
               <AuthContextProvider>
                  <BrowserRouter>
                     <App />
                  </BrowserRouter>
               </AuthContextProvider>
            </React.StrictMode>,
            document.getElementById('root')
         );
      src/components/Auth/AuthForm.js:
         import React, { useState, useRef, useContext } from 'react';
         import AuthContext from '../../store/auth-context';
         ...
         const AuthForm = () => {
            ...
            const authCtx = useContext(AuthContext);
            ...
            const submitHandler = (event) => {
               ...
               fetch(url, {...
               }).then(res => {
                  ...
               }).then(data => {
                  authCtx.login(data.idToken);
               }).catch(err => {
                  alert(err.message);
               });
            };
            return(...);
         };
         export default AuthForm;
      src/components/Layout/MainNavigation.js:
         import React, { useContext } from 'react';
         import { Link } from 'react-router-dom';
         import AuthContext from '../../store/auth-context';
         import classes from './MainNavigation.module.css';
         const MainNavigation = () => {
            const authCtx = useContext(AuthContext);
            const isLoggedIn = authCtx.isLoggedIn;
            return (
               <header className={classes.header}>
                  <Link to='/'><div className={classes.logo}>React Auth</div></Link>
                  <nav>
                     <ul>
                        {!isLoggedIn && <li><Link to='/auth'>Login</Link></li>}
                        {isLoggedIn && <li><Link to='/profile'>Profile</Link></li>}
                        {isLoggedIn && <li><button>Logout</button></li>}
                     </ul>
                  </nav>
               </header>
            );
         };
         export default MainNavigation;

   > The AuthForm can now use this Context to store the authentication token as a global state when the user successfully logs into the application with valid credentials.
   > The token context can then be used in other Components to change the UI based on the logged in user for example the Layout MainNavigation Component can update the navigation header items depending on the logged in state.
   > This is the first important step in the correct direction for providing some form of authentication and protection to your application.

------------------------------------------------------------------------------------
4. Using the Token for Requests to Protected Resources:
------------------------------------------------------------------------------------
   > Below is an example of how you can send the Token as part of your request body to an API endpoint to access some form of protected resource. In this example, we allow a logged in user to change their password by passing a HTTP request to the API providing the details from the form for the new password but also passing along the users Token Id.
   > The Token Id provides authentication and protection to the user as it should only be known by the system and the logged in user and cannot be faked by someone who should not have access to changing that users account password or to the protected API route.
   > The documentation on how to change the password using the Firebase API can be found at https://cloud.google.com/identity-platform/docs/use-rest-api?hl=en#section-change-password.
   > Note: in firebase within the Realtime Database you could enforce authentication rules of your own within the rules tab of your project's Realtime Database. But for this demonstration the API is much easier to implement as Firebase has created the route and rules for updating a user account password.

   Using Token for Requests to Protected Resources Example:
      src/components/Profile/ProfileForm.js:
         import React, { useRef, useState, useContext } from 'react';
         import { useHistory } from 'react-router-dom';
         import AuthContext from '../../store/auth-context';
         import classes from './ProfileForm.module.css';
         const ProfileForm = () => {
            const history = useHistory();
            const newPasswordInputRef = useRef();
            const [isLoading, setIsLoading] = useState(false);
            const authCtx = useContext(AuthContext);
            const submitHandler = (event) => {
               event.preventDefault();
               const enteredNewPassword = newPasswordInputRef.current.value;
               // Optional: Add Validation
               setIsLoading(true);
               fetch('https://identitytoolkit.googleapis.com/v1/accounts:update?key=AIzaSyAv_ELkr2S7sOfDKPi1d9Jd39kmLFzRvHo', {
                  method: 'post',
                  body: JSON.stringify({ idToken: authCtx.token, password: enteredNewPassword, returnSecureToken: false }),
                  headers: { 'Content-Type': 'application/json' }
               }).then(res => {
                  setIsLoading(false);
                  if(res.ok) { return res.json() } else {
                     return res.json().then(data => {
                        let errorMessage = 'Authentication Failed!';
                        if(data && data.error && data.error.message) { errorMessage = data.error.message };
                        throw new Error(errorMessage);
                     });
                  };
               }).then(data => { history.replace('/') }).catch(err => { alert(err.message) });
            };
            return (
               <form className={classes.form} onSubmit={submitHandler}>
                  <div className={classes.control}>
                     <label htmlFor='new-password'>New Password</label>
                     <input type='password' id='new-password' ref={newPasswordInputRef} />
                  </div>
                  <div className={classes.action}>
                     {!isLoading && <button>Change Password</button>}
                     {isLoading && <p>Updating Password...</p>}
                  </div>
               </form>
            );
         };
         export default ProfileForm;

   > This API endpoint provides no response data due to the 'returnSecureToken' set to false. However, you would receive a response e.g. a 200 status code to indicate a success response. In this scenario you would want to redirect the user away from this page to indicate a successful update of their password. The redirect can be achieved by using the useHistory Hook from React Router.
   > Note: you could let the user stay on the page and display some form of success message instead and do not necessarily need to redirect the user.
   > You would know that this works by trying to login using the old password which should throw an invalid password error. Only when using the new password should the user be able to login successfully.
   > It will depend on the API endpoint of how the token should be added. In the above example the token was added in the request body but for other endpoints you may be required to add the token as a query parameter to the URL or the token to the request body's headers for example "headers: { Authorization: 'Bearer AIzaSyAv_ELkr2S7sOfDKPi1d9Jd39kmLFzRvHo' }" - it all depends on the API you are using.
   > If you are building your own API then it would depend on you how you define your API and how you expect to receive the token. However, when working with Third Party API (like Firebase) you would need to view their documentations on how they implemented their API rules.