Adding Authentication to React Apps - Summary:
1. Introduction to Authentication (the What, How & Why?)
2. Adding User Signup & Login
3. Managing the Auth State with Context
4. Using the Token for Requests to Protected Resources
5. Adding Logout
6. Protecting Frontend Pages with Route Guards
7. Persisting the User Authentication Status:
8. Adding Auto-Logout

------------------------------------------------------------------------------------
1. Introduction to Authentication (the What, How & Why?):
------------------------------------------------------------------------------------
   > Authentication is needed if content should be protected (i.e. not accessible by everyone).
   > Protected content can mean different things. Sometimes you would have pages on your site that should be locked if users are not authenticated for example a user's change password page. Protected content could also be data that you are storing to a backend database i.e. API endpoints which the React application might be sending requests on certain pages that should be locked for non-authenticated users. There are many other examples for what protected content could mean for your application.
   > Therefore, authentication is all about making your application secure from unauthorised access and does not necessarily have to be in relation to pages but also protected endpoint API URLs to prevent any unauthorised user access/changes to the database.
   > Now that we know why we need authentication, how does authentication work in general?
   > Authentication in general is a two-step process: 1) Get Access/Permission and 2) Send request to the protected resource(s).
   > To get the permission you always provide your credentials on a login form. This data is sent to a server to lookup a database to match the username and password combination stored on the database. Only if the credentials are valid the server will grant permission to the restricted resource content. You can send more requests to other secure endpoints with the permission attached. This is how authenticated generally works.

   Getting Permission:
               --------------Request with User Credentials---------------
               |                                                        |
      [Client (Browser)]                                             [Server]
               ^--------------------Response (Yes/No--------------------|

   > Is this permission enough? A "Yes" or "No" response alone is not enough to then access protected resources (API endpoints). It is not enough because a "Yes" or "No" response is easy enough to fake to a server i.e. you could skip the step of getting permission and sending a fake "Yes" permission to request for protected resources.
   > Authentication is a lot more elaborate than just sending and checking credentials. The response that is sent back by the server to the client must be more than just a "Yes" or "No" response.
   > There are two main approaches commonly used in Authentication:
      1) Working with Server-Side sessions
      2) Working with Authentication Tokens

   > Server-Side Sessions are a traditional approach of handling authentication and are a great approach for handling authentication. Once a server grants you access that server stores a unique identifier for the specific client (i.e. the user who was granted access). Therefore, every visitor of a website who authenticates has their own identifier stored on the server. This identifier is also sent back to the client.
   > Both Server and Client knows this identifier. This identifier is attached to future requests to the server and since the server knows this identifier it cannot be faked.
   > Server-Side Sessions work great if your backend and frontend are tightly coupled. The one disadvantage of this approach is where you have decoupled ends i.e. the frontend is served on server A and the backend API is on server B then there is no tight coupling. You may want an API that should be used by many websites then the API cannot be tightly coupled and focused on one specific front end and instead needs to stay flexible. Therefore, you do not want to store an identifier on a server. The server should be stateless i.e. it should not store this kind of data about the connected clients.
   > You may have to deal with decoupled frontend and backend situations especially when building Single Page Applications.

   > Authentication Tokens are the same as Server-Side Sessions but with one key difference. The client sends their credentials to a server and the server validates the credential combination, if valid the server creates a permission token which is a very long string with some data encoded into that string (using some algorithm). The token can be decoded back into the individual pieces of data.
   > The token is generated by the server using a specific algorithm along with a key which is used for hashing that data into a string which is only known by the server and not by the client. The token is not stored by the server but it is sent back to the client but only the server knows how to create that token because of the key that is involved to create the token. The client can use this token to attach it to future requests to grant permission to protected resources on the server.
   > Even though the server has not stored the identifier (as it would with Server-Side Sessions approach) the server is still able to verify that the token was created by the server and was not faked. Only the server knows the key and the incoming token attached to the request for some protected resource can be validates by the server i.e. the server can check if that token could be created by the server.
   > This approach allows for decoupling of frontend and backend.
   > When working with "Authentication Tokens", these tokens are typically created in the "JSON Web Token" Format (JWT). Those "tokens" are really just long strings which are constructed by an algorithm that encodes data into a string (with help of a private key, only known by the server).You can learn more about JSON Web Tokens (JWTs) on this link https://jwt.io/.

------------------------------------------------------------------------------------
2. Adding User Signup & Login:
------------------------------------------------------------------------------------
   > To learn about authentication we will use the Google Firebase service which has a easy authentication API. You can use any backend and are not limited to Firebase but the implementation of authentication will vary from provider to provider. However this will provide the necessary knowledge to understand how you could implement authentication.
   > Login to your Firebase account and for a project overview sidebar you will notice a "Authentication" option under the Build options. You need to unlock authentication for your project in order to use authentication in your application. Click on the "Get Started" button.
   > You should be redirected to a screen which will provide various different authentication options. To simulate your own API with your own database select the "Email/Password" Authentication method and "Enable" the option (do not enable the "Email link (passwordless signin)" option). Once that is done you can now signup new users and then login with user accounts.
   > Your application should have some signup to allow users to signup to your application with an email and password combination. The signup form should be used to extract entered values and then check whether the user is in a login or signup mode and if within signup mode, send the data across to the backend database via the appropriate API endpoint for registering a new user.
   > You should validate the user input on both the client and server side before setting up a new user to your application. This is to ensure valid data are passed in as well as to prevent duplicate accounts being setup within the systems users backend.
   > Firestore documentations shows how you can use their REST API to signup new users - https://cloud.google.com/identity-platform/docs/use-rest-api#section-create-email-password.
   > the '[API-KEY]' should be replaced with your firebase project API Key provided by Firebase. You get the API key from going into your project and clicking on the gear icon and selecting Project Settings. Under Your Project you will see the Web API Key for your Firebase project.
   > You can use the Fetch API to send a HTTP POST request to the Firebase API endpoint to post a new user sign up data to the firebase store (i.e. backend database).
   > You will see all signed up users with their email and password in the Firebase application Authentication under the Users tab.
   > You should always provide some feedback to the user when signing up or logging into your application for a better user experience (especially when something goes wrong). Firebase provides an error message property on the response object which you can use to print to the screen or drill into the error message and provide your own custom error messages.
   > The Login form should submit a HTTP request to a different REST API endpoint which validates users against the backend database (https://cloud.google.com/identity-platform/docs/use-rest-api#section-sign-in-email-password). The Login endpoint is exactly the same format as the Signup endpoint but just with a different URL to distinguish between the two operations.
   > Both the Signup and Login responses provide a response which contains an idToken. This idToken will be importantly for the signed in users future requests to protected resources. If you get this kind of response then you would know that the user has validly signed into their account because a idToken is only provided by the Firebase backend on successful login.
   > Below is an example of a Signup and Login Form that shares the same fetch code logic but provides different outputs depending on the response provided from the API endpoints.

   Adding Signup & Login Example:
      src/components/Auth/AuthForm.js:
         import React, { useState, useRef } from 'react';
         import classes from './AuthForm.module.css';
         const AuthForm = () => {
            const emailInputRef = useRef();
            const passwordInputRef = useRef();
            const [isLogin, setIsLogin] = useState(true);
            const [isLoading, setIsLoading] = useState(false);
            const switchAuthModeHandler = () => { setIsLogin((prevState) => !prevState) };
            const submitHandler = (event) => {
               event.preventDefault();
               const enteredEmail = emailInputRef.current.value;
               const enteredPassword = passwordInputRef.current.value;
               // Optional: Add Validation
               setIsLoading(true);
               let url;
               if(isLogin) {
                  url = 'https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=AIzaSyAv_ELkr2S7sOfDKPi1d9Jd39kmLFzRvHo'
               } else {
                  url = 'https://identitytoolkit.googleapis.com/v1/accounts:signUp?key=AIzaSyAv_ELkr2S7sOfDKPi1d9Jd39kmLFzRvHo'
               };
               fetch(url, {
                  method: 'post',
                  body: JSON.stringify({ email: enteredEmail, password: enteredPassword, returnSecureToken: true }),
                  headers: { 'Content-Type': 'application/json' }
               }).then(res => {
                  setIsLoading(false);
                  if(res.ok) { return res.json() } else {
                     return res.json().then(data => {
                        let errorMessage = 'Authentication Failed!';
                        if(data && data.error && data.error.message) { errorMessage = data.error.message };
                        throw new Error(errorMessage);
                     });
                  };
               }).then(data => { console.log(data) }).catch(err => { alert(err.message) });
            };
            return (
               <section className={classes.auth}>
                  <h1>{isLogin ? 'Login' : 'Sign Up'}</h1>
                  <form onSubmit={submitHandler}>
                     <div className={classes.control}>
                        <label htmlFor='email'>Your Email</label>
                        <input type='email' id='email' required ref={emailInputRef} />
                     </div>
                     <div className={classes.control}>
                        <label htmlFor='password'>Your Password</label>
                        <input type='password' id='password' required ref={passwordInputRef} />
                     </div>
                     <div className={classes.actions}>
                        {!isLoading && <button>{isLogin ? 'Login' : 'Create Account'}</button>}
                        {isLoading && <p>Sending Request...</p>}
                        <button type='button' className={classes.toggle} onClick={switchAuthModeHandler}>
                           {isLogin ? 'Create new account' : 'Login with existing account'}
                        </button>
                     </div>
                  </form>
               </section>
            );
         };
         export default AuthForm;

------------------------------------------------------------------------------------
3. Managing the Auth State with Context:
------------------------------------------------------------------------------------
   > When a user has signed in and is authenticated you need to store this authentication token somewhere in the running React application where it can be used from all kinds of Components. For example, the header Component would need it to display menu items applicable for the logged in user as well as other areas of the application. Therefore, the token should be stored in an App-Wide State.
   > There are two main options for managing App-Wide State: the Context API or Redux. It is entirely up to you which two option you prefer for your project.
   > Below is an example using the Context API to store the authentication token.

   Managing Auth State with Context API Example:
      src/store/auth-context.js:
         import React, { useState } from 'react';
         const AuthContext = React.createContext({
            token: '',
            isLoggedIn: false,
            login: (token) => {},
            logout: () => {}
         });
         export const AuthContextProvider = (props) => {
            const [token, setToken] = useState(null);
            const userIsLoggedIn = !!token;
            const loginHandler = (token) => { setToken(token) };
            const logoutHandler = () => { setToken(null) };
            const contextValue = {
               token: token,
               isLoggedIn: userIsLoggedIn,
               login: loginHandler,
               logout: logoutHandler
            };
            return(
               <AuthContext.Provider value={contextValue}>{props.children}</AuthContext.Provider>
            );
         };
         export default AuthContext;
      src/index.js:
         import React from 'react';
         import ReactDOM from 'react-dom';
         import { BrowserRouter } from 'react-router-dom';
         import './index.css';
         import App from './App';
         import { AuthContextProvider } from './store/auth-context';
         ReactDOM.render(
            <React.StrictMode>
               <AuthContextProvider>
                  <BrowserRouter>
                     <App />
                  </BrowserRouter>
               </AuthContextProvider>
            </React.StrictMode>,
            document.getElementById('root')
         );
      src/components/Auth/AuthForm.js:
         import React, { useState, useRef, useContext } from 'react';
         import AuthContext from '../../store/auth-context';
         ...
         const AuthForm = () => {
            ...
            const authCtx = useContext(AuthContext);
            ...
            const submitHandler = (event) => {
               ...
               fetch(url, {...
               }).then(res => {
                  ...
               }).then(data => {
                  authCtx.login(data.idToken);
               }).catch(err => {
                  alert(err.message);
               });
            };
            return(...);
         };
         export default AuthForm;
      src/components/Layout/MainNavigation.js:
         import React, { useContext } from 'react';
         import { Link } from 'react-router-dom';
         import AuthContext from '../../store/auth-context';
         import classes from './MainNavigation.module.css';
         const MainNavigation = () => {
            const authCtx = useContext(AuthContext);
            const isLoggedIn = authCtx.isLoggedIn;
            return (
               <header className={classes.header}>
                  <Link to='/'><div className={classes.logo}>React Auth</div></Link>
                  <nav>
                     <ul>
                        {!isLoggedIn && <li><Link to='/auth'>Login</Link></li>}
                        {isLoggedIn && <li><Link to='/profile'>Profile</Link></li>}
                        {isLoggedIn && <li><button>Logout</button></li>}
                     </ul>
                  </nav>
               </header>
            );
         };
         export default MainNavigation;

   > The AuthForm can now use this Context to store the authentication token as a global state when the user successfully logs into the application with valid credentials.
   > The token context can then be used in other Components to change the UI based on the logged in user for example the Layout MainNavigation Component can update the navigation header items depending on the logged in state.
   > This is the first important step in the correct direction for providing some form of authentication and protection to your application.

------------------------------------------------------------------------------------
4. Using the Token for Requests to Protected Resources:
------------------------------------------------------------------------------------
   > Below is an example of how you can send the Token as part of your request body to an API endpoint to access some form of protected resource. In this example, we allow a logged in user to change their password by passing a HTTP request to the API providing the details from the form for the new password but also passing along the users Token Id.
   > The Token Id provides authentication and protection to the user as it should only be known by the system and the logged in user and cannot be faked by someone who should not have access to changing that users account password or to the protected API route.
   > The documentation on how to change the password using the Firebase API can be found at https://cloud.google.com/identity-platform/docs/use-rest-api?hl=en#section-change-password.
   > Note: in firebase within the Realtime Database you could enforce authentication rules of your own within the rules tab of your project's Realtime Database. But for this demonstration the API is much easier to implement as Firebase has created the route and rules for updating a user account password.

   Using Token for Requests to Protected Resources Example:
      src/components/Profile/ProfileForm.js:
         import React, { useRef, useState, useContext } from 'react';
         import { useHistory } from 'react-router-dom';
         import AuthContext from '../../store/auth-context';
         import classes from './ProfileForm.module.css';
         const ProfileForm = () => {
            const history = useHistory();
            const newPasswordInputRef = useRef();
            const [isLoading, setIsLoading] = useState(false);
            const authCtx = useContext(AuthContext);
            const submitHandler = (event) => {
               event.preventDefault();
               const enteredNewPassword = newPasswordInputRef.current.value;
               // Optional: Add Validation
               setIsLoading(true);
               fetch('https://identitytoolkit.googleapis.com/v1/accounts:update?key=AIzaSyAv_ELkr2S7sOfDKPi1d9Jd39kmLFzRvHo', {
                  method: 'post',
                  body: JSON.stringify({ idToken: authCtx.token, password: enteredNewPassword, returnSecureToken: false }),
                  headers: { 'Content-Type': 'application/json' }
               }).then(res => {
                  setIsLoading(false);
                  if(res.ok) { return res.json() } else {
                     return res.json().then(data => {
                        let errorMessage = 'Authentication Failed!';
                        if(data && data.error && data.error.message) { errorMessage = data.error.message };
                        throw new Error(errorMessage);
                     });
                  };
               }).then(data => { history.replace('/') }).catch(err => { alert(err.message) });
            };
            return (
               <form className={classes.form} onSubmit={submitHandler}>
                  <div className={classes.control}>
                     <label htmlFor='new-password'>New Password</label>
                     <input type='password' id='new-password' ref={newPasswordInputRef} />
                  </div>
                  <div className={classes.action}>
                     {!isLoading && <button>Change Password</button>}
                     {isLoading && <p>Updating Password...</p>}
                  </div>
               </form>
            );
         };
         export default ProfileForm;

   > This API endpoint provides no response data due to the 'returnSecureToken' set to false. However, you would receive a response e.g. a 200 status code to indicate a success response. In this scenario you would want to redirect the user away from this page to indicate a successful update of their password. The redirect can be achieved by using the useHistory Hook from React Router.
   > Note: you could let the user stay on the page and display some form of success message instead and do not necessarily need to redirect the user.
   > You would know that this works by trying to login using the old password which should throw an invalid password error. Only when using the new password should the user be able to login successfully.
   > It will depend on the API endpoint of how the token should be added. In the above example the token was added in the request body but for other endpoints you may be required to add the token as a query parameter to the URL or the token to the request body's headers for example "headers: { Authorization: 'Bearer AIzaSyAv_ELkr2S7sOfDKPi1d9Jd39kmLFzRvHo' }" - it all depends on the API you are using.
   > If you are building your own API then it would depend on you how you define your API and how you expect to receive the token. However, when working with Third Party API (like Firebase) you would need to view their documentations on how they implemented their API rules.

------------------------------------------------------------------------------------
5. Adding Logout:
------------------------------------------------------------------------------------
   > At the moment you are able to login a user using the login form which will store the token id in the global state when a user has successfully logged into the application. You now need a way to log a user out of the application and update the state of the stored token.
   > The server does not store any information about the client for the logged in user using the Token Authentication approach (unlike with the Server-Side Sessions approach). Therefore, you do not need to send any requests to the server because the server does not know or care about logged in users. Hence, the state needs to be updated when logging out the user i.e. clearing the stored token.

   Adding Logout Example:
      src/components/Layout/MainNavigation.js:
         import React, { useContext } from 'react';
         import { Link } from 'react-router-dom';
         import AuthContext from '../../store/auth-context';
         import classes from './MainNavigation.module.css';
         const MainNavigation = () => {
            const authCtx = useContext(AuthContext);
            const isLoggedIn = authCtx.isLoggedIn;
            const logoutHandler = () => { authCtx.logout() };
            return (
               <header className={classes.header}>
                  <Link to='/'><div className={classes.logo}>React Auth</div></Link>
                  <nav>
                     <ul>
                        {!isLoggedIn && <li><Link to='/auth'>Login</Link></li>}
                        {isLoggedIn && <li><Link to='/profile'>Profile</Link></li>}
                        {isLoggedIn && <li><button onClick={logoutHandler}>Logout</button></li>}
                     </ul>
                  </nav>
               </header>
            );
         };
         export default MainNavigation;

   > In the above example, the "logoutHandler" function calls on the AuthContext's "logout" function which updates the global App-Wide "token" state to an empty string. The "Logout" button's "onClick" event is linked to this function to trigger the call whenever the logout button is clicked by the user which will update what is displayed on the screen UI.

------------------------------------------------------------------------------------
6. Protecting Frontend Pages with Route Guards:
------------------------------------------------------------------------------------
   > You may wish to protect certain routes from being navigated to whether within the application or manually in the URL for example the ProfileForm Component i.e. Change Password Page should not be accessible to any users who is not logged into the application.
   > While it may not be a problem or cause any harm with a page like this as it requires a token id to successfully change the password of a user account; however, you may still want to prevent users from visiting this page if they have not already logged into their account.
   > This can be solved by adding a feature called Navigation Guards. This feature is all about dynamically changing the route configuration based on whether the user is logged in or not.
   > The routes can only be visited by the defined routes in the App.js file. If you render the routes conditionally, only under certain conditions will a user be able to visit a certain route if that condition is true. Therefore, you can use the current authentication status of a user as the condition for certain routes. This will prevent users accessing certain page whether navigated via the application links or manually in the URL.

   Protecting Frontend Pages with Route Guards:
      src/App.js:
         import React, { useContext } from 'react';
         import { Switch, Route, Redirect } from 'react-router-dom';
         import Layout from './components/Layout/Layout';
         import UserProfile from './components/Profile/UserProfile';
         import AuthPage from './pages/AuthPage';
         import HomePage from './pages/HomePage';
         import AuthContext from './store/auth-context';
         function App() {
            const authCtx = useContext(AuthContext);
            return (
               <Layout>
                  <Switch>
                     <Route path='/' exact><HomePage /></Route>
                     {!authCtx.isLoggedIn && <Route path='/auth'><AuthPage /></Route>}
                     <Route path='/profile'>
                        {authCtx.isLoggedIn && <UserProfile />}
                        {!authCtx.isLoggedIn && <Redirect to="/auth" />}
                     </Route>
                     <Route path="*"><Redirect to="/" /></Route>
                  </Switch>
               </Layout>
            );
         };
         export default App;

   > In the above example, using the AuthContext the "Profile" page is conditionally rendered if the user is logged into the application or redirected to the auth page if not logged in creating a form of Navigation Guard.
   > The Route configuration is simply a Component that is being rendered and therefore we can conditionally render the Route Components. This is a standard way of solving this problem by proving a route guard.
   > You can get really creative here and fine tune the Route configuration as you need it based on the authentication status.

------------------------------------------------------------------------------------
7. Persisting the User Authentication Status:
------------------------------------------------------------------------------------
   > Currently there is one big problem. At the moment whenever you reload the application or manually enter a URL (which also causes a reload of the application) you use the authentication status. This makes sense because you restart the React application and is how the Browser works. However, this also means all of the context is lost resulting in the initial state.
   > You would typically want to keep a user logged in for a particular period of time (or when they logout).
   > It is important to understand that the token that is provided by the Firebase store has a duration which is provided as the API response payloads 'expiresIn' property. This is provided when a user is logged in using the Firebase API endpoint for logging in. The token provided by Firebase will expire in one hour by default which is a security mechanism.
   > Important Note: you can refresh this with the refreshToken property (which is a little advance and not covered here but you can read up the documentation found on https://firebase.google.com/docs/reference/rest/auth#section-sign-in-email-password).
   > You need to store the token somewhere outside of the React state. Browser do have storage mechanisms which you could use for example cookies and local storage. You can read an article on the comparison between the two storage mechanisms on https://academind.com/tutorials/localstorage-vs-cookies-xss/.
   > Using local storage is fine in development and will only be a problem if your page is vulnerable to Cross-Site Scripting attacks (ig you have Cross-Site Scripting attacks issues then you already have a problem with your application security in general).

   Persisting the User Authentication Status Example:
      src/store/auth-context.js:
         import React, { useState } from 'react';
         const AuthContext = React.createContext({ token: '', isLoggedIn: false, login: (token) => {}, logout: () => {} });
         export const AuthContextProvider = (props) => {
            const initialToken = localStorage.getItem('token');
            const [token, setToken] = useState(initialToken);
            const userIsLoggedIn = !!token;
            const loginHandler = (token) => {
               setToken(token);
               localStorage.setItem('token', token);
            };
            const logoutHandler = () => {
               setToken(null);
               localStorage.removeItem('token');
            };
            const contextValue = { token: token, isLoggedIn: userIsLoggedIn, login: loginHandler, logout: logoutHandler };
            return(<AuthContext.Provider value={contextValue}>{props.children}</AuthContext.Provider>);
         };
         export default AuthContext;

   > When the user logs into the application you want to store the token not just inside of the state but also in the Browser's storage. When the user logs out you also want to clear that data in the Browser's storage. In addition when the page loads you want to look into the storage and if a token is found then you want to use that token without forcing the user to re-login by sending a new login request.
   > The 'localStorage.setItem()' is an API that is built into the Browser (similar to the fetch API provided by the Browser) that you can call to store simple data into local storage. The .setItem() method expects a key:value pair to store the data in local storage.
   > Local Storage is only able to store basic primitive data like strings or numbers. If you want to store an object you would need to convert it to JSON first using JSON.stringify() method which will convert the object to a string representation.
   > You can use either '.clear()' or '.removeItem()' methods on the localStorage API object. The former clears the whole local storage while the latter removes a particular item (retrenched by its key) from the local storage.
   > The .getItem() method is used to retrieve a value from local storage by referencing the key for the item you wish to retrieve.
   > You do not need the useEffect Hook because localStorage is a synchronous API. The initial value for the token is retrieved once by React when the State is first initialised. If the Component re-runs thereafter the initial run you won't overwrite any state changes with that token.
   > You can view the localStorage items within the Browser in the Developer Tools Application Tab under Local Storage.
   > This now creates the persistence of the user login even if the page is reloaded or the user manually enters a URL path in the browser.

------------------------------------------------------------------------------------
8. Adding Auto-Logout:
------------------------------------------------------------------------------------
   > The token expires after one hour and so you would want to also make sure that the user is automatically logged out when the token expires i.e. automatically remove the token from local storage after one hour. Therefore, you would want to store the expiration time in local storage in order to set the timer correctly for the remaining duration correctly even after reloading the page.
   > Below is a example code for adding an auto-logout logic to the authentication context using the Browser's Local Storage mechanism.

   Adding Auto-Logout Example:
      src/store/auth-context.js:
         import React, { useState, useEffect, useCallback } from 'react';
         let logoutTimer;
         const AuthContext = React.createContext({ token: '', isLoggedIn: false, login: (token) => {}, logout: () => {} });
         const calculateRemainingTime = (expirationTime) => {
            const currentTime = new Date().getTime();
            const adjExpirationTime = new Date(expirationTime).getTime();
            const remainingExpiration = adjExpirationTime - currentTime
            return remainingExpiration;
         };
         const retrieveStoredToken = () => {
            const storedToken = localStorage.getItem('token');
            const storedExpirationDate = localStorage.getItem('expirationTime');
            const remainingTime = calculateRemainingTime(storedExpirationDate);
            if(remainingTime <= 60000) {
               localStorage.removeItem('token');
               localStorage.removeItem('expirationTime');
               return null;
            };
            return { token: storedToken, duration: remainingTime };
         };
         export const AuthContextProvider = (props) => {
            const tokenData = retrieveStoredToken();
            let initialToken;
            if(tokenData) { initialToken = tokenData.token };
            const [token, setToken] = useState(initialToken);
            const userIsLoggedIn = !!token;
            const logoutHandler = useCallback(() => {
               setToken(null);
               localStorage.removeItem('token');
               localStorage.removeItem('expirationTime');
               if(logoutHandler) {
                  clearTimeout(logoutTimer)
               };
            }, []);
            const loginHandler = (token, expirationTime) => {
               setToken(token);
               localStorage.setItem('token', token);
               localStorage.setItem('expirationTime', expirationTime);
               const remainingTime = calculateRemainingTime(expirationTime);
               logoutTimer = setTimeout(logoutHandler, remainingTime);
            };
            useEffect(() => {
               if(tokenData) {
                  // console.log(tokenData.duration);    // Only see the duration time reducing if the user is automatically logged in for testing the useEffect.
                  logoutTimer = setTimeout(logoutHandler, tokenData.duration);
               };
            }, [tokenData, logoutHandler]);
            const contextValue = { token: token, isLoggedIn: userIsLoggedIn, login: loginHandler, logout: logoutHandler };
            return(<AuthContext.Provider value={contextValue}>{props.children}</AuthContext.Provider>);
         };
         export default AuthContext;
      src/components/Auth/AuthForm.js:
         ...
         const AuthForm = () => {
            ...
            const switchAuthModeHandler = () => { ... };
            const submitHandler = (event) => {
               ...
               fetch(url, {
                  method: 'post',
                  body: JSON.stringify({ email: enteredEmail, password: enteredPassword, returnSecureToken: true }),
                  headers: { 'Content-Type': 'application/json' }
               }).then(res => {
                  ...
               }).then(data => {
                  const expirationTime = new Date(new Date().getTime() + (+data.expiresIn * 1000));
                  authCtx.login(data.idToken, expirationTime.toISOString());
                  history.replace('/');
               }).catch(err => {
                  alert(err.message);
               });
            };
            return (...);
         };
         export default AuthForm;

   > The calculateRemainingTime function is used as a helper function outside the Component to help correctly calculate the token expiration time. It returns the time in milliseconds to use in the '.setTimeout()' JavaScript function. You can get the current time by calling JavaScript 'new Date()' date class which will provide the current date/time stamp. The .getTime() will return only the time which is what you would be interested in.
   > The "expirationTime" would be a string and so would need to be converted into a Date class object in order to correctly calculate the remaining time in milliseconds.
   > The "loginHandler" function needs to be switched around with the "logoutHandler" function so that you can call "setTimeout()" function to pass in the "logoutHandler" function as a pointer so that this is called when the timer runs out. The second argument to the "setTimeout()" function is the time remaining. This will automatically log the user out when the time has expired.
   > The 'expiresIn' Payload response data is a string value. To convert this into a number in JavaScript we can add the plus sign in (+) front which will convert the string value to a number. You would multiply by 1000 to convert the seconds into milliseconds which is expected by the setTimeout() method.
   > To test whether the auto-logout is working you could temporarily change the setTimeout to 3 seconds in the auth-context.js file (i.e. 'setTimeout(logoutHandler, 3000)') which will allow you to see the auto-logout working after 3 seconds of logging into the application to make sure everything is working.
   > If the "logoutTimer" is set as global variable which stores the setTimeout value when logging in a user. When the user clicks the logout button it will check whether the logoutTimer is set and clear this on the logout button using the 'clearTimeout()' function passing in the "logoutTimer" timer as the argument/parameter. This will clear the timer if a timer was set on the logout button event.
   > The "retrieveStoredToken" helper function checks local storage for an expiration time and re-calculates the remaining time on any page reloads. If the remaining time is less than or equal to 1minute (i.e. 60000 milliseconds then you would not want to re-log the user into the application and also would want to delete the token and expirationTime data if stored in local storage).
   > The useEffect Hook is used to handle the side effect creation of the logoutTimer when the page reloads. This is to ensure when we log a user in automatically that the timer is set to automatically logout the user with the correct remaining time.
   > Using the useEffect which requires the "logoutHandler" function as a dependency required the useCallback Hook to prevent an infinite loop on "logoutHandler" function (i.e. unnecessarily re-creating the function on the Component re-execution/re-evaluation cycles).
   > The useCallback does not need any dependencies because localStorage is browser built-in functions, the setToken is a state updating function which is guaranteed by React that the function will never change and logout timer is a global variable which also is outside of the React re-evaluation/re-rendering flow. Therefore, the useCallback on the logoutHandler callback function does not require any dependencies.

------------------------------------------------------------------------------------
Conclusion:
------------------------------------------------------------------------------------
   > This should demonstrate how you can add some form of authentication to your application using Firebase. There are many ways of adding authentication and protection to protected routes using Authentication Tokens. The way you would implement authentication for your application will depend on the backend API you use for your project or your own created API.
   > You should now have a fundamental understanding of Authentication and what is required to setup protections for your application or what needs to be considered when building your application.
   > Note that there are many ways in which you can implement authentication with login/logout mechanism and protecting your routes with Route Guarding. The example provided is a demonstration of one such way using the Firebase API endpoints as an easy implementation to demonstrate Authentication in practice.