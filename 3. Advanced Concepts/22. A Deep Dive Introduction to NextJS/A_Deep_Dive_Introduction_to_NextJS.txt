A Deep Dive Introduction into Next.js - Summary:
1. What Is and Why Use Next.js?
2. Creating a New NextJS Project App and Analysing the Project Setup
3. Adding Pages, Nested Paths & Pages, Dynamic Pages (with Parameters) and Extracting Dynamic Parameter Values
4. Linking Between Pages
5. How Pre-Rendering Works & The Problems Faced with Pre-Rendering
6. Data Fetching for Static Pages and Static Site Generation(SSG)
7. Data Fetching for Server Side Rendering (SSR)
8. Working with Dynamic Params for SSG Data Fetching
9. Introducing API Routes

------------------------------------------------------------------------------------
1. What Is and Why Use Next.js?:
------------------------------------------------------------------------------------
   > NextJs offers a lot of features that makes building large scale production ready React applications easier i.e. it is a React framework for production.
   > React is a JavaScript library for building user interfaces i.e. it is a third part package which you can add to your front end projects (client side JavaScript code) to build interactive User Interface (UI). This is a library that makes building complex UI much easier than it would be with just vanilla JavaScript. It is a library because it focuses on that UI part through Component, State and Props.
   > If you want to build large scale React projects, you typically want to also need to add extra libraries for routing, authentication, etc.
   > NextJS is labelled a Framework. It is a framework that build up on React.
   > The difference between Framework and Library is that a Framework is bigger, has more features and focuses on more things and it provides clear rules/guidance on how you should write your code, structure files and so on.
   > NextJS goal is to solve the common problems of building production React apps and it enhances React by adding many core features which you would have had to add on your own in React for example routing.
   > Therefore, you no longer need to reinvent the wheel because a lot of the feature you would typically need for a production React applications is available right out of the box and you would not need to add as much third part libraries to solve common problems which is needed in larger applications.
   > What are the key features and benefits of a NextJS applications?
      1) Server Side Rendering:
         - This is the most important and key feature NextJS adds. Server Side Rendering is all about preparing the content of a page on the server instead of on the client. If you inspect a regular client side React applications you would see a very bar-bones HTML page with a <div id="root"> element which the React applications is loaded and rendered to. All of that rendering is done by React and done on the client side JavaScript i.e. inside of the browser of the user and not on the server.
         - This may not be a problem but it can also be a problem. For example, if your page also fetches some data from a server that should be displayed then the user might initially see some loading state (i.e. a flickering page for a fraction of second whilst the request is on its way fetching the data). Data fetching only begins once the JavaScript code executed on the client and you still need to wait for the outgoing response for that request, simply because the page which you requested did not contain that data already. This might not necessarily be a problem but it may not also be the user experience you want for your users.
         - This can be a problem for Server Engine Optimisation (SEO). This does not matter for all pages for example if you have an administration dashboard which is only reached by logging in then SEO does not matter because it will never see the dashboard as it is highly user specific requiring login. However, if you have a public facing page with a lot of content that should be found through search engines then SEO does matter.
         - The search engine crawlers will only see the empty HTML page when scanning your application pages that you are getting from the server and therefore will be ranked very low on search engine results.
         - Server Side Rendering can help you on this because if the page would be pr-rendered on the server (e.g. the data fetching occurs on the server) and the finished page would be served to the users and the search engine crawlers then the user will not see that flickering loading state and search engines would see the page content. This is a problem Server Side Rendering solves.
         - ReactJS actually has built-in features that allow you to add server-side rendering but it can be tricky to get this right. It also requires extra setup from your side. However, with NextJS it comes way easier because it has built-in server side rendering. NextJS automatically renders your pages and this means that if you build a standard NextJS app (without any extra setup from your side) if you visit such a page, it was pre-rendered on the server by default out of the box.
         - If you inspect the source code of a page from a NextJS application, you would see the HTML page rather than an empty HTML skeleton which is great for SEO and also helps with User Experience (UX) of not seeing that flickering load state.
         - It is worth noting that with NextJS, after the initial load/request, you still get a standard Single Page React application running in the browser. Subsequent navigation actions by the user are all handled by React within the browser to have this fast interactive UX which you typically want to offer with React applications.
         - NextJS blends client-side and server-side code together. This on its own is probably already a strong benefit/reason for why you might want to use NextJS for building React Projects instead of just ReactJS.
      2) File-Based Routing:
         - In traditional React you do not have a router, instead you give an illusion of having multiple pages. When you navigate around and load different pages then that is the job of a router (typically using React Router). The router basically watches the URL and when it changes it basically prevents the browser's default behaviour of sending a request to some backend server. Instead, it renders different content on the page (i.e. Components) with React.
         - Routing is basically changing what is visible on the screen based on the URL without sending a extra request to a server because you stay in that Single Page Application which is typically built with React.
         - In React, Routing is setup in code and while it is not bad or wrong it is extra code which you have to write. Then often, you end up storing your Components that act as pages in a separate folder which kind of replicates your routes setup in code (e.g. if your have three pages setup as pages in code you would then have three page Components in the pages Component folder).
         - NextJS gets rid of that in-code route definition. Instead, you define pages and routes with files and folders instead of code. NextJS applications have a special pages folder (which has to be named pages) and then you are structuring that folder to define the routes and path you page supports.
         - This allows you to get rid of extra code i.e. less code, less work and highly understandable concept (i.e. similar to how you started with web development using vanilla HTML, CSS and JavaScript files).
         - NextJS still supports all the features you might want such as nested routes or dynamic routes with dynamic parameters, etc.
      3) Fullstack Capabilities:
         - NextJS makes it easy for us as a developer to add backend code to React projects so as to build a Full Stack React Projects.
         - You can build a Full Stack React Projects where you don't just have the client side code maybe with Server Side Pre-rendering but where you also have standalone backend code that for example works with the file system or reaches out to a database. NextJS makes it easy to add your own backend API into your React Project using NodeJS code.
         - This makes it easy to add code for storing data to a database/files, retrieving data, adding authentication, etc. using NextJS.
         - Therefore, can do not need to build a standalone REST API project but can stay in one NextJS project (you would need to have some NodeJS coding knowledge but that is a requirement for building on the backend) where you have all the client side code (React UI) and also blend in your backend API code.
   > There are more features but the three mentioned above are the core/key features of NextJS and why you would want to use this framework to build a production React application.

------------------------------------------------------------------------------------
2. Creating a New NextJS Project App and Analysing the Project Setup:
------------------------------------------------------------------------------------
   > To create a NextJS project you would need to run one simple command in the terminal (cd to the path you want to create and store the new NextJS project directory):

   Install NextJS with NPM Command:
      $: npx create-next-app

   > To run the command you need NodeJS installed on your machine which you can download and install from their website (https://nodejs.org/en/). This comes with the Node Package Manager which allows you to install files from the web using the npm install command.
   > NextJS uses NodeJS under the hood to run JavaScript code on a machine i.e. server; for example, the server side rendering uses NodeJS. Therefore, it is a pre-requisite for NextJS projects.
   > Alternatively, if you have Yarn (https://yarnpkg.com/) installed as a Package Manager you can use the yarn command instead to install the NextJS project files.
   > After answering a few basic questions about the application it will create a new NextJS project directory within the directory path you ran the terminal command from.
   > Once the base NextJS project has been created with all of the core required dependencies you can run the following command to start your development server.

   Running NextJS Development Server Command:
      $: npm run dev

   > You are now ready to start building your NextJS application using the IDE of your choice (e.g. Open the NextJS project folder Visual Studio). Let us now analyse the different folders that make up the NextJS project:
      - The "styles" folder contains all of the CSS files of the project
      - The "public" folder contains all of the public assets/resources of the project (e.g. images, logos, etc.)
         > You will notice that there is no "index.html" file which we see in a React project. NextJS has built-in pre-rendering and while it gives you a single page application, that single page is dynamically pre-rendered when a request reaches the server so that an initial page with content is served (i.e. NextJS allows us to determine when a page should be pre-rendered).
      - The "pages" folder is the most important folder and a reserved folder name. This is where you would setup the file base routing i.e. this is where you would define the different pages that should make up the application.

      Pages/_app.js:
         function MyApp({ Component, pageProps }) {
            return <Component {...pageProps} />
         };
         export default MyApp;

   > The "_app.js" File in the "pages" folder is an important and special file. This is like the root Component which NextJS will render. It receives props and uses Object de-structuring to pull information out of the props and the information it pulls out is a 'Component' prop and 'Page' prop. These props are passed into the 'MyApp' Component automatically by NextJS since NexJS is the thing that is using that specific Component. 'Component' is the prop that holds the actual page content that should be rendered (i.e. it will be different whenever you switch a page). 'Page' is the specific props the page might be getting.
   > You can delete the boilerplate template codes such as "Home.module.css" file (from the "styles" folder), the "api" folder and the "index.js" file (from the "pages" folder).
   > You now have a starting NextJS directory to build out your NextJS application code.

------------------------------------------------------------------------------------
3. Adding Pages, Nested Paths & Pages, Dynamic Pages (with Parameters) and Extracting Dynamic Parameter Values:
------------------------------------------------------------------------------------
   > In NextJS ,if you wanted to build a simple website with three kinds of pages (e.g. a root/landing page, a list item page and a detail page for the listed item), to build this kind of structure in NextJS you would create three files in the "pages" folder.
   > The 'index.js' file is the root page. Therefore, if a URL reached "www.domain-name.com/" then the 'index.js' file will be loaded. This is in line with standard websites where the 'index.html' file is served if a request targets the root domain name only (i.e. "/"). It is important to note that 'index' is a special name reserved for the root domain.
   > The "news.js" file will be loaded if the URL reached "www.domain-name.com/news". The pathname after the forward slash will be the JavaScript file name and in this example it was "/news" which will server the "news.js" file.
   > What goes inside of these pages are the React Components that should be loaded for that specific page. Therefore, you can add a Component functions as you would using React.

   Adding a Page Example:
      pages/index.js:
         function HomePage() {
            return <h1>The Home Page</h1>;
         };
         export default HomePage;
or
      pages/Home.js:
         const HomePage = () => {
            return <h1>The Home Page</h1>;
         };
         export default HomePage;

   > You can use either function expressions syntax when creating functions in JavaScript.
   > You must 'export default' the Component so that NextJS is able to find the Component code.
   > Inside of the Component you must return JSX code just as you would do in React Components.
   > NextJS projects support modern React development whereby you do not need to define 'import React from 'react';' because it does this for you behind the scenes and therefore can be omitted.
   > Running th dev server and going to "http://localhost:3000/" will load the HomePage Component. Inspecting the Page Source you should notice that the HTML page is not an empty skeleton but rather it contains actual page content. This is an important difference to a standard React application where the page is not pre-rendered on the server.
   > The HTML code you see is the actual HTML code returned back by the server. The advantage of this is that you do not see any flickering of the page while you wait for the the response and in addition it is viewable for SEO.
   > This is how you can get started by creating pages and routing in NestJS without any extra setup because it works out of the box.
   > There is an important alternative you should be aware of when it comes to organising your files and folders. Folders also act as path segments and it is entirely up to you how you want to organise your file/paths structure.

   Adding a Page Alternative Example:
      pages/news/index.js:
         function NewsPage() {
            return <h1>The News Page</h1>;
         };
         export default NewsPage;

   > You could create a subfolder inside of the pages folder and name that folder the path segment name (i.e. route), for example "news". Within this folder you can now hold the "index.js" file which will be served whenever a user navigates to "www.domain-name.com/news" path segment.

   Nested Paths & Routes Example:
      pages/news/detail.js:
         function DetailPage() {
            return <h1>The Detail Page</h1>;
         };
         export default DetailPage;
or
      pages/news/detail/index.js:
         function DetailPage() {
            return <h1>The Detail Page</h1>;
         };
         export default DetailPage;

   > If you want to create nested paths/routes it is important to created nested segments folders. Therefore, if you wanted to create a route for "www.domain-name.com/news/detail" you would need to create a "news" folder inside of the "pages" folder and the root page for the "/news" route will be served the 'index.js' while the "/news/detail" will be served the "detail.js" file located inside the sub folder.
   > Alternatively, you could also create a subfolder inside of the "news" folder and call it "detail" which will hold the 'index.js' file for the "DetailPage" Component which will also create the nested path route segment for "www.domain-name.com/news/detail".
   > You may realise a problem with this approach when it comes to dynamically loading content on the detail page i.e. to reuse the DetailPage Component but output different results for different news content. Hardcoding the identifier is not very realistic. Instead you want to create a so-called dynamic page whether the path segment to the concrete path can be dynamic.

   Dynamic Page with Parameters Example:
      pages/news/[newsID].js:
         function DetailPage() {
            return <h1>The Detail Page</h1>;
         };
         export default DetailPage;
or
      pages/news/[newsID]/index.js:
         function DetailPage() {
            return <h1>The Detail Page</h1>;
         };
         export default DetailPage;

   > The square brackets in front of the file extension is a special syntax within the file name which is understood by NextJS to mean that the page is a dynamic page.
   > Note: You can also have name folder using the square brackets syntax to create a Dynamic Page with Parameters.
   > This allows you to load the same page no matter what the concrete value is but inside of the page you have access to that dynamic value (i.e. parameter) in the path so that you can fetch the data for that parameter.
   > The identifier name inside the square brackets is entirely up to you.
   > If a person visits "www.domain-name.com/news/detail" or "www.domain-name.com/news/something-important" or anything else after the "news/" will be served the same "[newsID].js" page. This is how you can add dynamic paths and another key feature to NextJS. It is a feature that allows you to build truly dynamic and flexible websites with NextJS.
   > How can you now extract this entered path/parameter value inside of the Component so that you can for example fetch the correct news item from a database when a user visits this page?

   Extracting Dynamic Parameter Values Example:
      pages/news/[newsID].js:
         import { useRouter } from 'next/router';
         function DetailPage() {
            const router = useRouter();
            console.log(router.query.newID);
            return <h1>The Detail Page</h1>;
         };
         export default DetailPage;

   > NextJS provides a special React Hook you can use to extract dynamic parameter values from the visited URL for the Component file. This works for React Function Components.
   > Important Note: there is also an alternative for React class-based Components i.e. using a Higher Order Component that you can wrap around your Components.
   > The next/router is a sub-package which exposes routing specific functionality.
   > The 'useRouter' Hook is a regular React Hook (just one that is not built into React but a custom Hook built by the NextJS team). You can call this Hook and get access to a router object which you can store in a variable.
   > On the router object you get certain pieces of properties and methods which you can call. For example, you have methods for programmatic navigation as well as access to values encoded in the URL. The 'query' property gives access to a nested object and on this 'query' property you would have the identifier which you chose between the square brackets in the dynamic pages Component file name.
   > In the above example ".newsID" (from "[newsID].js") is a property held on the ".query" property object. This will hold the concrete value in the URL for the dynamic segment for which the page was visited.
   > The 'useRouter' Hook runs twice because it runs immediately when the page is first rendered (at this point it does not know what is in the URL) but once it has the URL information the Component is rendered again and then you will have the concrete value for the dynamic parameter. This is just how this Hook works and hence the console prints 'undefined' and then the concrete value from the URL.

------------------------------------------------------------------------------------
4. Linking Between Pages:
------------------------------------------------------------------------------------
   > Currently the user always has to enter the URL manually in the browser to render a page for the NextJS application. This is not how users would use websites instead there are links that allow users to navigate around.

   Linking Between Pages Example:
      pages/news/index.js:
         import { Fragment } from 'react';
         function NewsPage() {
            return(
               <Fragment>
                  <h1>The News Page</h1>
                  <ul>
                     <li><a href="news/nextjs-is-a-framework"><li>NextJS is a Framework</li></a><li>
                     <li><a href="news/reactjs-is-a-library"><li>React JS is a Library</li></a><li>
                  </ul>
               </Fragment>
            );
         };
         export default NewsPage;

   > React Fragment is used to wrap sibling Component without having to use a <div> element unnecessarily to overcome JSX limitation of returning a single parent element.
   > In vanilla HTML you would use anchor tags to wrap around your element to create a link and the <a> element has a 'href' property which points to the URL path to navigate to when the link is clicked.
   > The list could be generated dynamically by mapping some array data into JSX elements (the above is just hardcoding values for simple demonstration to focus on navigation feature in NextJS).
   > While this would work in NextJS, this syntax is the second best way to navigate of navigating around in a NextJS App. This method always sends a new request to the server and gets back a new HTML page. While it works it has the disadvantage i.e. you no longer have a Single Page Application and are always sending a new request to the backend server to request a new HTML page whenever the user navigates around.
   > While it is great that we have the pre-rendered pages so that when the user initially visits the website  some content is there right from the start which is great for SEO, but if the user is on the page already and then navigates around on it we want to stay in that Single Page Application because that allows us to preserve the state across pages and give the user a better more reactive user experience. This is one of the reasons for using React. Below is an alternative navigation provided by NextJS:

   Linking Between Pages Alternative Example:
      pages/news/index.js:
         import { Fragment } from 'react';
         import Link from 'next/link';
         function NewsPage() {
            return(
               <Fragment>
                  <h1>The News Page</h1>
                  <ul>
                     <li><Link href="news/nextjs-is-a-framework">NextJS is a Framework</Link><li>
                     <li><Link href="news/reactjs-is-a-library">React JS is a Library</Link><li>
                  </ul>
               </Fragment>
            );
         };
         export default NewsPage;

   > The next/link is a sub-package which exposes linking specific functionality.
   > The 'Link' Component (a default export) is a special Component which you can use inside of your JSX code to build links. You would use this instead of an anchor element. The 'Link' Component expects a 'href' prop which sets the target destination for the 'Link'. This by default will render an anchor element and everything will continue to work.
   > The browser no longer refreshes the page when using the Links on the page. The user will instantly go to the page without requesting a new HTML page providing a Single Page Application experience. The visible content on the screen is re-rendered by React instead.
   > This method allows you to combine the best of both worlds. You have a highly interactive and reactive Single Page Application where you can manage and store state across pages and yet if the user was to visit the page as an initial page by just entering the URL in the browser you will also be able to return the finished HTML page here. If the user is already on the news page and click the link the user stays on the Single Page Application.
   > The 'Link' Component creates an anchor tag but it watches for clicks on those anchor tags and if you click on them it prevents the browsers default of sending a request and getting a new HTML page. Instead, it will load the to be loaded Component for you and change the URL so that it looks like you changed the page whilst in reality you stayed in that Single Page Application.
   > Therefore, for internal links in a NextJS application you would want to use the Link Component instead of the anchor tag element because the Link Component provides the best of both worlds.

   Programmatically Navigate to Pages Example:
      import { useRouter } from 'next/router';
      import Card from '../ui/Card';
      import classes from './MeetupItem.module.css';
      function MeetupItem(props) {
         const router = useRouter();
         function showDetailsHandler() {
            router.push('/' + props.id)
         };
         return (
            <li className={classes.item}>
               <Card>
                  <div className={classes.image}><img src={props.image} alt={props.title} /></div>
                  <div className={classes.content}><h3>{props.title}</h3><address>{props.address}</address></div>
                  <div className={classes.actions}><button onClick={showDetailsHandler}>Show Details</button></div>
               </Card>
            </li>
         );
      };
      export default MeetupItem;

> The 'useRouter' Hook from 'next/router' provides the router object which has different methods you can use. For example the '.push()' method allows you to programmatically navigate to different routes. The '.push()' method pushes a page onto the stack of pages and this is the equivalent to using the 'Link' Component.
> You can use this alternative if you do not want to use 'Link' but want to programmatically navigate to a different URL page.
> The '.push()' method takes in string path to which you want to navigate to as an argument/parameter. You can create a dynamic path utilising props and the URL parameters values.
> In the above example the button has a 'onClick' event which triggers the showDetailsHandler function which programmatically navigates the user to a details page using the passed in props id. It is important to note that you can also create Links 'href' values programmatically as well. But remember that you are not limited to using 'Links' to navigate users to different pages.

------------------------------------------------------------------------------------
5. How Pre-Rendering Works & The Problems Faced with Pre-Rendering:
------------------------------------------------------------------------------------
   > If you want to send a HTTP request once the page is rendered you would typically use the useEffect Hook to control this side effect.

   Simulated HTTP Request with useEffect Hook Example:
      src/pages/index.js:
         import { useState, useEffect } from 'react';
         import MeetupList from '../components/meetups/MeetupList';
         const DUMMY_MEETUPS = [
            { id: 'm1', title: 'A First Meetup', image: 'https://image1.jpg', address: 'Boat Tour in Amsterdam', description: 'This is a first meetup'},
            { id: 'm2', title: 'A Second Meetup', image: 'https://image2.jpg', address: 'Coffee Shop in Italy', description: 'This is a second meetup'}
         ];
         function HomePage() {
            const [loadedMeetups, setLoadedMeetups] = useState([]);
            useEffect(() => {
               // send HTTP request and fetch data
               setLoadedMeetups(DUMMY_MEETUPS);
            }, []);
            return(<MeetupList meetups={loadedMeetups} />);
         };
         export default HomePage;

   > In the above example, if we pretend that the "DUMMY_MEETUPS" was some data coming from a database. The 'useEffect' Hook would send a http request (probably using the fetch API) to get the data from the server as a asynchronous task and once received the 'setLoadedMeetups' state function is used to set the "loadedMeetups" state with the returned data.
   > The useEffect Hook has no dependencies so that it would only run once on the first initial load of the Component page.
   > The 'useEffect' Hook is executed after the Component function was executed which is important to note. This would mean for the first time the Component was rendered the "loadedMeetups" state was an empty array. The 'useEffect' function would then execute updating the state and it would then trigger the Component function to execute again because the state had changed. This will cause the list to be re-rendered with the fetched data.
   > Therefore, there will be two render cycles. In the first render cycle the "loadedMeetups" state would be an empty array. The reason for emphasising this point is due to the problem with Search Engine Optimisations. The page source will show that the actual meetup data is missing and you only see the unordered list element only without any list elements.
   > The items the users would eventually see on screen in the list are missing from the page HTML pre-rendered code because of the fact that the data comes in at the second Component execution cycle. However, the pre-rendered HTML page generated by NextJS automatically does not wait for the second Component execution cycle.
   > NextJS pre-rendering always takes the first render cycle and returns that as the pre-rendered HTML code. NextJS does not wait for the data to be fetched from the server to then return the fully pre-rendered page.
   > This is a very important problem to understand properly when it comes to pre-rendering; but thankfully, NextJS has solutions to this problem. There are more core features built into NextJS to help you with this precise problem where you want to pre-render a page with data but with data for which you have to wait to be retrieved. You need to tell NextJS when you are done waiting.
   > How can you fetch data for pre-rendering? This is what we will explore in the next few sections.

------------------------------------------------------------------------------------
6. Data Fetching for Static Pages and Static Site Generation(SSG):
------------------------------------------------------------------------------------
   > NextJS has a built-in page pre-rendering feature but it has a flaw of rendering a snapshot of the HTML page after the first component render cycle as its content which might be missing crucial data.
   > While the built-in pre-rendering feature might be theoretically good for SEO it might not always be the case.
   > After the pre-rendered HTML page is received, React will actually take over and the page is 'Hydrated' (as this process is called) which means React will turn the page into a Single Page Application. The page is then updated by React inside the browser and not on the server. Therefore, you have a fully interactive page with all the data you need handled by React (e.g. useEffect fetching data and populating the list on screen).
   > If you want to pre-render a page with data so that the initial returned HTML code already contains the data you need to fine tune and configure the built-in pre-rendering process.
   > NextJS provides two forms of pre-rendering which you can use for controlling how the page should be rendered:
      1) Static Site Generation (SSG)
      2) Server Side Rendering (SSR)
   > The two forms of pre-rendering may sound similar but the code runs at different points in time.

   Static Site Generation (SSG):
   > This is the approach you should typically use for your application pre-rendering.
   > A page Component is pre-rendered when you build the application for production using the 'npm run build' script. With Static Generation the page is not pre-rendered on the fly on the server when a request reaches the server but instead it is pre-rendered when you as the developer build your application for production.
   > This means that after the application is deployed the pre-rendered page does not change (at least not by default).
   > If the data is updated and you know that the pre-rendered page needs to change then you would need to start the build process again and redeploy again with the new Static Pages.
   > This may sound worse than it actually is because for a lot of applications pages content do not change all the time and if it should change frequently then there are alternative (i.e. Server Side Rendering).
   > If you need to wait for data (adding data fetching to a page Component) you can do so by exporting a special function called 'getStaticProps' from inside of your Page Component file. This only works for Page Component files (Components located inside of the "pages" folder) and not in other Component files.
   > The exported function must be called 'getStaticProps' because it is a reserved name that NextJS would look for a function with that name when building the project for production. If it finds functions with this name in the Page Component files it will execute this function during the pre-rendering process.
   > Therefore, it does not directly call the Component function and use the returned JSX snapshot as the HTML content but instead it will first call the 'getStaticProps' function before it calls the Page Component function.
   > The 'getStaticProps' functions job is to prepare props for the page and these props could then contain the data the page needs.
   > The 'getStaticProps' function is allowed to be asynchronous and can return a promise. NexyJS will then wait for the promise to resolve (i.e. it waits until the data is loaded) and then it will return the props for the Page Component function. This allows data to be loaded before the Component can be rendered with the required data.
   > In the 'getStaticProps' function you can run any code that would normally only run on a server e.g. accessing a file server or securely connecting to a database. Any code you write in this function will never execute on the client side simply because the code is executed during the build process not on the server and not on the client. Therefore, the code will never visit the client or server.

   Static Site Generation (SSG) Example:
      src/pages/index.js:
         import MeetupList from '../components/meetups/MeetupList';
         function HomePage(props) {
            return(<MeetupList meetups={props.meetups} />);
         };
         export async function getStaticProps(){
            // fetch data from an API
            return {
               props: {
                  meetups: DUMMY_MEETUPS
               }
            };
         };
         export default HomePage;

   > The 'getStaticProps' function must always return an object. On this object you can configure a lot of things but most importantly you typically set a 'props' property (and must be named 'props'). The 'props' property holds another object which will be the 'props' object you receive in your Page Component function.
   > The structure of the props object is entirely up to you. In the above example there is a "meetup" key which holds the "DUMMY_MEETUPS" data.
   > The props data will be loaded and prepared in the 'getStaticProps' function and then they would be set as 'props' for the Page Component function (e.g. "function HomePage(props)").
   > Therefore, you no longer need to manage state using useState or retrieve the data from a database using useEffect because the data now comes via 'props' that is passed from the 'getStaticProps' function.
   > This is how you can move the data fetching away from the client-side to the build process. If you now view the page source of the pre-rendered HTML page you should no longer see an empty unordered list. The HTML page contains the full HTML code for what is displayed on the page which is great for SEO.
   > The data is no longer fetched in a second Component render cycle on the client but now initial before the page is pre-rendered during the build process.
   > SSG is one of the main key features of NextJS. The 'getStaticProps' is a function you would use a lot with NextJS projects.

   Running the NPM Build Script Command:
      $: npm run build

   > This is the script you would run within your terminal while cd in your NextJS project directory location. You would run this script before deploying your project onto your production server when you are ready to deploy your NextJS project. A new folder called '.next' will be created in the project containing the optimised production code ready to be deployed to a production server.
   > In the terminal once the command has completed its execution you will see a list of Page it created during the build process. These are the Static Pages for your application code. You will also notice it also generates a 404 Page (for invalid URLs) for you.
   > Each page has a dot next to the name. A filled dot denotes a Statically Generated Site (i.e. SSG) page which was automatically generated as a HTML. An empty dot denotes a Static Generated page.
   > A Static Generation is almost similar to a Statically Generated Site but the only difference is that there are no initial props (i.e. no initial data that was fetched).
   > Page Components which have the 'getStaticProps' function will be a SSG Page and will be denoted with a filled dot.
   > The potential problems that you can face when using the 'getStaticProps' function is that for some websites (depending on what you are doing) the data could be outdated. In the above example, if you add more meetups to the database, the pre-generated page would not know about the new data. If there are no client side data-fetching then you would only see the outdated data being displayed and this can be a problem.
   > You can always re-build the site and redeploy when the data changes and for some websites like personal blogs this is a great alternative because data does not change too frequently.
   > If data does change more frequently there is an extra property you could add to the returned object from the 'getStaticProps' function. The 'revalidate' property unlocks a feature called incremental Static Generation. This property requires a number which is the number of seconds NextJS will wait until it regenerates the page for an incoming request.

   Static Site Generation (SSG) with Server Revalidate SSG Generations Example:
      export aync function getStaticProps(){
         return {
            props: {
               meetups: DUMMY_MEETUPS
            },
            revalidate: 10
         };
      };

   > In the above example, the page will not just be generated during the build process but it will also be generated every couple of seconds on the server (at least if there are requests for the Page Component). The re-generated pages will replace the old pre-generated pages. This will ensure the data is never older than 10 seconds. Therefore, the number you use depends on your data update frequency.

------------------------------------------------------------------------------------
7. Data Fetching for Server Side Rendering (SSR):
------------------------------------------------------------------------------------
   > The 'getStaticProps' function is a very useful function which you can export in your Page Components to ensure that the pre-rendered pages contain data you might need to wait for. The 'revalidate' property ensures that the page is also updated regularly after deployment but sometimes even a regular update is not enough.
   > Sometimes you really want to update the page for every incoming request i.e. pre-generate the page dynamically on the fly on every request after deployment on the server (not during the build process and not every couple of seconds/minutes/hours duration).

   Server Side Rendering (SSR) Example:
      export async function getServerSideProps(context) {
         const req = context.req;
         const res = context.res;
         // fetch data from an API
         return {
            props: {
               meetups: DUMMY_MEETUPS
            }
         };
      };

   > The exported 'getServerSideProps' function is a reserved name which NextJS will look for in Page Components. This function will not run during the build process but instead always on the server after deployment.
   > The 'getServerSideProps' function always returns an object with a 'props' property (the same as the 'getStaticProps' function) because the function is still all about getting props for the Page Component. You can therefore continue to run any code including asynchronous code such as fetching data from the file system or a database, etc. Any code you write here will always run on the server and never on the client.
   > You can therefore run server side code as well as perform operations that use credentials that should not be exposed to the users. This is because this code only ever runs on the server and not on the client machine so the client will never see this code.
   > You cannot set a 'revalidate' property on the 'getServerSideProps' function return object because it does not make any sense to have such a property. The 'getServerSideProps' function runs for every incoming server side request so it does not require any revalidation for whatever duration in seconds.
   > The 'getServerSideProps' function can receive a 'context' argument/parameter (note: you also get access to this parameter with the 'getStaticProps' function). The 'context' argument/parameter has a request object (under 'req' key) as well as the response (under the 'res' key). If you work with NodeJS the 'res' and 'req' keys might look familiar to you.
   > Having access to the concrete request object can be useful for example when working with authentication and you need to check some session cookie or anything of the sort like this. The request object provides access to all the incoming request and all of its headers and request body if you need that information (i.e. that extra data can be used as extra information required for the code that needs to execute in 'getServerSideProps').
   > Ultimately, you do not send a response by working on that response object but instead you return the object with the 'props' property key which then holds an object of all the 'props' for the Page Component function to receive. This is how you can use 'getServerSideProps' for preparing that data for the page.
   > You will notice that everything works the same as before with 'getStaticProps' and you would still receive a HTML page with all the content (i.e. the unordered list with list item elements) in the served page source.
   > The 'getServerSideProps' may sound better to use because it guarantees to run for every request but that can also be a disadvantage. You would need to wait for the page to be generated on every incoming request because of the (SSR).
   > If you do not have data that changes frequently or you do not need access to the request object then the 'getStaticProps' (SSG) method is better. The pre-generated static HTML file can be stored and served in a CDN which is simply much faster than regenerating and fetching the data for every incoming request on the server.
   > Page fetching/loading is faster when working with 'getStaticProps' compared to with 'getServerSideProps' because the static page can be cached and reused instead of being regenerated all the time.
   > Hence, you should only use the 'getServerSideProps' (SSR) method if you need access to the concrete request object (i.e. 'req') because you do not have access to the request and response in the 'getStaticProps' (SSG) method or that you have data that changes multiple times every second and even the 'revalidate' property on the return object of 'getStaticProps' will not help you.

------------------------------------------------------------------------------------
8. Working with Dynamic Params for SSG Data Fetching:
------------------------------------------------------------------------------------
   > Imagine if you needed to fetch some data based on a parameter encoded in the URL (as a parameter) such as the id of the record you wish to identify and retrieve from a dashboard. The problem you face with fetching data using SSG (or SSR) is that you cannot use the 'useRouter' Hooks (or any Hooks) outside of a Component function. The 'getStaticProps' function is not a Component function this would invalidates the rule for using React Hooks.

   Extracting Parameters in SSG/SSR Data Fetching Example:
      src/pages/[meetupID]/index.js:
         import MeetupDetail from '../../components/meetups/MeetupDetail';
         function MeetupDetails() {
            return(
               <MeetupDetail
                  image="https://image1.jpg"
                  title="First Meetup"
                  address="1 Fake Road, Fake City"
                  description="This is a first meetup"
               />
            );
         };
         export async function getStaticPaths() {
            return {
               paths: [
                  { params: { meetupID: 'm1'} },
                  { params: { meetupID: 'm2'} }
               ]
            }
         };
         export async function getStaticProps(context) {
            const meetupId = context.params.meetupID;
            console.log(meetupId);
            // fetch data for a single meetup
            return {
               fallback: false,
               props: {
                  meetupData: {
                     id: meetupId,
                     image='https://image1.jpg',
                     title: 'First Meetup',
                     address: '1 Fake Road, Fake City',
                     description: 'This is a first meetup'
                  }
               }
            };
         };
         export default MeetupDetails;

   > This is not a problem because the 'getStaticProps' and 'getServerSideProps' receive a context argument/parameter which you can use.
   > The 'context' argument/parameter passed to 'getStaticProps' will not hold the 'request' and 'response' object unlike with 'getServerSideProps'. However, the context argument/parameter will have a 'params' key for either functions.
   > The 'context.params' is an object where the identifiers between square brackets (e.g. meetupID) will be properties and the values will be the actual values encoded in the URL.
   > This would then allow the function to retrieve a concrete id which can then be exposed as a prop to the page Component. However, this is not enough to make it work as this will throw an error "getStaticPaths is required for dynamic SSG pages and is missing for [Component File Name]".
   > The export 'getStaticPaths' is another function NextJS understands and must be exported in the Page Component file if the page is Dynamic and you are using 'getStaticProps'.
   > The 'getStaticPaths' is not needed for 'getServerSideProps' or if you are not using i.e. exporting either 'getStaticPaths' or 'getServerSideProps' in your Dynamic Page Component function.
   > The 'getStaticPaths' function can also be an asynchronous function.
   > Why do you need 'getStaticPaths' with a dynamic page that uses 'getStaticProps'? With 'getStaticProps' a page is pre-generated during the build process and therefore NexJS needs to pre-generate all versions of the dynamic page in advance for all supported IDs. Since the Param is dynamic NextJS needs to know for which ID it should pre-generate the page - how would it pre-generate the page otherwise?
   > Keep in mind the Dynamic Page Component is not pre-generated when a user visits the page with a specific value in the URL but rather during the build process. Therefore, you need to pre-generate for all the URLs (e.g. all the meetupID values) the users might be entering at runtime. If the user enters an ID that was not pre-generated a page then a 404 page error page will be displayed instead.
   > Therefore, the 'getStaticPaths' function has the job of returning an object where you describe all the dynamic segment values for which this page should be pre-generated.
   > The 'getStaticPaths' return object needs a 'paths' key which holds an array which objects for each version of the dynamic page. This object has a 'params' key which then itself is again an object with all the key:value pairs that might lead to the dynamic page.
   > In the above example there is only one dynamic param path ([meetupID]) which is listed with its concrete id. If the URL have multiple dynamic params path, the 'params' key object will hold a list of each dynamic path as keys with the potential concrete value as its value. This is repeated for all possible dynamic path variations you would wish to pre-generate pages for.
   > In reality you would not hardcode these values but rather fetch your supported IDs from a database/API and then generate the array dynamically. But for demonstration purposes the above example shows how this return object would look like for each dynamic path you would want to pre-generate a SSG for at the build process.
   > The 'getStaticPaths' function return object also expects a 'fallback' property which tells NextJS whether the 'paths' array contains all supported parameter values or just some of them. Setting the 'fallback' parameter to false will tell NextJS that the 'paths' array contains all supported meetupID values. If a user enters anything that is not supported the user would see the 404 error page. If you set 'fallback' property to true then NextJS would try to generate a page for the meetupID dynamically on the server for the incoming request.
   > The 'fallback' is a nice feature because it allows you to pre-generate some of your pages for certain values and then pre-generate the missing values dynamically when requests for them are coming in. This is useful so that you do not have to pre-generate all pages (especially if you have 100 of IDs) but rather pre-generate the most popular pages.
   > The export of 'getStaticPaths' function must come before the 'getStaticProps' function. This ordering is important because the 'getStaticProps' is executed for every page returned by the 'getStaticPaths' function.
   > Note that the 'console.log(meetupId)' would be printed in the terminal console and not in the browser JavaScript console because the 'getStaticProps' runs at build time on the server (i.e. on the developer server using NodeJS to run JavaScript code on the server) and not on the client browser.
   > This concludes how 'getStaticProps' and 'getServerSideProps' works for pre-generating pages rather than using the default built-in pre-rendering of NextJS and how you can configure these functions to work. Note: the return object to these functions have many parameters which you can read up on in the official NextJS documentations for these functions and their return object settings.

------------------------------------------------------------------------------------
9. Introducing API Routes:
------------------------------------------------------------------------------------
   > NextJS makes it easy to build a backend API together with your front-end React Application in the same project which is a major key feature for using the NextJS framework.
   > API Routes are a special endpoint routes (special pages) which do not return HTML code but which are instead about accepting incoming HTTP requests (e.g. GET, POST, PUT, PATCH, UPDATE, DELETE requests) with JSON data attached to them which then might do whatever you need them to do for example storing the data in a database and then return the JSON data.
   > Therefore, you could say that API Routes allow you to build your own API end points as part of your NextJS project and then it would be served by the same server as your NextJS Application.
   > To add API Routes you add a special folder to your pages folder called 'api'. Just as with the "pages" folder the "api" folder must be named "api" and must be contained inside of the "pages" folder. This tells NextJS that the files contained in this folder are API Route files.
   > The file names inside of the "api" folder will act as path segments in the URL.
   > The JavaScript files located in the "api" folder must not be React Component functions. The API Routes files are not about defining, rendering or retuning React Components. Instead you will define function that contain server-side code. This is because API Routes will only run on the server, never on the client and will never be exposed to the client. Therefore, you can use credentials inside of an API Routes without compromising them.
   > These functions are simply triggered whenever a request is sent to the API Routes.

   API Routes File Example
      src/pages/api/new-meetup.js:
         function handler(req, res) {
            if(req.method === 'POST') {
               const data = req.body;
               const { title, image, address, description } = data;
               // Store the incoming data in a database.
            };
         };
         export default handler;

   > The new-meetup JavaScript file functions will execute when the user sends a request to "www.domain-name.com/api/news-meetup"
   > Often the name of the functions in API Route files is called "handler" but the name is entirely up to you but it is important that the function is exported as the default export.
   > The API Route function will receive a request ('req') and response ('res') objects as argument/parameters to the function. You might know this from NodeJS and ExpressJS.
   > The request object holds information about the incoming request while the response object is required for sending back a response to the incoming request.
   > from the request object you can get information such as the request headers, request body, request method, etc. The 'req.method' property allows you to see what type of request was sent.
   > In the above example the conditional statement checks the type of request that is sent and only if it is a POST request will the function execute that code block.
   > The 'req.body' contains the body of the incoming request (i.e. the data of the incoming request).
   > You can then do whatever you want inside of the function that you need to do. You can decide whatever data you would expect to receive for the endpoint since it is you page, your project and your API (you can expect whichever data you need).
   > The above example uses object destructuring to extract values from the object to store as individual variable of the same name. You can then save that data to a database as an example of what the API Route.
   > This is how you can build API Routes using NextJS within a single project.