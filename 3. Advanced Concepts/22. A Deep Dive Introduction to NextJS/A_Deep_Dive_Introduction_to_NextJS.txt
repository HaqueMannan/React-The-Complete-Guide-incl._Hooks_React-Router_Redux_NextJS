A Deep Dive Introduction into Next.js - Summary:
1. What Is and Why Use Next.js?
2. Creating a New NextJS Project App and Analysing the Project Setup
3. Adding Pages, Nested Paths & Pages, Dynamic Pages (with Parameters) and Extracting Dynamic Parameter Values

------------------------------------------------------------------------------------
1. What Is and Why Use Next.js?:
------------------------------------------------------------------------------------
   > NextJs offers a lot of features that makes building large scale production ready React applications easier i.e. it is a React framework for production.
   > React is a JavaScript library for building user interfaces i.e. it is a third part package which you can add to your front end projects (client side JavaScript code) to build interactive User Interface (UI). This is a library that makes building complex UI much easier than it would be with just vanilla JavaScript. It is a library because it focuses on that UI part through Component, State and Props.
   > If you want to build large scale React projects, you typically want to also need to add extra libraries for routing, authentication, etc.
   > NextJS is labelled a Framework. It is a framework that build up on React.
   > The difference between Framework and Library is that a Framework is bigger, has more features and focuses on more things and it provides clear rules/guidance on how you should write your code, structure files and so on.
   > NextJS goal is to solve the common problems of building production React apps and it enhances React by adding many core features which you would have had to add on your own in React for example routing.
   > Therefore, you no longer need to reinvent the wheel because a lot of the feature you would typically need for a production React applications is available right out of the box and you would not need to add as much third part libraries to solve common problems which is needed in larger applications.
   > What are the key features and benefits of a NextJS applications?
      1) Server Side Rendering:
         - This is the most important and key feature NextJS adds. Server Side Rendering is all about preparing the content of a page on the server instead of on the client. If you inspect a regular client side React applications you would see a very bar-bones HTML page with a <div id="root"> element which the React applications is loaded and rendered to. All of that rendering is done by React and done on the client side JavaScript i.e. inside of the browser of the user and not on the server.
         - This may not be a problem but it can also be a problem. For example, if your page also fetches some data from a server that should be displayed then the user might initially see some loading state (i.e. a flickering page for a fraction of second whilst the request is on its way fetching the data). Data fetching only begins once the JavaScript code executed on the client and you still need to wait for the outgoing response for that request, simply because the page which you requested did not contain that data already. This might not necessarily be a problem but it may not also be the user experience you want for your users.
         - This can be a problem for Server Engine Optimisation (SEO). This does not matter for all pages for example if you have an administration dashboard which is only reached by logging in then SEO does not matter because it will never see the dashboard as it is highly user specific requiring login. However, if you have a public facing page with a lot of content that should be found through search engines then SEO does matter.
         - The search engine crawlers will only see the empty HTML page when scanning your application pages that you are getting from the server and therefore will be ranked very low on search engine results.
         - Server Side Rendering can help you on this because if the page would be pr-rendered on the server (e.g. the data fetching occurs on the server) and the finished page would be served to the users and the search engine crawlers then the user will not see that flickering loading state and search engines would see the page content. This is a problem Server Side Rendering solves.
         - ReactJS actually has built-in features that allow you to add server-side rendering but it can be tricky to get this right. It also requires extra setup from your side. However, with NextJS it comes way easier because it has built-in server side rendering. NextJS automatically renders your pages and this means that if you build a standard NextJS app (without any extra setup from your side) if you visit such a page, it was pre-rendered on the server by default out of the box.
         - If you inspect the source code of a page from a NextJS application, you would see the HTML page rather than an empty HTML skeleton which is great for SEO and also helps with User Experience (UX) of not seeing that flickering load state.
         - It is worth noting that with NextJS, after the initial load/request, you still get a standard Single Page React application running in the browser. Subsequent navigation actions by the user are all handled by React within the browser to have this fast interactive UX which you typically want to offer with React applications.
         - NextJS blends client-side and server-side code together. This on its own is probably already a strong benefit/reason for why you might want to use NextJS for building React Projects instead of just ReactJS.
      2) File-Based Routing:
         - In traditional React you do not have a router, instead you give an illusion of having multiple pages. When you navigate around and load different pages then that is the job of a router (typically using React Router). The router basically watches the URL and when it changes it basically prevents the browser's default behaviour of sending a request to some backend server. Instead, it renders different content on the page (i.e. Components) with React.
         - Routing is basically changing what is visible on the screen based on the URL without sending a extra request to a server because you stay in that single page application which is typically built with React.
         - In React, Routing is setup in code and while it is not bad or wrong it is extra code which you have to write. Then often, you end up storing your Components that act as pages in a separate folder which kind of replicates your routes setup in code (e.g. if your have three pages setup as pages in code you would then have three page Components in the pages Component folder).
         - NextJS gets rid of that in-code route definition. Instead, you define pages and routes with files and folders instead of code. NextJS applications have a special pages folder (which has to be named pages) and then you are structuring that folder to define the routes and path you page supports.
         - This allows you to get rid of extra code i.e. less code, less work and highly understandable concept (i.e. similar to how you started with web development using vanilla HTML, CSS and JavaScript files).
         - NextJS still supports all the features you might want such as nested routes or dynamic routes with dynamic parameters, etc.
      3) Fullstack Capabilities:
         - NextJS makes it easy for us as a developer to add backend code to React projects so as to build a Full Stack React Projects.
         - You can build a Full Stack React Projects where you don't just have the client side code maybe with Server Side Pre-rendering but where you also have standalone backend code that for example works with the file system or reaches out to a database. NextJS makes it easy to add your own backend API into your React Project using NodeJS code.
         - This makes it easy to add code for storing data to a database/files, retrieving data, adding authentication, etc. using NextJS.
         - Therefore, can do not need to build a standalone REST API project but can stay in one NextJS project (you would need to have some NodeJS coding knowledge but that is a requirement for building on the backend) where you have all the client side code (React UI) and also blend in your backend API code.
   > There are more features but the three mentioned above are the core/key features of NextJS and why you would want to use this framework to build a production React application.

------------------------------------------------------------------------------------
2. Creating a New NextJS Project App and Analysing the Project Setup:
------------------------------------------------------------------------------------
   > To create a NextJS project you would need to run one simple command in the terminal (cd to the path you want to create and store the new NextJS project directory):

   Install NextJS with NPM Command:
      $: npx create-next-app

   > To run the command you need NodeJS installed on your machine which you can download and install from their website (https://nodejs.org/en/). This comes with the Node Package Manager which allows you to install files from the web using the npm install command.
   > NextJS uses NodeJS under the hood to run JavaScript code on a machine i.e. server; for example, the server side rendering uses NodeJS. Therefore, it is a pre-requisite for NextJS projects.
   > Alternatively, if you have Yarn (https://yarnpkg.com/) installed as a Package Manager you can use the yarn command instead to install the NextJS project files.
   > After answering a few basic questions about the application it will create a new NextJS project directory within the directory path you ran the terminal command from.
   > Once the base NextJS project has been created with all of the core required dependencies you can run the following command to start your development server.

   Running NextJS Development Server Command:
      $: npm run dev

   > You are now ready to start building your NextJS application using the IDE of your choice (e.g. Open the NextJS project folder Visual Studio). Let us now analyse the different folders that make up the NextJS project:
      - The "styles" folder contains all of the CSS files of the project
      - The "public" folder contains all of the public assets/resources of the project (e.g. images, logos, etc.)
         > You will notice that there is no "index.html" file which we see in a React project. NextJS has built-in pre-rendering and while it gives you a single page application, that single page is dynamically pre-rendered when a request reaches the server so that an initial page with content is served (i.e. NextJS allows us to determine when a page should be pre-rendered).
      - The "pages" folder is the most important folder. This is where you would setup the file base routing i.e. this is where you would define the different pages that should make up the application.
   > You can delete the boilerplate template codes such as "Home.module.css" file (from the "styles" folder), the "api" folder and the "index.js" file (from the "pages" folder).
   > You now have a starting NextJS directory to build out your NextJS application code.

------------------------------------------------------------------------------------
3. Adding Pages, Nested Paths & Pages, Dynamic Pages (with Parameters) and Extracting Dynamic Parameter Values:
------------------------------------------------------------------------------------
   > In NextJS ,if you wanted to build a simple website with three kinds of pages (e.g. a root/landing page, a list item page and a detail page for the listed item), to build this kind of structure in NextJS you would create three files in the "pages" folder.
   > The 'index.js' file is the root page. Therefore, if a URL reached "www.domain-name.com/" then the 'index.js' file will be loaded. This is in line with standard websites where the 'index.html' file is served if a request targets the root domain name only (i.e. "/"). It is important to note that 'index' is a special name reserved for the root domain.
   > The "news.js" file will be loaded if the URL reached "www.domain-name.com/news". The pathname after the forward slash will be the JavaScript file name and in this example it was "/news" which will server the "news.js" file.
   > What goes inside of these pages are the React Components that should be loaded for that specific page. Therefore, you can add a Component functions as you would using React.

   Adding a Page Example:
      pages/index.js:
         function HomePage() {
            return <h1>The Home Page</h1>;
         };
         export default HomePage;
or
      pages/Home.js:
         const HomePage = () => {
            return <h1>The Home Page</h1>;
         };
         export default HomePage;

   > You can use either function expressions syntax when creating functions in JavaScript.
   > You must 'export default' the Component so that NextJS is able to find the Component code.
   > Inside of the Component you must return JSX code just as you would do in React Components.
   > NextJS projects support modern React development whereby you do not need to define 'import React from 'react';' because it does this for you behind the scenes and therefore can be omitted.
   > Running th dev server and going to "http://localhost:3000/" will load the HomePage Component. Inspecting the Page Source you should notice that the HTML page is not an empty skeleton but rather it contains actual page content. This is an important difference to a standard React application where the page is not pre-rendered on the server.
   > The HTML code you see is the actual HTML code returned back by the server. The advantage of this is that you do not see any flickering of the page while you wait for the the response and in addition it is viewable for SEO.
   > This is how you can get started by creating pages and routing in NestJS without any extra setup because it works out of the box.
   > There is an important alternative you should be aware of when it comes to organising your files and folders. Folders also act as path segments and it is entirely up to you how you want to organise your file/paths structure.

   Adding a Page Alternative Example:
      pages/news/index.js:
         function NewsPage() {
            return <h1>The News Page</h1>;
         };
         export default NewsPage;

   > You could create a subfolder inside of the pages folder and name that folder the path segment name (i.e. route), for example "news". Within this folder you can now hold the "index.js" file which will be served whenever a user navigates to "www.domain-name.com/news" path segment.

   Nested Paths & Routes Example:
      pages/news/detail.js:
         function DetailPage() {
            return <h1>The Detail Page</h1>;
         };
         export default DetailPage;
or
      pages/news/detail/index.js:
         function DetailPage() {
            return <h1>The Detail Page</h1>;
         };
         export default DetailPage;

   > If you want to create nested paths/routes it is important to created nested segments folders. Therefore, if you wanted to create a route for "www.domain-name.com/news/detail" you would need to create a "news" folder inside of the "pages" folder and the root page for the "/news" route will be served the 'index.js' while the "/news/detail" will be served the "detail.js" file located inside the sub folder.
   > Alternatively, you could also create a subfolder inside of the "news" folder and call it "detail" which will hold the 'index.js' file for the "DetailPage" Component which will also create the nested path route segment for "www.domain-name.com/news/detail".
   > You may realise a problem with this approach when it comes to dynamically loading content on the detail page i.e. to reuse the DetailPage Component but output different results for different news content. Hardcoding the identifier is not very realistic. Instead you want to create a so-called dynamic page whether the path segment to the concrete path can be dynamic.

   Dynamic Page with Parameters Example:
      pages/news/[newsID].js:
         function DetailPage() {
            return <h1>The Detail Page</h1>;
         };
         export default DetailPage;

   > The square brackets in front of the file extension is a special syntax within the file name which is understood by NextJS to mean that the page is a dynamic page.
   > This allows you to load the same page no matter what the concrete value is but inside of the page you have access to that dynamic value (i.e. parameter) in the path so that you can fetch the data for that parameter.
   > The identifier name inside the square brackets is entirely up to you.
   > If a person visits "www.domain-name.com/news/detail" or "www.domain-name.com/news/something-important" or anything else after the "news/" will be served the same "[newsID].js" page. This is how you can add dynamic paths and another key feature to NextJS. It is a feature that allows you to build truly dynamic and flexible websites with NextJS.
   > How can you now extract this entered path/parameter value inside of the Component so that you can for example fetch the correct news item from a database when a user visits this page?

   Extracting Dynamic Parameter Values Example:
      import { useRouter } from 'next-router';
      function DetailPage() {
         const router = useRouter();
         console.log(router.query.newID);
         return <h1>The Detail Page</h1>;
      };
      export default DetailPage;

   > NextJS provides a special React Hook you can use to extract dynamic parameter values from the visited URL for the Component file. This works for React Function Components.
   > Important Note: there is also an alternative for React class-based Components i.e. using a Higher Order Component that you can wrap around your Components.
   > The next/router is a sub-package which exposes routing specific functionality.
   > The 'useRouter' Hook is a regular React Hook (just one that is not built into React but a custom Hook built by the NextJS team). You can call this Hook and get access to a router object which you can store in a variable.
   > On the router object you get certain pieces of properties and methods which you can call. For example, you have methods for programmatic navigation as well as access to values encoded in the URL. The 'query' property gives access to a nested object and on this 'query' property you would have the identifier which you chose between the square brackets in the dynamic pages Component file name.
   > In the above example ".newsID" (from "[newsID].js") is a property held on the ".query" property object. This will hold the concrete value in the URL for the dynamic segment for which the page was visited.
   > The 'useRouter' Hook runs twice because it runs immediately when the page is first rendered (at this point it does not know what is in the URL) but once it has the URL information the Component is rendered again and then you will have the concrete value for the dynamic parameter. This is just how this Hook works and hence the console prints 'undefined' and then the concrete value from the URL.