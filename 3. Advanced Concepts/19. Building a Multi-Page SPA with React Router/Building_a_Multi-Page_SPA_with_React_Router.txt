Building a Multi-Page SPA with React Router - Summary:
1. What is Routing & Installing React Router
2. Defining & Using Routes, Working with Links and Using NavLinks
3. Adding Dynamic Routes with Params and Extracting Route Params
4. Using 'Switch' and 'exact' for Configuring Routes
5. Working with Nested Routes
6. Redirecting the User
7. Implementing Not Found Page
8. Implementing Programmatic (Imperative) Navigation
9. Preventing Possible Unwanted Route Transitions with the 'Prompt' Component
10. Working with Query Parameters
11. Getting Creative with Nested Routes
12. Writing More Flexible Routing Code

------------------------------------------------------------------------------------
1. What is Routing & Installing React Router:
------------------------------------------------------------------------------------
   > When the path in the URL changes the URL loads different pages i.e. the visible content of the page also changes.
   > The combination of the different pages with their own paths that make up the overall website. This is how the web works and how the React application should work as well.

   Traditional Multi-Page Application:
      [/welcome]---------------URL Change--------------->[/products]
      [Welcome Page]-------Visible Content Change------->[Products Page]
      [welcome.html]---------Page Change = New---------->[products.html]
                           (Requests + Response)

   > When you have a traditional multi-page application where the server sends back different HTML files it will be typically be built with different HTML files on the server (or generating the files dynamically on the server) and then for the requests to the different URLs, different HTML pages are sent back to the client as the response. These pages are then rendered by the browser.
   > When you have different HTML pages you no longer have a single page application which means whenever you change the URL you leave the running client side application (losing all the state), wait for the request/response cycle and let the browser render the new page.
   > One of the reason switching to React is to move away from the traditional flow. Instead you want to load client side application (i.e. a JavaScript web app that runs in the browser) and utilise this application to change what is visible on the screen with JavaScript to provide an instant reactive user experience.
   > Fetching different HTML pages does not fit in with React Applications because it does not provide the reactive experience.

   Multi-Page Single Page Application:
                     [Single Page Application]
                              |
                              v
               [One initial HTML Request & Response]
                              |
                              v
      [URL changes handled by client side React Code]----->[Changes the visible content without fetching a new HTML file]

   > React allows you to build a Single Page Application (SPA) which allows you to have one initial HTML request & response. You can then look at the URL and manipulate the URL and path after the domain name with JavaScript.
   > You can use some client side React code to control the URL which would then change what is displayed on the screen when the URL changes without fetching a new HTML file providing a Multi-Page experience.
   > Therefore, you need some code that works on the URL (i.e. the path after the domain name) and then listens to clicks on the page to update that path into the URL. However, this does not actually send a request to the server for a new HTML file but instead blocks the browsers default behaviour and update what is visible on the screen with client side JavaScript i.e. React.
   > You need to write code that does all the above or you could use a Third-Party package that does it for you. There is a popular third-party package called "React Router" (https://reactrouter.com/) which you have to install separately. This package will provide this client-side routing feature to watch and manipulate the URL which the Component will render based on the URL.
   > To install React Router to your React project run the following command in the terminal while in the project directory.

   React Router Install Command:
      $: npm install react-router-dom

------------------------------------------------------------------------------------
2. Defining & Using Routes, Working with Links and Using NavLinks:
------------------------------------------------------------------------------------
   > Now that the 'react-router-dom' is installed to the React application you are now ready to start using routes.
   > Routing is basically like conditionally rendering a Component and may recall it being similar to using state to conditionally show a certain Component.

   "domain-name.com/"            => Renders Component A
   "domain-name.com/products"    => Renders Component B

   > You could write your own code to conditionally render Component based on the URL i.e. set your own states, listening to clicks on links and prevent the browser's default behaviour of sending a request, change some state to conditionally render something onto the screen, etc. The third-party 'react-router-dom' package does this all for us (i.e. we do not need to write our own code) and makes working with routes very easy.

   Using React-Router-Dom Example:
      src/pages/Welcome.js:
         import React from 'react';
         const Welcome = () => { return <h1>The Welcome Page</h1> };
         export default Welcome;
      src/pages/Products.js:
         import React from 'react';
         const Products = () => { return <h1>The Products Page</h1> };
         export default Products;
      src/App.js:
         import React from 'react';
         import { Route } from 'react-router-dom';
         import Welcome from './pages/Welcome';
         import Products from './pages/Products';
         const App = () => {
            return (
               <div>
                  <Route path="/welcome">
                     <Welcome />
                  </Route>
                  <Route path="/products">
                     <Products />
                  </Route>
               </div>
            );
         };
         export default App;
      src/index.js:
         import React from 'react';
         import ReactDOM from 'react-dom';
         import { BrowserRouter } from 'react-router-dom';
         import App from './App';
         ReactDOM.render(
            <React.StrictMode>
               <BrowserRouter>
                  <App />
               </BrowserRouter>
            </React.StrictMode>, 
            document.getElementById('root')
         );

   > First import the 'Route' Component from the 'react-router-dom' package. This Component allows you to define a certain path and then the React Component that should be loaded when that path becomes active in the URL.
   > The Route Component wants a special prop called 'path' which should be the path in the URL that comes after the domain-name. In-between the Route tags you would place the Component(s) that should be rendered for that route. In the above example the Welcome Component is rendered for the "domain-name.com/welcome" route path while the Products Component is rendered for the "domain-name.com/products".
   > The Route Component will ensure that only the Component between the tags are rendered when the URL route path is active otherwise the Component will not be displayed.
   > This is how you would register routes with 'react-router-dom' so that it can evaluate the URL and render the relevant Component(s) to the browser's screen.
   > To activate the 'react-router-dom' and all its features (e.g. the Routes Component feature) you need to go to the 'src/index.js' file of your React application and import 'BrowserRouter' Component from the 'react-router-dom' package. This component needs to wrap the overall <App/> i.e. the root Component for the whole React application.
   > This will active React Router and unlock the React Router features like defining the routes/paths using the Route Component.
   > Whenever you navigate to any other URL path other than those defined within the Route Component(s) will now render/display nothing to the screen. This in a nutshell how routing works. There are more features to routing and more concepts to be explored; however, the above is the core concept behind routing and creating a Multi-Page SPA application in React.
   > One thing to note, since we now use Components as different pages in the application (and not like other Components we have worked with before) it is quite common to store them in a folder named "pages" or "screens". You do not need to name the "pages" and can stick to having a folder called "components".
   > Having a separate "pages" folder with the Component that are loaded by the router makes it clearer what kind of Components these are and that you use these Component in conjunction with the Router.
   > You can have other Components within the application that are not loaded by the Router but which you instead use in other Component's JSX code and these can be kept in the "components" folder as we have done in the past. This will help make it clearer to distinguish between the different types of Component files you have within your application.
   > Now that you have routing implemented within the React application, there is one issue. There is no way to navigate the different route paths other than changing the URL manually. Whilst you might sometimes do that but it is often common to have links on the page which you can click to take you somewhere else.

   Working with Links (Flawed Approach) Example:
      src/components/MainHeader.js:
         import React from 'react';
         const MainHeader = () => {
            return(
               <header>
                  <nav>
                     <ul>
                        <li><a href="/welcome">Welcome</a></li>
                        <li><a href="/products">Products</a></li>
                     </ul>
                  </nav>
               </header>
            );
         };
         export default MainHeader;
      src/App.js:
         import React from 'react';
         import { Route } from 'react-router-dom';
         import MainHeader from './components/MainHeader';
         import Welcome from './pages/Welcome';
         import Products from './pages/Products';
         const App = () => {
            return (
               <div>
                  <MainHeader />
                  <main>
                     <Route path="/welcome"><Welcome /></Route>
                     <Route path="/products"><Products /></Route>
                  </main>
               </div>
            );
         };

   > The above is one way in which you can create a navigation link to your application and whenever you click the link it will update the URL and allow you to navigate the different routes without having to write the URL manually in the browser. However, there is a big flaw with the above approach.
   > This actually loads a new page sending a new request using the browsers default behaviour with links. This will cause a brand new HTML file being loaded each time you click a link (and can be seen in the browsers developer tools network tab). While this works for navigation it also means that you leave the single-page application and start a new one whenever you click on one of the navigation links.
   > Any application state will be lost whenever the page refreshes which is not ideal. This goes against building a single page application which will cause a sub-optimal user experience.
   > It would be better if the default browser 's sending a request for a new HTML page would be prevented. You could write your own code for this by adding click event listeners on the <a> link tags and prevent the default and manually get the react router to load the correct Component. However, you do not need to do this manually.

   Working with Link (React Router Approach) Example:
      src/components/MainHeader.js:
         import React from 'react';
         import { Link } from 'react-router-dom';
         import classes from './MainHeader.module.css';
         const MainHeader = () => {
            return(
               <header className={classes.header}>
                  <nav>
                     <ul>
                        <li><Link to="/welcome">Welcome</Link></li>
                        <li><Link to="/products">Products</Link></li>
                     </ul>
                  </nav>
               </header>
            );
         };

   > There is another Component you can import from the 'react-router-dom' called 'Link'. The 'Link' Component does what it's name implies i.e. it allows you to create a link. You can replace the <a> tag with the <Link /> Component and replace the "href" attribute with the "to" prop. The Link Component expects a "to" prop which should hold the link path to navigate to when the link is clicked.
   > Visually you will receive the same output as before; however, you will notice that the page no longer reloads or sends a new request for a new HTML page.
   > The Links Component are still <a> tags at the end of the day but React Router will actually listen to clicks on the Link Component, prevent the browser default, manually update the URL for you so that it looks like you are switching pages and finally change what is displayed on the screen creating this fake navigation which is what you want for your Multi-Page SPA.
   > You no longer lose any state while giving the user an illusion of switching between different pages. This is how you want to use routing in your React application.
   > Another problem we now have is that when it comes to navigation we often want to highlight the active links within the navigation.

   Using React Router's NavLink Example:
      src/components/MainHeader.module.css:
         ...
         .header a:hover,
         .header a:active,
         .header a.active {
            color: #95bcf0;
            padding-bottom: 0.25rem;
            border-bottom: 4px solid #95bcf0;
         }
      src/components/MainHeader.js:
         import React from 'react';
         import { NavLink } from 'react-router-dom';
         import classes from './MainHeader.module.css';
         const MainHeader = () => {
            return(
               <header className={classes.header}>
                  <nav>
                     <ul>
                        <li><NavLink activeClassName={classes.active} to="/welcome">Welcome</NavLink></li>
                        <li><NavLink activeClassName={classes.active} to="/products">Products</NavLink></li>
                     </ul>
                  </nav>
               </header>
            );
         };

   > React Router provides another feature. Instead of using the regular 'Link' Component you can import and use the 'NavLink' Component instead.
   > The 'NavLink' Component works exactly like the 'Link' Component but it also does more. The NavLink Component will set a CSS class on the active anchor (<a> tag) item. You need to use the 'activeClassName' prop to tell the 'NavLink' which class it should add on the active link.
   > In the above example the module.css file contains a style for the ".header a.active" i.e. this style targets anchor elements that have the class name of "active". The 'NavLink' will conditionally add the "active" class using the 'activeClassName' prop whenever the 'NavLink' is active which will trigger the "active" link styling.
   > This is a nice additional feature you would want to have with a lot of application you would build. This is made simple using the NavLink feature provided by React Router (i.e. without having to write your own code).

------------------------------------------------------------------------------------
3. Adding Dynamic Routes with Params and Extracting Route Params:
------------------------------------------------------------------------------------
   > You may want a route path that is activated by a link but that page is rendered using details based on the link you clicked from. For example, you could have a products page with links to different products. Those links would take you to the product details page which will provide the detail of the product that was clicked (whether that detail data comes from aback-end API from a database or application from an application-wide state frp, React Context API or Redux).
   > In this example you would definitely want one and the same Component but you need a way to tell React Router for which specific product the product details Component should be loaded so that inside of this Component you can kind of retrieve that extra product data.

   Dynamic Routes with Params Example:
      src/pages/ProductDetails.js:
         import React from 'react';
         const ProductsDetails = () => {
            return(
               <section><h1>Product Detail</h1></section>
            );
         };
         export default ProductsDetails;
      src/pages/Products.js:
         import React from 'react';
         const Products = () => {
            return(
               <section>
                  <h1>The Products Page</h1>
                  <ul>
                     <li>A Book</li>
                     <li>A Pen</li>
                     <li>A Ruler</li>
                  </ul>
               </section>
            );
         };
         export default Products;
      src/App.js:
         import React from 'react';
         import { Route } from 'react-router-dom';
         ...
         import ProductsDetails from './pages/ProductDetail';
         const App = () => {
            return (
               <div>
                  <MainHeader />
                  <main>
                     ...
                     <Route path="/product-detail/:productId"><ProductDetail /></Route>
                  </main>
               </div>
            );
         };

   > You can define dynamic routes in the path prop using a special syntax of using the colon followed by any identifier of your choice e.g. "domain-name.com/product-detail/:productId".
   > The ":productId" is a dynamic path segment which tells React Router that the overall path for which the page should be loaded will be something like "domain-name.com/product-detail/<any value>" where the "<any value>" is a placeholder that can have any value e.g. "domain-name.com/product-detail/a-book".
   > Inside of the ProductsDetails Component which gets rendered (as long as the URL is valid) when the path is reached you will get access to the concrete value for the dynamic segment. You now need a way to access that value stored in the dynamic segment so that you can use it inside of the rendered Component.

   Extracting Route Params Example:
      src/pages/ProductDetails.js:
         import React from 'react';
         import { useParams } from 'react-router-dom';
         const ProductsDetails = () => {
            const params = useParams();
            return(
               <section>
                  <h1>Product Detail</h1>
                  <p>{params.productId}</p>
               </section>
            );
         };
         export default ProductsDetails;

   > Import the 'useParams' Custom Hook from the 'react-router-dom' package. When you call on the useParams Hook this will return a params object which you can store in a const variable.
   > This object will have key:value pairs where the keys are the name of the dynamic segments leading to that page and the value is extracted segment value from the URL.
   > Using the params object you can now access and extract the entered parameters from URL and use it within the Component JSX.
   > You could have more than one dynamic segment for a route e.g. "domain-name.com/product-detail/:productId/:anotherId". If the URL in the browser was "domain-name.com/product-detail/1/2" then the useParams Hook would extract the params object as { productId: 1, anotherId: 2 } from the URL which you can then use inside of the Component file to do something like fetching data from a database using a backend API.

------------------------------------------------------------------------------------
4. Using 'Switch' and 'exact' for Configuring Routes:
------------------------------------------------------------------------------------
   > Dynamic Routes and Route Parameters are a another crucial feature of React Router which you will use in almost any application your building. However, there is a potential problem you could face using the above example setup. Your URL path should basically work like a folder structure i.e. new sub-folders (related pages) add a new segment:

      "domain-name.com/products"
         "domain-name.com/products/:productId"

   > Whenever you navigate as an example "domain-name.com/products/1" this will render both the Products Component as well as the ProductDetail Component. By default the routes are not parsed such that only one is loaded at the same time but instead all routes that match the current path will be loaded.
   > Matching in React Router world means your path starts with the path defined in the Route component. Therefore, the URL "domain-name.com/products/1" start with "/products" as well as "/products/:productId" and so both paths are active and also the reason for why both Components will be rendered to the screen when navigating to that URL path.
   > Sometimes this might be what you want but other times it is not and in the example of the product detail this is the latter.

   Using Switch and 'exact' Prop Example:
      src/App.js:
         import React from 'react';
         import { Route, Switch } from 'react-router-dom';
         ...
         const App = () => {
            return (
               <div>
                  <MainHeader />
                  <main>
                     <Switch>
                        <Route path="/welcome"><Welcome /></Route>
                        <Route path="/products" exact><Products /></Route>
                        <Route path="/products/:productId"><ProductsDetails /></Route>
                     </Switch>
                  </main>
               </div>
            );
         };
         export default App;


   > Import the 'Switch' Component from the 'react-router-dom' package. This allows you to wrap the 'Route' Components and this will then allow only one active Route at the same time.
   > The active route will be the Route 'path' that matches first (i.e. matching Routes (the starting path and not the entire path) from top to bottom). When a match is found the 'Switch' will stop matching routes and render that one route it did find a match for.
   > One solution is to change the order of the route path.
         <Route path="/products/:productId"><ProductsDetails /></Route>
         <Route path="/products"><Products /></Route>
   > An alternative is to keep the ordering as is but use the 'exact' prop on the 'Route'. The 'exact' prop tells React Router that the Route path should only lead to a match if you have an exact match. This switches the matching for that particular Route from the beginning of the path to matching the full URL path in the browser.
   > Therefore, these behaviour (i.e. having multiple Components rendered at the same time from a URL) are not always a problem but will always depend on the navigation scenario. You can use the 'exact' prop to target a scenario where you only want a specific Component to render when there is a absolute exact match with the URL. This is a solution you can therefore use.

------------------------------------------------------------------------------------
5. Working with Nested Routes:
------------------------------------------------------------------------------------
   > What is meant by Nested Routes? Depending on what you are building you could have the requirements that you do not just have a couple of different main pages but that instead also inside of a page you also want to have a route.

   Working with Nested Routes Example:
      src/pages/Welcome.js:
         import React from 'react';
         import { Route } from 'react-router-dom';
         const Welcome = () => {
            return(
               <section>
                  <h1>The Welcome Page</h1>
                  <Route path="/welcome/new-user"><p>Welcome New User!</p></Route>
               </section>
            );
         };
         export default Welcome;

   > You are not limited to defining Routes in one place only, you can define routes wherever you want. If the 'Route' are on a Component which is currently active they will be evaluated by React Router.
   > Therefore, if the Welcome page is active the nested routes will be evaluated.
   > In the above example, if the path was "/products" then the Route will never be active because you can never be on the Welcome page for a path that starts with "/products".If on the other hand you set the path to "welcome/new-user" then this route would become active if you are on the Welcome page because you have to be on "/welcome" to render the Component which will trigger the nested rule for "/new-user" which will come after "/welcome".
   > You still need to define the full path to the URL for nested routes.
   > Therefore, in the above example if you visit "domain-name.com/welcome" you will not see the paragraph "Welcome New User!" being rendered to the screen because the router has not evaluated a match. However, if you navigate to "domain-name.com/welcome/new-user" then it will render the paragraph.
   > This is the nested routes feature provided by React Router. You can define routes in other Components and then load more content if you have a more specific path match as we see with the example. This is a feature you can use to build more complex user interfaces and whilst you may not need it in every application you build it can be helpful in a couple of applications.

------------------------------------------------------------------------------------
6. Redirecting the User:
------------------------------------------------------------------------------------
   > The redirect feature allows you to redirect a user to a different URL route/path.

   Redirect the User Example:
      src/App.js:
         import React from 'react';
         import { Route, Switch, Redirect } from 'react-router-dom';
         ...
         const App = () => {
            return (
               <div>
                  <MainHeader />
                  <main>
                     <Switch>
                        <Route path="/" exact><Redirect to="/welcome" /></Route>
                        <Route path="/welcome"><Welcome /></Route>
                        <Route path="/products" exact><Products /></Route>
                        <Route path="/products/:productId"><ProductsDetails /></Route>
                     </Switch>
                  </main>
               </div>
            );
         };
         export default App;

   > Import the 'Redirect' Component from the 'react-router-dom' package. If the 'Redirect' Component gets rendered it will do what the name implies i.e. redirect the user somewhere else. The 'Redirect' Component requires a 'to' prop which should be the value to the URL it should redirect the user to.
   > In the above example, if a user was to visit "domain-name.com/" this will redirect the user to the "domain-name.com/welcome" page instead of showing the page with no rendered content. The 'exact' prop is important in this example because every route starts with "/" which will end up causing an infinite loop breaking the application.

------------------------------------------------------------------------------------
7. Implementing Not Found Page:
------------------------------------------------------------------------------------
   > When a user enters a URL that is not defined within your application routes you would want to display some kind of 404 Error Page (i.e. page not found).

   404 Page Not Found Example:
      src/pages/NotFound:
         import React from 'react';
         const NotFound = () => {
            return (
               <div className="centered">
                  <p>404 Page Not Found</p>
               </div>
            );
         };
         export default NotFound;
      src/App.js:
         import React from 'react';
         import { Route, Switch, Redirect } from 'react-router-dom';
         import AllQuotes from './pages/AllQuotes';
         import QuoteDetail from './pages/QuoteDetail';
         import NewQuote from './pages/NewQuote';
         import Layout from './components/layout/Layout';
         import NotFound from './pages/NotFound';
         const App = () => {
            return (
               <div>
                  <Layout>
                     <Switch>
                        <Route exact path="/"><Redirect to="/quotes" /></Route>
                        <Route exact path="/quotes"><AllQuotes /></Route>
                        <Route path="/quotes/:quoteId"><QuoteDetail /></Route>
                        <Route path="/new-quote"><NewQuote /></Route>
                        <Route path="*"><NotFound /></Route>
                     </Switch>
                  </Layout>
               </div>
            );
         };
         export default App;

   > When defining all the routes the application supports in the Route Switch statement, whenever there is no single match it would leave the switch statement and hence nothing shows up on the screen.
   > Therefore, to show a fallback 404 Not Found Page, the typical approach is to add a final route at the end which looks at no other route matched (i.e. where you match all other incoming requests).
   > The 'path' is set to the asterisk (*) wildcard. This signifies to React Router that any path should match this route which is why this route must be placed last so that it does not consume the request to one of the actual routes you have.
   > If you had no matches up to the last Route then you would want to match all routes to this final route in order to render the 404 Page Not Found page to the screen. For example navigating to "domain-name.com/id" will display the 404 Page Not Found instead of a blank screen which is a common requirement for applications.

------------------------------------------------------------------------------------
8. Implementing Programmatic (Imperative) Navigation:
------------------------------------------------------------------------------------
   > You would typically expect from an application that submits a form to show a success message or modal overlay or you would expect to navigate somewhere else. For example, if you have an application that allows you to submit a new quote and that request was sent to the server, you might expect that you are automatically navigated away from the page to another page.
   > Using a Link on the form button to link to another page is not an option because the button is required to submit the form. Instead what you need is something called Programmatic Navigation.
   > Programmatic Navigation is where you trigger a navigation action and navigate the user away programmatically in your code.

   Programmatic Navigation Example:
      src/pages/NewQuote.js:
         import React from 'react';
         import { useHistory } from 'react-router-dom';
         import QuoteForm from '../components/quotes/QuoteForm';
         const NewQuote = () => {
            const history = useHistory();
            const addQuoteHandler= (quoteData) => {
               console.log(quoteData);
               history.push('/quotes');
            };
            return (
               <QuoteForm onAddQuote={addQuoteHandler} />
            );
         };
         export default NewQuote;

   > Import the 'useHistory' Hook from the 'react-router-dom' package. The 'useHistory' Hook allows you to change the browser's history i.e. the history of pages you visited.
   > Calling the 'useHistory' Hook provides a history object which you can store in a const variable.
   > The '.push()' method is used to push a new page on the stack of pages (i.e. a new page on the history of pages) whilst the '.replace()' method is used to replace the current page.
   > The difference between the two methods is that the '.push()' method allows you to to go back using the browsers back button to the page you are coming from while the '.replace()' method you cannot.
   > Therefore, the '.replace()' method is like a redirect while the '.push()' method is adding a new page to the page history.
   > Both methods will navigate the user programmatically; however, the method you wish to use depends on whether you would want to allow the user to go back to the previous page using the back button or to redirect the user to a new page.
   > The '.push()' or '.replace()' methods will cause the Component to re-evaluate and re-render the page because React Router will see that the page history has changed and the Component should re-evaluate and re-render the page even if it is the page you are currently on. This is a useful mechanism which you can use to your advantage (especially when it comes to Query Parameters).

------------------------------------------------------------------------------------
9. Preventing Possible Unwanted Route Transitions with the 'Prompt' Component:
------------------------------------------------------------------------------------
   > You may notice on some applications that if you were entering data on a form and accidentally swiped away or pressed the back button (which typically causes the entered data to be lost) is prevented by a prompt. This prompt asks you if you really want to navigate away from the page. This prompt prevents you from accidentally navigating away from the form (i.e. prevents unwanted route transitions).

   Prompt Component Preventing Unwanted Navigation Example:
      src/components/quotes/QuoteForm.js:
         import React, { Fragment, useRef, useState } from 'react';
         import { Prompt } from 'react-router-dom';
         ...
         const QuoteForm = (props) => {
            const [isEntering, setIsEntering] = useState(false);
            ...
            function submitFormHandler(event) { ... };
            const formFocusedHandler = () => { setIsEntering(true) };
            const finishEnteringHandler = () => { setIsEntering(false) };
            return (
               <Fragment>
                  <Prompt when={isEntering} message={(location) => 'Are you sure you want to leave? All your entered data will be lost!'} />
                  <Card>
                     <Form>
                        ...
                        <div className={classes.actions}>
                           <button className="btn" onClick={finishEnteringHandler}>Add Quote</button>
                        </div>
                     </Form>
                  </Card>
               </Fragment>
            );
         };
         export default QuoteForm;

   > Import the 'Prompt' Component from the 'react-router-dom' package. This Component will automatically watch if the user navigates away and if a certain condition is met it will show a warning before it allows the user to leave the page.
   > The 'onFocus' prop allows you to see whether the form is in focus. The 'onFocus' prop can trigger some function on this onFocus event. You can then use the 'useState' Hook from React to create a state that will manage this state to check if the form is in focus.
   > Showing a user when the user tries to leave the form (maybe accidentally) is straight forward using the 'Prompt' Component.
   > The 'Prompt' Component needs two props; a 'when' prop which should be a boolean value defining when to show the prompt if the user has changed the URL and a 'message' prop to display the prompt message.
   > The 'message' prop takes in a function which should return a string to display to the user when they try to leave. This function receives a location object as an argument/parameter which provides information about the page the user is trying to go to. This will allow you to add the path of the page the user is trying to navigate to.
   > In the above example, the Prompt Component will display a prompt message whenever the form was focused and the user tries to navigate away from the page. The user can select the 'Cancel' button to cancel the navigation or the 'OK' button to continue with navigating away from the page.
   > Note that when the user finishes entering the data on a form and wants to submit that form the 'isEntering' state needs to be set to false to prevent the prompt from triggering when submitting the form (the 'isEntering' is used for the 'Prompt' Component 'when' prop boolean trigger value).
   > Note that the "finishEnteringHandler" function will execute before the "submitFormHandler" function so that the state is updated before the submission function is executed which will stop the Prompt from appearing and the reason for having a separate function.

------------------------------------------------------------------------------------
10. Working with Query Parameters:
------------------------------------------------------------------------------------
   > Query Parameters are special parameters which you find on some URLs at the end of the URL path.
   > Query Parameters are seen by a question mark followed by parameter pairs (e.g. "domain-name.com/quotes?sort=asc").
   > Query Parameters pass extra data into the page that was loaded.
   > The difference between Query Parameters and Route Parameters is that Route Parameters are mandatory in the URL route matching. Query Parameters are optional and has no effect on the route matching.
   > Whichever route is matched has access to the Query Parameter data to, for example, change the behaviour of the page that was loaded (e.g. sort the list of quotes in ascending/descending order which requires some sorting functionality within the application code).

   Working with Query Parameters Example:
      src/components/quotes/QuoteList.js:
         import React, { Fragment } from 'react';
         import { useHistory, useLocation } from 'react-router-dom';
         import QuoteItem from './QuoteItem';
         import classes from './QuoteList.module.css';
         const sortQuotes = (quotes, ascending) => {
            return quotes.sort((quoteA, quoteB) => {
               if (ascending) {
                  return quoteA.id > quoteB.id ? 1 : -1;
               } else {
                  return quoteA.id < quoteB.id ? 1 : -1;
               };
            });
         };
         const QuoteList = (props) => {
            const history = useHistory();
            const location = useLocation();
            const queryParams = new URLSearchParams(location.search);
            const isSortingAscending = queryParams.get('sort') === 'asc';
            const sortedQuotes = sortQuotes(props.quotes, isSortingAscending);
            const changeSortingHandler = () => { history.push('/quotes?sort=' + (isSortingAscending ? 'desc' : 'asc')) };
            return (
               <Fragment>
                  <div className={classes.sorting}>
                     <button onClick={changeSortingHandler}>Sort {isSortingAscending ? 'Descending' : 'Ascending'}</button>
                  </div>
                  <ul className={classes.list}>
                     {sortedQuotes.map((quote) => (
                        <QuoteItem key={quote.id} id={quote.id} author={quote.author} text={quote.text}/>
                     ))}
                  </ul>
               </Fragment>
            );
         };
         export default QuoteList;

   > The 'useHistory' Hook provides access an object that allows you to manage and change the URL. The 'useLocation' Hook provides access to an object which has information about the currently loaded URL. Both Hooks provided by the 'react-router-dom' library.
   > The 'search' parameter on the location object holds the Query Parameter data of the loaded page which is held in a string. The default JavaScript 'URLSearchParams()' constructor function makes it easy to work with URL search parameters by converting the data into a JavaScript Class object that can be stored in a variable. The 'location.search' string is passed as an argument to this constructor function.
   > You can now use this JavaScript Object to extract search parameter by its key to get its value (e.g. "sort" key will give the value of "asc" or "desc"). This is a more convenient way of extracting values from the URL's Query Parameters using the '.get()' method which takes in the parameter key you wish to extract the value for.
   > This is how you can work with Query Parameters in URLs within your application routes and pages.

------------------------------------------------------------------------------------
11. Getting Creative with Nested Routes:
------------------------------------------------------------------------------------
   > You can use the Nested Routes Feature to conditionally render different content based on the URL without you having to manage some complex state as React Router can do this for you.

   Conditionally Loading with Nested Routes Example:
      src/pages/QuoteDetail.js:
         import React, { Fragment } from 'react';
         import { useParams, Route, Link } from 'react-router-dom';
         import Comments from '../components/comments/Comments';
         import HighlightedQuote from '../components/quotes/HighlightedQuote';
         const DUMMY_QUOTES = [
            { id: 'q1', author: 'Alex', text: 'Learning React is fun!' },
            { id: 'q2', author: 'Beth', text: 'Learning React is great!' },
         ];
         const QuoteDetail = () => {
            const params = useParams();
            const quote = DUMMY_QUOTES.find(quote => quote.id === params.quoteId);
            if(!quote) { return(<p>No Quote Found!</p>) };
            return (
               <Fragment>
                  <HighlightedQuote text={quote.text} author={quote.author} />
                  <Route path={`/quotes/${params.quoteId}`} exact>
                     <div className="centered">
                        <Link className="btn--flat" to={`/quotes/${params.quoteId}/comments`}>Load Comments</Link>
                     </div>
                  </Route>
                  <Route path="/quotes/:quoteId/comments"><Comments /></Route>
               </Fragment>
            );
         };
         export default QuoteDetail;

   > The first nested Route will check whether the route has only the "quoteId" in the URL and if so it will load the JSX code between the <Route> tags i.e. the "Load Comments" div element i.e. link button.
   > The 'Link' Component is used to forward the user to the '/comments' route for the current "quoteId" page which will now render the page without the "Load Comments" link button.
   > This allows you to conditionally render content to the page based on the URL using React Router's Nested Routes feature without the need for any complex state.

------------------------------------------------------------------------------------
12. Writing More Flexible Routing Code:
------------------------------------------------------------------------------------
   > React Router helps with constructing nested paths and navigating to more complex URLs.
   > Currently we have seen how to manually build nested routes strings. However, the downside of this approach is that if you wanted to change the parent URL string path then you would also have to go through all other nested links and update the path string as well. This is not flexible approach.
   > React Router provides Custom Hooks that allow you to find out which URL the Component was rendered from. Therefore, you do not need to repeat that path in URL string for the nested route.

   Flexible Routing Example:
      src/App.js:
         import React from 'react';
         import { Route, Switch, Redirect } from 'react-router-dom';
         import AllQuotes from './pages/AllQuotes';
         import QuoteDetail from './pages/QuoteDetail';
         import NewQuote from './pages/NewQuote';
         import Layout from './components/layout/Layout';
         import NotFound from './pages/NotFound';
         const App = () => {
            return (
               <div>
                  <Layout>
                     <Switch>
                        <Route exact path="/"><Redirect to="/quotes" /></Route>
                        <Route exact path="/quotes"><AllQuotes /></Route>
                        <Route path="/quotes/:quoteId"><QuoteDetail /></Route>
                        <Route path="/new-quote"><NewQuote /></Route>
                        <Route path="*"><NotFound /></Route>
                     </Switch>
                  </Layout>
               </div>
            );
         };
         export default App;
      src/pages/QuoteDetail.js:
         import React, { Fragment } from 'react';
         import { useParams, Route, Link } from 'react-router-dom';
         import Comments from '../components/comments/Comments';
         import HighlightedQuote from '../components/quotes/HighlightedQuote';
         const DUMMY_QUOTES = [
            { id: 'q1', author: 'Alex', text: 'Learning React is fun!' },
            { id: 'q2', author: 'Beth', text: 'Learning React is great!' },
         ];
         const QuoteDetail = () => {
            const params = useParams();
            const quote = DUMMY_QUOTES.find(quote => quote.id === params.quoteId);
            if(!quote) { return(<p>No Quote Found!</p>) };
            return (
               <Fragment>
                  <HighlightedQuote text={quote.text} author={quote.author} />
                  <Route path={match.path} exact>
                     <div className="centered">
                        <Link className="btn--flat" to={`${match.url}/comments`}>Load Comments</Link>
                     </div>
                  </Route>
                  <Route path="${match.path}/comments"><Comments /></Route>
               </Fragment>
            );
         };
         export default QuoteDetail;

   > Import the 'useRouteMatch' Hook from the 'react-router-dom' package. This custom Hook is similar to the 'useLocation' Hook but it provides access to an object which holds more information about the currently loaded route (i.e. some internally managed data that React Router is aware of).
   > You can use the useRouteMatch object to construct the nested route paths dynamically.
   > The 'path' property provides the path defined by you in React Router files including the placeholder and query parameters. The 'url' property provides the full actual navigated URL in the browser. The 'params' property provides an object of passed in parameters in the navigated URL path.
   > You have the same behaviour as before but without having to write a concrete path string in the nested route. Instead we are extracting the path from the existing route definition. Therefore, if you now change the root routes, you do not need to go and change all the nested routes resulting in less manual code refactoring work.

   > React Router allows you to use an alternative description of the destination i.e. a Link should lead to a path defined as either a string or a programmatic navigation path.
   > Below is an example of using a programmatic path object for a navigation Link in contrast to using a string value.
      - const changeSortingHandler = () => { history.push(`${location.pathname}?sort=${(isSortingAscending ? 'desc' : 'asc')}`) };

   Programmatic Navigation Link Path Object Example:
      src/components/quotes/QuoteList.js:
         ...
         const QuoteList = (props) => {
            const history = useHistory();
            const location = useLocation();
            const queryParams = new URLSearchParams(location.search);
            const isSortingAscending = queryParams.get('sort') === 'asc';
            const sortedQuotes = sortQuotes(props.quotes, isSortingAscending);
            const changeSortingHandler = () => {
               history.push({
                  pathname: location.pathname,
                  search: `?sort=${(isSortingAscending ? 'desc' : 'asc')}`
               });
            };
            ...
         };
         export default QuoteList;

   > Besides using a string you can also use an object. The object describes the target destination. This object wants a 'pathname' property which describes the path to navigate to. The 'search' property allows you to add a Query Parameter - it expects a string which you can use a template literal to dynamically add the Query Parameter value instead of hardcoding the value.
   > The Path and Query Parameter are now separated into two different properties which makes the navigation link's target destination code more readable especially with more complex routes.
   > Either approach will work and is entirely up to you as a developer which syntax to use for your navigation links. This is another convenience feature provided by React Router.