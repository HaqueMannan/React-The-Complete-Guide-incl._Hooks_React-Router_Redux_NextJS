Diving into Redux: An Alternative to the Context API - Summary:
1. Redux vs React Context
2. How Redux Works
3. Exploring the Core Redux Concepts
4. More Redux Basics
5. Using Redux with React
6. Using Redux with Class-based Components
7. Attaching Payloads to Actions
8. Working with Multiple State Properties
9. How to Work with Redux State Correctly
10. Using Redux Toolkit Library as a Solution
11. Working with Multiple Slices
12. Splitting Redux Store Code

------------------------------------------------------------------------------------
1. Redux vs React Context:
------------------------------------------------------------------------------------
   > Redux is a State Management System for cross-component or app-wide state.
   > We can split the definition of State into three types of States:
      - Local State: State that belong to a single Component e.g. listening to user input in an input field or toggling a "show more" details field. Should be managed internally inside of a Component using useState() or useReducer() Hooks
      - Cross-Component State: State that affects multiple Components e.g. open/close state of a modal overlay. Can use useState() or useReducer() but will require "prop chains"/"prop drilling" (a little more complex compared to Local State).
      - App-Wide State: State that affects the entire application (i.e. most or all Components) e.g. user authentication status. Can use useState() or useReducer() but will require "prop chains"/"prop drilling".
   > For Cross-Component and App-Wide State, passing around data and update function through props can be cumbersome. React Context is a built-in feature in React that makes managing cross-component or application-wide state much more easier. Redux also solves the same problem.
   > Both React Context and Redux are there to help you manage such cross-component or application-wide state. But this should lead to the question: Why would we need Redux if we have React-Context?
   > Important Note: You can use both React Context and Redux together in the same application.
   > React Context has a couple of potential disadvantages (potential because it may not matter depending on the application you are building):
      - Complex Setup/Management of State. Typically occurs with larger enterprise level applications which can end up with deeply nested JSX code if using multiple State Providers or one large State Provider unmanageable state provider file, both issues demonstrated below:

         Complex React Context Setup/Management Multiple State Providers:
            ...
            return(
               <AuthContextProvider>
                  <ThemeContextProvider>
                     <UIInteractionContextProvider>
                        <MultiStepFormContextProvider>
                           <UserRegistration />
                        </MultiStepFormContextProvider>
                     </UIInteractionContextProvider>
                  </ThemeContextProvider>
               </AuthContextProvider>
            );

      or

      Complex React Context Setup/Management with one Big State Provider:
         function AllContextProvider() {
            const [isAuth, setIsAuth] = useState(false);
            const [isEvaluatingAuth, setIsEvaluatingAuth] = useState(false);
            const [activeTheme, setActiveTheme] = useState('default');
            const [...] = useState(...);
            ...
            function loginHandler(email, password) {...};
            function signupHandler(email, password) {...};
            function changeThemeHandler(email, password) {...};
            function(...) {...};
            ...
            return(<AllContext.Provider></AllContext.Provider>);
         };

      - Performance Issues. React Context is great for low frequency/unlikely updates (like changing locale/theme); however, it is not great if the data changes a lot i.e. high frequency/often updates. React Context is not ready to be used as a replacement for all Flux-like state propagation (note: Redux on the other hand is a Flux-like state management library).

   > Redux does not suffer from the two potential disadvantages mentioned above that may be applicable to React Context.

------------------------------------------------------------------------------------
2. How Redux Works:
------------------------------------------------------------------------------------
   > Redux is all about having ONE central Data (State) Store in an application. You never have more than one store.
   > The central data store holds all the state (cross-component and app-wide states) for the entire application. This might seem unmanageable but the positive is that you do not need to manage the whole store.
   > Ultimately, you have data inside of the store so that you can use it from inside of the Components.
   > Components setup Subscriptions to the central store. Whenever the data changes the store notifies the Subscribed Components. The Components can get the data they need (i.e. a slice of the data store) and then use it to React to the change.
   > One important rule, Components never directly manipulate the store data.
   > While data flow can be passed down by Subscriptions there is no data flow in the other direction (at least not a direct data flow).
   > There is a concept called Reducers. A Reducer Function (which needs to be setup) is a function responsible for mutating (i.e. changing) the Store's data.
   > Important Note: "Reducer Function" is a general concept and is not the same as the useReducer() Hook. Reducer Function are general functions that take an input and then transforms/reduce that input and returns a new transformed output. This is a general programming concept which both the Reducer Function and useReducer() Hook implements.
   > Components dispatch (i.e. trigger) Actions. An Action is a simple JavaScript object which describes the kind of operation the reducer should perform.
   > Redux forwards Actions to the Reducer which reads the description of the desired operation and then the operation is performed by the Reducer Function.
   > Redux uses Actions to indirectly connect Components to Reducers.
   > The Reducer will output a new State which will effectively replace the existing state in the central data store. When the state inside of the data store is updated, subscribing Components are notified of the data change so that they can update their UI.
   > This is how Redux works and can be shown visually in the diagram below:

   Redux Concept:
            ----------------------->[Reducer Function]
            | forwarded to                |
            |                             | Mutates (changes) Store Data
            |                             v
         [Actions]            [Central Data (State) Store]
            ^                             |
            |                             | Subscription
            | Dispatch                    v
            ------------------------[Components]

------------------------------------------------------------------------------------
3. Exploring the Core Redux Concepts:
------------------------------------------------------------------------------------
   > To install the Redux library use the following npm command within the terminal while within the project directory (note: you could run a similar command to install using Yarn Package Manager):
      $ npm install redux

   > The Redux library (and all of its dependencies) will get installed inside of your project file and the package.json will be updated to reflect the new library and dependencies installed to the node_modules folder.
   > To use Redux you would need to import the library into your JavaScript file.
   > Note: If executing JavaScript files through NodeJS the import syntax is slightly different to the normal ES6 import syntax. This is because NodeJS has not implemented the ES6 import Syntax.

      ES6 Import Syntax Importing Redux example:
         import redux from 'redux';

      NodeJS Import Syntax Importing Redux example:
         const redux = require('redux');

   > After installing and importing Redux you are now ready to use Redux.

      Creating a Store Example:
         const redux = require('redux');
         const store = redux.createStore();

   > The imported redux object from the Redux library provides a .createStore() method. This exposed method will create a Central Data Store.
   > The new store is saved to a const variable which you can name as anything you want (the above example uses store as the const variable name).
   > The data the central store manages is determined by the Reducer Function. It is the Reducer Function which will produce new state snapshots whenever an action reaches it.
   > When the code is executed for the first time the Reducer Function will also be executed with a default action which will produce the initial state.

      Creating a Reducer Function Example:
         const redux = require('redux');
         const counterFunction = (state, action) => {
            return { counter: state.counter + 1 };
         };
         const store = redux.createStore(counterFunction);

      or
         const redux = require('redux');
         function counterFunction(state, action) {
            return { counter: state.counter + 1 };
         };
         const store = redux.createStore(counterFunction);

   > You can use either syntax (ES5 function or ES6 anonymous arrow function syntax) to create the Reducer Function.
   > The Reducer is a standard JavaScript function but it will be called by the Redux library and therefore will always then receive two pieces of input arguments/parameters:
      - Inputs: state (i.e. the old state) & action (i.e. the dispatched action)
   > The Reducer Function must return a certain output i.e. a new State object:
      - Output: New State Object
   > Therefore, the reducer function should be a pure function which means the same input (i.e. values for the input) should always lead to (i.e. produce) the same output. There should be no side effects inside of the function i.e. you must not send a HTTP request or fetch/write something to local storage, etc.
   > Typically the output would be a State object because in most applications, State is more than just a single value; however, theoretically the output can be any kind of value type (but in reality it is typically an object).
   > The State Object can have any structure you want and will totally depend on the developer.
   > In the above example, the counter property refers to the old state.counter property value and adds 1 to get the new counter value for the new state. This is how a basic reducer could look like.
   > The reducer is what is passed to the .createStore() method. This is because the .createStore() method needs to know which reducer is responsible for changing the store (keep in mind that it is the reducer that works together with the store). Therefore, the store wants to know who the reducer function is that will manipulate the store.
   > It is important that you do not execute the Reducer Function but just point to the function when passing it as an argument/parameter to the .createStore() method.

      Creating a Subscriber Example:
         const counterSubscriber = () => {
            const latestState = store.getState();
            console.log(latestState);
         };
         store.subscribe(counterSubscriber);

   > You can use either syntax (ES5 function or ES6 anonymous arrow function syntax) to create the Subscriber Function.
   > The subscriber function does not receive any function but it is a function that can reach out to the store and call the .getState() method which is a method created on to the created store object.
   > The .getState() will provide the latest state snapshot after the store was updated. This can be stored in a variable which can be used to do whatever is required with the new state.
   > To make Redux aware of the Subscriber Function and to tell Redux that this function should be executed whenever the state changes by reaching out the the created store object and calling the .subscribe() method. This is another method provided by the Redux library's .createStore() method when setting up the store object.
   > The .subscribe() method expects a subscribe function which Redux will execute for you whenever the data in the data store changes.
   > It is important that you do not execute the subscriber function but just point to the function when passing it as an argument/parameter to the .subscribe() method.
   > Both the Reducer Function and the Subscriber Function will be executed by Redux.

   Executing File through NodeJS:
      $: node fileName.js

   > The above command will execute the specified JavaScript file within the current terminal directory through NodeJS and spit out the the result in the terminal. You will notice an error is thrown of:
      counter: state.counter + 1
                     ^
      TypeError: Cannot read property 'counter' of undefined

   > This error appears because you are creating a store which has a reducer and in that reducer you return a state object which sets the counter to the old state.counter + 1. The problem is that when the store is initialised, Redux will execute the Reducer Function for the very first time and the state is undefined because there are no existing state because it is the first time the function is executing.
   > Therefore, when passing the state argument/parameter inside of the Reducer Function you should always give the state argument/parameter a default/fallback value so that when it runs for the first time it will have a value that is not undefined which will remove the error.

      Providing a Default State Value Example:
         const counterFunction = (state = { counter: 0 }, action) => {...};

   > When the Reducer Function runs after the initial execution, the state will always have a value for state which will ignore the default value set for the state argument/parameter. The default value will only be used where the state does not have a value i.e. on first execution where the state is undefined.
   > Now when the code is run you will not see any output to the terminal. This is because while we have the Central Data Store, Reducers and Subscription all setup there are no Actions dispatched. While the initial initialisation is dispatched by Redux, this does not trigger the Subscription function.
   > You could get the initial state by using the following code after the store is created:

      Get Initial Store State Example:
         const store = redux.createStore(counterFunction);
         console.log(store.getState());

   > Typically you would not want to do the above, but this demonstrates how you could receive the initial state if needed.

      Creating An Action Example:
         store.dispatch({ type: 'increment' });

   > The store object has a .dispatch() method which is a method that dispatches an Action.
   > An Action is a JavaScript object with a 'type' property which acts as an identifier. The value is typically a string value which should be a unique string value. Every distinct Action you dispatch should lead to different things being done in the reducer.
   > In its simplest form the .dispatch() method only needs an object with the 'type' property set to a unique string value
   > If you execute the JavaScript file again you would see { counter: 2 } printed to the terminal. This is because counter is initially set to 1 after the first .createStore() initialisation (as seen with the above Get Initial Store State Example) and then when you dispatched a new action this caused the "counterFunction" Reducer Function to be executed again incrementing the existing counter state property by 1 resulting in the value of 2.
   > This in a nutshell is how Redux works. The final code can be found below for reference of understanding the core Redux concepts.

      Final Core Redux Concepts Example:
      redux-demo.js:
         const redux = require('redux');
         const counterFunction = (state = { counter: 0 }, action) => {
            return{ counter: state.counter + 1 };
         };
         const store = redux.createStore(counterFunction);
         const counterSubscriber = () => {
            const latestState = store.getState();
            console.log(latestState);
         };
         store.subscribe(counterSubscriber);
         store.dispatch({ type: 'increment' });
      
      Running the Above JavaScript File through NodeJS in terminal:
         redux-demo.js $ node redux-demo.js
         { counter: 2 }

------------------------------------------------------------------------------------
4. More Redux Basics:
------------------------------------------------------------------------------------
   > Typically when using Redux the goal is to different things inside of the reducer for different actions. This is the reason for why you get the 'action' as the second argument/parameter to the reducer function by Redux.
   > Therefore, inside of the reducer function you can look at the action and use conditional statements to check the 'action.type' is equal to a specific unique string value for the action.type property.

      Different Reducer Mutations Based on Action.Type value Example:
         const counterFunction = (state = { counter: 0 }, action) => {
            if(action.type === 'increment') {
               return{ counter: state.counter + 1 };
            };
            if(action.type === 'decrement') {
               return{ counter: state.counter - 1 };
            };
            return state;
         };
         ...
         store.dispatch({ type: 'increment' });
         store.dispatch({ type: 'decrement' });

   > In the above example, if the 'increment' Action was dispatched the state's counter property will increment by one when it detects the action.type is equal to the unique 'increment' string. However, if the action.type has no value or a different action then the Reducer Function will either run the other mutation function (e.g. 'decrement') or return the state.
   > This small change will change the behaviour of what is returned by the Reducer Function i.e. on first initialisation the counter property value will not increment but will return instead the the state { counter: 0 }. When the dispatch action of 'increment' is executed this will increment the counter property and will return { counter: 1 }.
   > You can dispatch other actions in which case you would now need to add a conditional statement to check for that action type string within the Reducer Function to perform a different mutation based on the new action type.
   > The above Reducer Function example has an mutation for 'increment' and 'decrement' actions. The Reducer Function will mutate/change/reduce the new state output based on the action type received from the dispatched action.
   > There are more things you can do with Reducer Functions and Actions but what has been covered is the fundamental/core of how Redux works no matter how you use it.
   > Redux is not a library restricted to React. It is a library that can be used in any JavaScript project. There are also implementations for other programming languages.
   > We can now explore how to use Redux in a React application.

------------------------------------------------------------------------------------
5. Using Redux with React:
------------------------------------------------------------------------------------
   > Use NPM or Yarn Package Manager to install Redux and React-Redux libraries:
      $ npm install redux react-redux

   > The React-Redux library helps with connecting React applications to Redux stores, reducers, subscriptions, actions, ect. much more simply.
   > Now that the package is installed you are ready to use Redux in your React project.
   > As a common convention (and not something you have to do) create a folder called store within the src folder within your project. This folder will contain Redux related code files inside of this store folder.
   > Create a index.js (or a suitable named file) within the store folder which will contain the Redux logic.

   Creating a Store Example:
      src/store/index.js:
         import { createStore } from 'redux';
         const counterReducer = (state = { counter: 0 }, action) => {
            if(action.type === 'increment') {
               return { counter: state.counter + 1 };
            };
            if(action.type === 'decrement') {
               return { counter: state.counter - 1 };
            };
         };
         export default store;

   > First import the redux library. The syntax in the above example extracts the 'createStore' function from the redux library. Note: you could have imported the whole library (e.g. import redux from 'redux').
   > A 'store' const variable is used to store the .createStore() functions returned central data store object. The .createStore() wants a pointer to a reducer function as its argument/parameter.
   > The counterReducer function is an anonymous function which receives the state and action arguments/parameter from the redux library. The reducer function code must come before the .createStore() method because it is pointed at later in the code.
   > The state argument/parameter much have a default value so that no errors are thrown on first initialisation of the redux store.
   > The reducer function should handle different actions returning different state snapshots depending on which action was dispatched. The above example has an increment and decrement actions. If neither action.type is met then the reducer will return the unchanged state.
   > This now creates the Redux Store for your react application. We would now want to connect the React App to the Redux store so that the Components of the App can dispatch an action and subscribe to the changed store state.
   > Export the store as the default export of the file so that the Redux store object can be used outside of the file.
   > Remember: You can only have one Redux store, therefore, you only need to provide the store once. What does provide mean?

   Providing Redux Store Example:
      src/index.js:
         import React from 'react';
         import ReactDOM from 'react-dom';
         import from 'react-redux';
         import store from './store/index';
         ...
         ReactDOM.render(
            <React.StrictMode>
               <Provider store={store}><App/><Provider/>
            </React.StrictMode>,
            document.getElementById('root')
         );

   > To provide the Redux store to the React application you would typically go to the index.js file where you render the entire application i.e. the highest level where you can go in your React application (the top of the Component Tree).
   > The 'Provider' Component is imported from 'react-redux' which is then used to wrap the root Component of your application i.e. <App />. This is similar to wrapping using your own Context Providers using React Context API (e.g. <AuthContextProvider />).
   > You do not need to wrap the Root Component but whichever Component is wrapped using the Provider will have access to the Redux store and so will the all the Child Components going down the tree also have access. If the vast majority of the application requires the store then it makes sense to typically wrap the root (highest level) <App/> Component.
   > Import the file containing the created redux store and set the store prop of the Provider to the imported store. This will let react-redux know which store it should provide to your React application.
   > The <App /> Components in the React application (and any other child Component) can now tap into the Redux store that is now provided. Component can now setup subscriptions to the store as well as dispatch actions.

   Using Redux Data In React Component Example:
      src/component/Counter.js:
         import { useSelector } from 'react-redux';
            const Counter = () => {
               const counter = useSelector((state) => state.counter);
               return (
                  <main className={classes.counter}>
                     <h1>Redux Counter</h1>
                     <div className={classes.value}>{counter}</div>
                     <button onClick={toggleCounterHandler}>Toggle Counter</button>
                  </main>
               );
            };

   > For a Component to get access to the Redux Store, first import the useSelector() Hook (a custom React Hook made by the React-Redux team) from the 'react-redux' library.
   > Important Note: The useStore Hook from the 'react-redux' library allows access to the whole store while the useSelector() Hook allows you to select a slice/part of the data store. If the Component is a Class-based Component then the 'react-redux' library provides a connect function which can be used as a wrapper around the component to connect to the store.
   > The useSelector() Hook takes in a function as an argument/parameter. This function will be executed by React-Redux which will determine which piece of data we want to extract from the store. The anonymous function receives a 'state' argument passed by React-Redux which will then allow you to retrieve a slice of the state from. The returned value is then stored in a const variable.
   > When using the useSelector() Hook the React-Redux library will automatically setup a Subscription to the Redux Store for the Component. The Component will therefore be updated and receive the latest state data automatically whenever that data changes in the Redux store. This change will cause the Component function to be re-executed so that the latest data is displayed in the Component.
   > If the Component was to unmount from the DOM the React-Redux will automatically clear the Component subscription for you behind the scenes.

   Dispatching Actions From A React Component Example:
      src/component/Counter.js:
         import { useSelector, useDispatch } from 'react-redux';
         const Counter = () => {
            ...
            const dispatch = useDispatch();
            const incrementHandler = () => { dispatch({ type: 'increment' }) };
            const decrementHandler = () => { dispatch({ type: 'decrement' }) };
            ...
            return (
               <main className={classes.counter}>
                  ...
                  <div>
                     <button onClick={incrementHandler}>Increment</button>
                     <button onClick={decrementHandler}>Decrement</button>
                  </div>
                  ...
               </main>
            );
         };

   > The useDispatch() Hook from the React-Redux library allows you to dispatch actions from inside of a Component file.
   > When you call the useDispatch() Hook it does not take any parameter, instead this Hook returns a function which you can store in a variable. You can call on this function to dispatch an action against the Redux store.
   > Within your event handler functions of your Component you can call on the 'dispatch' function (i.e. the function provided by useDispatch() Hook). An action is a object which has a type property. You would pass this action object to the dispatch function as an argument/parameter. The action type identifier must match exactly the action string that was setup within the Redux store's Reducer Function.
   > Whenever the event triggers e.g. on a button click the action will be dispatched from the Component to the Redux store to update the state and when that state is updated the Component (if subscribed to the Redux store) will re-execute on state changes and will re-render the Component.
   > In the above example the increment and decrement buttons will increase/decrease the Redux store's counter property which will trigger the subscription which will notify the subscribed Component. Since the Counter.js is a subscriber to the store, when it is notified the store has changed this will trigger a re-execution of the Component function to re-render the counter value to the screen.
   > This demonstrates all the fundamental of Redux Concepts being used within a React Project using the Redux library and implementations support from the React-Redux library.

------------------------------------------------------------------------------------
6. Using Redux with Class-based Components:
------------------------------------------------------------------------------------
   > While most modern React Projects use Functional Components there are a lot of older React projects that continue to use Class-based Components. Therefore the below demonstrate how the previous Counter.js Functional Component would look like if it were a Class-based Component implementing Redux.
   > You should at this point be aware that Class-based Components cannot use React Hooks. Therefore, the custom Hooks provided by the React-Redux library would not work with Class-based Components.

   Redux with Class-based Component Example:
      src/component/Counter.js:
         import React, { Component } from 'react';
         import { connect } from 'react-redux';
         import classes from './Counter.module.css';
         class Counter extends Component {
            incrementHandler() {
               this.props.increment();
            };
            decrementHandler() {
               this.props.decrement();
            };
            render() {
               return (
                  <main className={classes.counter}>
                     <h1>Redux Counter</h1>
                     <div className={classes.value}>{this.props.counter}</div>
                     <div>
                        <button onClick={this.incrementHandler.bind(this)}>Increment</button>
                        <button onClick={this.decrementHandler.bind(this)}>Decrement</button>
                     </div>
                     <button onClick={this.toggleCounterHandler}>Toggle Counter</button>
                  </main>
               );
            };
         };
         const mapStateToProps = (state) => {
            return {
               counter: state.counter
            };
         };
         const mapDispatchToProps = (dispatch) => {
            return {
               increment: () => dispatch({ type: 'increment' }),
               decrement: () => dispatch({ type: 'decrement' })
            };
         };
         export default connect(mapStateToProps, mapDispatchToProps)(Counter);

   > The React-Redux library exports a connect function which you would need to import into the Class-based Component. This function helps connect Class-based Component to the Redux store.
   > The connect function can also be used with Functional Components but using the React Hooks is much more convenient.
   > When exporting the Component you would call the connect() function which will return a new function as a value which you would then execute again passing in the Component as the argument/parameter to the executed function (i.e. connect()(Component)).
   > This syntax could look strange but the connect() function is a so called 'Higher Order Component' which is executed first and it returns another function which is then executed passing in the Component as the argument to the second executed function.
   > The connect() function itself expects two argument/parameters which are both functions:
      - The first function is conventionally called 'mapStateToProps' and is the equivalent to the useSelector() Hook. This function receives the Redux store as an argument/parameter automatically by Redux and it s then used to return an object where the keys will be available as props in the receiving Component and the values of those keys then uses the logic to extract from the Redux store.
      - The second function is conventionally called 'mapDispatchToProps' and is the equivalent to the useDispatch() Hook. This function receives dispatch as an argument/parameter automatically by Redux and it is then used to return an object where the keys will be available as props in the receiving Component and the value is then another function in which you call dispatch and then setup the action object.
   > Both these functions are used as pointers (not executed) to the connect() function which Redux will execute for us automatically behind the scenes.
   > The returned function from connect() will provide props (received from the 'mapStateToProps' and 'mapDispatchToProps' functions) to the linked Component. The Component can uses these exposed props to retrieve state from the Redux store as wel as dispatch actions to the Redux store via prop names.
   > To access the exposed props from the Component, use the 'this.props.' followed by the prop name you wish to access/execute.
   > The '.bind()' is required to bind the 'this' keyword to the class functions context.
   > The React-Redux library will setup and manage all the subscription for you when calling the connect() function. It is just an alternative to using the useSelector() and useDispatch() Hooks.
   > The functionality should work as before but now using Redux and React-Redux with Class-based Components.

------------------------------------------------------------------------------------
7. Attaching Payloads to Actions:
------------------------------------------------------------------------------------
   > Often you would want to dispatch actions that also carry an extra value.
   > Usually the extra value will come from a user input and it is not possible (or does not scale well) to multiple hard-code values within the Reducer Function.
   > The extra data is known as a payload.

   Attaching Payloads to Actions Example:
      src/store/index.js:
         import { createStore } from 'redux';
         const counterReducer = (state = { counter: 0 }, action) => {
            if(action.type === 'increase') {
               return { counter: state.counter + action.amount };
            };
            ...
         };
         const store = createStore(counterReducer);
         export default store;

      src/components/Counter.js:
         ...
         const Counter = () => {
            ...
            const increaseHandler = () => {
               dispatch({ type: 'increase', amount: 10 });
            };
            ...
            return (
               <main className={classes.counter}>
                  ...
                  <div>
                     <button onClick={increaseHandler}>Increment by 10</button>
                  </div>
               </main>
            );
         };

   > The payload property name can be of your choosing. In the above example the dispatched action receives the action type and a payload called amount.
   > The name of the payload property must match the same name inside of the reducer function for that action (or vice versa). In the above example the action.type "increase"  function can receive an "amount" payload data (i.e. on action.amount). The matching of the name is important in order to pass the payload along to the reducer function when dispatching actions.
   > While in the above example the Component dispatches a hardcoded value for the amount payload, you can in reality set this to a variable coming from a user input.
   > Action payloads are very common and are often needed. Payloads are simply extra properties added to the action object.

------------------------------------------------------------------------------------
8. Working with Multiple State Properties:
------------------------------------------------------------------------------------
   > To add a new piece of data to the Redux Store you need to go the Reducer Function and add the new piece of state to all the state snapshots.

   Working with Multiple State Properties Example:
      src/store/index.js:
         import { createStore } from 'redux';
         const initialState = { counter: 0, showCounter = true };
         const counterReducer = (state = initialState, action) => {
            if(action.type === 'increment') {
               return { counter: state.counter + 1, showCounter: state.showCounter };
            };
            if(action.type === 'increase') {
               return { counter: state.counter + action.amount, showCounter: state.showCounter };
            };
            if(action.type === 'decrement') {
               return { counter: state.counter - 1, showCounter: state.showCounter };
            };
            if(action.type === 'toggle') {
               return { counter: state.counter, showCounter: !state.showCounter };
            };
            return state;
         };
         const store = createStore(counterReducer);
         export default store;

      src/components/Counter.js:
         ...
         const Counter = () => {
            const counter = useSelector((state) => state.counter);
            const show = useSelector((state) => state.showCounter);
            ...
            return (
               <main className={classes.counter}>
                  <h1>Redux Counter</h1>
                  {show && <div className={classes.value}>{counter}</div>}
                  ...
               </main>
            );
         };

   > To make the code more readable you could extract the state object into its own variable (e.g. initialState) and then set the Reducer Functions 'state' argument/parameter to the extract state object.
   > Each function within the reducer functions would still need to return every property of the state because the function would return the overall state object.
   > Redux will not merge the changes with the existing state. Instead, it will take whatever is returned from the reducer function and replaces the existing state with it.
   > The useSelector() Hook can be used multiple times to retrieve multiple different pieces of state data from the Redux store to store in a variable to be accessed by the Component. Whenever that state updated (Redux automatically sets up a Subscription to the Redux store state) the Component file will re-execute again re-rendering the Component file UI.
   > The Component file can use this state to conditionally render HTML elements to the screen as seen in the above example with the 'show' state to conditionally render the Counter <div>.
   > This is how you can manage multiple pieces of different store data in state.

------------------------------------------------------------------------------------
9. How to Work with Redux State Correctly:
------------------------------------------------------------------------------------
   > We learnt that the Reducer function always returns a brand new snapshot of the state object which Redux will use to replace the existing state with. The state being returned will NOT be merged with the existing state instead they will override the existing state. Therefore, you must always set the other states whenever updating a piece of state.
   > You must never mutate the existing state but should always override the existing state by providing a new state object. This is because Objects and Arrays are reference values in JavaScript it is easy to accidentally override and change the existing state.
   > Refer to the following article on Primitive vs Reference Values to understand why mutating Objects or Arrays is not recommended in JavaScript (https://academind.com/tutorials/reference-vs-primitive-values/).
   > It is recommended not to mutate the original state object because this can lead to bugs, unpredictable behaviour, unexpected side effects and it can make debugging applications much more difficult. This can cause the UI to get out of sync and the UI not reflecting the true/correct state.
   > The simple rule is to never mutate your state instead replace it with a new object.

   Incorrect Mutation of Original State Example:
      if(action.type === 'increment') {
         state.counter++ 
         return { counter: state.counter, showCounter: state.showCounter };
      };

   > While the "state.counter++" will not cause any errors in the above example and will continue to increment as expected. However, doing this on other more complicated state which has nested objects and arrays, it can become more easy to accidentals mutate your existing state introducing bugs, unexpected behaviours and side effects. Therefore; avoid doing any mutations on existing state!
   > Returning a new object will always ensure that you update the existing state in an immutable way and you would never accidentally mutate your existing state.

------------------------------------------------------------------------------------
10. Using Redux Toolkit Library as a Solution:
------------------------------------------------------------------------------------
   > The more complex projects become the more complex it can get to use Redux correctly. There is a slightly easier way to use Redux as well.
   > At this point you should be familiar with the core fundamental Redux Concepts and also how to use Redux with React projects with the help of React-Redux library. We can now dive into an approach that is slightly more easier to setup and maintain.
   > Below are potential problems that could be identified with the core fundamental Redux approach if the project was to continue to grow in size:
      - The action types (identifiers): you need to avoid typos when dispatching actions identifier otherwise it will not be handled or handled correctly by the reducer. With larger applications and a larger developer contribution it is easy to mess up one of the identifier or have a clashing identifier names. Therefore, defining identifier once and re-using them can be something that can be done in JavaScript.
      - The amount of data you handle: the more data (i.e. different pieces of state) you have the bigger the state objects get. This would mean you would need to copy a lot of state whenever you update and return the state object from the reducer. This also means the reducer function will grow in size and become an unmaintainable and large Redux file.
      - The state immutability to respect: you need to always ensure to return a brand new state snapshot object and you do not accidentally change the existing state anywhere. Especially with more complex data with nested objects and arrays, it is easier to mess up and accidentally change some nested data even though you did not want to.
   > For all these problems there are solutions we could implement on our own e.g. for unique identifier we could create a const variables that store the identifier and export the variable. The const variable can be used to check the value in the reducer function. The const variable can then be imported in the Component file to use. This will ensure both identifiers will always match and avoid typos. This is a solution used in the past with Redux.

   Past Unique Identifier Solution Example:
      src/store/index.js:
         export const INCREMENT = 'increment';
         const counterReducer = (state = initialState, action) => {
            if(action.type === INCREMENT) {...};
            ...
         };

      src/components/Counter.js:
         import { INCREMENT } from '../store/index';
         const Counter = () => {
            ...
            const incrementHandler = () => { dispatch({ action.type = INCREMENT }) };
         };

   > There are solutions for splitting the Reducer Functions into smaller Reducers files so that you do not get a large Reducer file. There are also solutions and third party packages which allow you to automatically copy state and ensure that you do not accidentally mutate the original state.
   > However, we do not need to dive into those various solutions anymore and this is because there is another library called Redux Toolkit (https://redux-toolkit.js.org/). This library is developed by the same development team behind React-Redux and Redux libraries itself.
   > Redux Toolkit is simply an extra package which makes working with Redux more convenient and easier. You do not have to use it unlike React and React-Redux but if you do install it certain things will become easier.

   Terminal Command to Install Redux Toolkit:
      $: npm install @reduxjs/toolkit

   > After installing the Redux Toolkit package you could uninstall the Redux package from the package.json because it is included as part of the Redux Toolkit dependencies.
   > Redux Toolkit simplifies a couple of aspects of working with Redux and so it should be used within the store/index.js file.

   Using Redux Toolkit and Adding State Slices Example:
      src/store/index.js:
         import { createSlice } from '@reduxjs/toolkit';
         const initialState = { counter: 0, showCounter: true };
         const counterSlice = createSlice({
            name: 'counter',
            initialState,
            reducers: {
               increment(state) { state.counter++ },
               decrement(state) { state.counter-- },
               increase(state, action) { state.counter = state.counter + action.amount },
               toggleCounter(state) { state.count = !state.counter; }
            }
         });

   > The createSlice function allows us to create state slices. The createReducer function also allows you to create a reducer with certain enhancements. However; the createSlice method is more powerful than the createReducer function and will simplify couple of aspects in one go.
   > The createSlice function wants an object as an argument/parameter. The createSlice allows you to prepare a slice of the global state. When you have different pieces of state which are not directly related (e.g. authentication status and counter status) we could create different slices (potentially in different files) to make your code more maintainable.
   > Every slice needs a 'name' property which is an identifier of that piece of state. The value of the name is entirely up to you.
   > Next, you need to setup an initial state (i.e. an object or a pointer to a variable storing a state object) for the 'initialState' property on the object argument/parameter. The above example uses ES6 Object Property Value shorthand of 'initialState' which is the same as writing 'initialState: initialState'.
   > Finally, you need to setup reducers object for the 'reducers' property on the object argument/parameter. The 'reducer' object lists all the reducers that the state slice needs. Here you would all all the methods with any name of you choice, although those names will become important later.
   > Every method in the reducer object will receive the latest state as an argument/parameter from Redux automatically. There is no need to pass in action as a second argument because we no longer need to write our own if statement checks anymore, instead we will soon be able to identify the different reducers and dispatch actions that target the different reducers. This helps reduce some boilerplate code.
   > Within the reducer methods we are now allowed to mutate the state. This is because when using Redux Toolkit and its functions such as createSlice we cannot accidentally manipulate the existing state. This is because Redux Toolkit internally uses another package called 'imgur' which will detect mutating codes like 'state.counter++' and will automatically clone the existing state, create a new state object, keep all the state that are not edited and override the state which you are editing in an immutable way. Therefore, you still have immutable code even though it does not look like it because of the internally used package.
   > Redux Toolkit allows us as a developer to have a much easier time working with Redux because we do not need to create a copy manually and keep all the code we are not changing. Instead, we would change the code we want to change and internally it is translated into immutable code.
   > With Redux Toolkit we can still have actions that listen to extra payload. The reducer methods also receive 'action' as a second argument/parameter but we can decide whether to include or ignore it. Therefore, whenever the reducer method expects a payload you should add the 'action' as a second argument to the method.
   > The createSlice function returns a state slice which we need to store in a variable. The name of the variable is entirely up to you (e.g. counterSlice).
   > We now have a state slice created using the Redux Toolkit's createSlice function. How do we make the store aware of the slice and dispatch actions against this slice?

   Connecting Redux Toolkit State Example:
      src/store/index.js:
         import { createSlice, configureStore } from '@reduxjs/toolkit';
         const initialState = { counter: 0, showCounter: true };
         const counterSlice = createSlice({ ... });
         const store = configureStore({
            reducer: counterSlice.reducer
         });
         export default store;

   > To the createStore we could pass the createSlice function's returned state slice object and call .reducer on it (e.g. const store = createStore(counterSlicer.reducer)). This will be enough to connect the state slice and the reducer function to the React application. However, you will have a problem with this approach in larger application because there can only be one reducer passed to the createStore() function.
   > With standard Redux there is a combineReducers function which you can import and use.
   > However; Redux Toolkit provides a configureStore function which makes it a little easier to setup. The configureStore function just like the createStore function creates a Redux store but it makes merging multiple reducers into one reducer much easier.
   > The configureStore function takes in an object as an argument/parameter. This is a configuration object expected by the configureStore function. This takes an expected 'reducer' property which can have a value of a single reducer or an object with key:values where the key is the name of our choice for the the state slice and the value is the different Reducer functions. For example:
      - Single Reducer Syntax: reducer: counterSlice.reducer
      - Multiple Reducers Syntax: reducer: { counter: counterSlice.reducer, auth: authenticationSlice.reducer }
   > Behind the scenes the configureStore function will combine the different Reducers into one big global store data.
   > The state slice has now been connected to the Redux store. The question that now remains is how do we dispatch actions? This is because we do not have our own if statement checks and we do not know what identifiers to dispatch for our actions to trigger the reducer function methods.

   Dispatching Actions wit Redux Toolkit Example:
      src/store/index.js:
         import { createSlice, configureStore } from '@reduxjs/toolkit';
         const initialState = { counter: 0, showCounter: true };
         const counterSlice = createSlice({
            name: 'counter',
            initialState,
            reducers: {
               increment(state) { state.counter++ },
               decrement(state) { state.counter-- },
               increase(state, action) { state.counter = state.counter + action.payload },
               toggleCounter(state) { state.count = !state.counter; }
            }
         });
         const store = configureStore({ reducer: counterSlice.reducer });
         export const counterActions = counterSlice.actions;
         export default store;

      src/components/Counter.js:
         import { useSelector, useDispatch } from 'react-redux';
         import { counterActions } from '../store/index';
         const Counter = () => {
            const dispatch = useDispatch();
            ...
            const incrementHandler = () => { dispatch(counterActions.increment()) };
            const decrementHandler = () => { dispatch(counterActions.decrement()) };
            const increaseHandler = () => { dispatch(counterActions.increase(10)) };
            const toggleHandler = () => { dispatch(counterActions.toggleCounter()) };
            ...
         };

   > The createSlice function automatically creates unique action identifiers for the different reducers methods. To get hold of the action identifiers we can use the counterSlice and access the '.action' property. This is an object full of keys where the key names match the method names within the createSlice function within the reducers property area.
   > These action methods (called action creators) on the 'action' object when called will automatically create action objects for us where the 'type' property has a unique identifier per action automatically created behind the scenes by Redux Toolkit. For example:
      - counterSlice.actions.toggleCounter() returns an action object something like: { type: 'autogenerated identifier'}
   > We do not have to worry about action identifiers or create the action objects of our own because we can tap into the '.actions' object on the created slice and execute these action creator methods which with their names match the reducers methods to dispatch actions which will then ultimately trigger those different reducer methods.
   > This means that we as a developer do not have to worry about creating action objects on our own or coming up with unique identifier or avoiding typos.
   > We can store the '.action' object in a variable and export it so that the Component files that require the actions can import this export and use the '.actions' object to dispatch actions to the Redux store.
   > We can use this object which has all the reducer methods names as keys which you can use to dispatch with. Remember to executed the method when dispatch the action (e.g. 'counterActions.increment()'). This is because the method is an action creator that creates a full action object with the type set to the automatically created unique action identifier.
   > Where there is a payload data expected, we use the same syntax but pass the payload data as either an object with key:value pairs of you choice or a single value. For example:
      - dispatch(counterActions.increase(10));
      - dispatch(counterActions.increase({ amount: 10 }));
   > Any payload values you pass to the executed action creator method as an argument will be stored in an extra field named 'payload' which will store you passed in values (whether a single value or an object). For example:
      - { type: 'SOME_UNIQUE_VALUE', payload: 10 }
      - { type: 'SOME_UNIQUE_VALUE', payload: { amount: 10 } }
   > To access these payload values in the Redux store file you would either need to use:
      - reducers: { increase(state, action) { state.counter = state.counter + action.payload } }
      - reducers: { increase(state, action) { state.counter = state.counter + action.payload.amount } }
   > This will depend all on how you pass the payload data through from the action in order to access the passed down value in the reducer method i.e. whether to call on the action objects 'payload' property or need to use dot notation to drill into the 'payload' property to access the relevant key on the object you passed as a payload to the action objects default 'payload' property.
   > Redux Toolkit creates this 'payload' property on the actions object which you cannot change to a different name.
   > With all of this work to migrate/refactor the code over to use Redux Toolkit library, you now have a React application that works as before but without the shortcomings mentioned at the beginning. Your React application will be much more easier to work with and maintain the Redux store especially as the application grows in size and complexity.

------------------------------------------------------------------------------------
11. Working with Multiple Slices:
------------------------------------------------------------------------------------
   > In the below example we will explore working with multiple slices from the Redux store using the Redux Toolkit.
   > The below example will use a login form to log a user into some login mode which will change what is displayed in the navigation bar Component and the login form switched out for a user profile Component. This is to simulate some form of authentication state which is an application wide state which matters to a lot of Components in the application.

   Multiple Slices Example:
      src/store/index.js:
         import { createSlice, configureStore } from '@reduxjs/toolkit';
         const initialCounterState = { counter: 0, showCounter: true };
         const counterSlice = createSlice({
            name: 'counter',
            initialState: initialCounterState,
            reducers: {
               increment(state) { state.counter++ },
               decrement(state) { state.counter-- },
               increase(state, action) { state.counter = state.counter + action.payload },
               toggleCounter(state) { state.count = !state.counter; }
            }
         });
         const initialAuthState = { isAuthenticated: false };
         const authSlice = createSlice({
            name: 'authentication',
            initialState: initialAuthState,
            reducers: {
               login(state) { state.isAuthenticated = true },
               logout(state) { state.isAuthenticated = false }
            }
         });
         const store = configureStore({ reducer: { counter: counterSlice.reducer, auth: authSlice.reducer  } });
         export const counterActions = counterSlice.actions;
         export const authActions = authSlice.actions;
         export default store;

   > In programming you would want to separate your concerns i.e. the slices focuses on the state and action related to what the slice data is concerned about. The counterSlice is not concerned with authentication and so a new slice should be created for the authentication state and actions. The position of the slices does not matter, so long as it comes before the store creation line.
   > The authentication slice has two reducers to change the isAuthenticated state from true/false on login/logout actions.
   > It is very important that when working with multiple slices the must only be one redux store i.e. you should only call the configureStore function once and should not be change.
   > The store must have one root reducer. The store reducer property does not just take in a reducer function as a argument but it can instead take a object that acts as a map of reducers. This key:value pairs of properties name to individual reducers will automatically be merged together into one main reducer which is then exposed to the store.
   > This is how we can combine both the counter and auth slices together into one store (e.g. 'reducer: { counter: counterSlice.reducer, auth: authSlice.reducer  }').
   > You can now also export the exposed actions from the authSlice reducer. Whichever Component requires the state from a slice can import the exported store and actions as normal.

   Reading & Dispatching from a State Slice Example:
      src/components/App.js:
         import React, { Fragment } from 'react';
         import { useSelector } from 'react-redux';
         ...
         function App() {
            const isAuth = useSelector(state => state.auth.isAuthenticated);
            ...
            return(
               {!isAuth && <Auth />}
               {isAuth && <UserProfile />}
               ...
            );
         };
      src/components/Header.js:
         import React from 'react';
         import { useSelector, useDispatch } from 'react-redux';
         import { authActions } from '../store/index';
         const Header = () => {
            const isAuth = useSelector(state => state.auth.isAuthenticated);
            const dispatch = useDispatch();
            const onLogoutHandler = (event) => {
               event.preventDefault();
               dispatch(authActions.logout());
            };
            return (
               <header className={classes.header}>
                  <h1>Redux Auth</h1>
                  {isAuth && (
                     <nav>
                        ...
                        <li><button onClick={onLogoutHandler}>Logout</button></li>
                     </nav>
                  )}
               </header>
            );
         };
      src/components/Auth.js:
         import React from 'react';
         import { useDispatch } from 'react-redux';
         import { authActions } from '../store/index';
         const Auth = () => {
            const dispatch = useDispatch()
            const loginHandler = (event) => {
               event.preventDefault();
               dispatch(authActions.login());
            };
            return (
               <main className={classes.auth}>
                  <section>
                     <form onSubmit={loginHandler}>
                        ...
                     </form>
                  </section>
               </main>
            );
         };
      src/components/Counter.js:
         import { useSelector, useDispatch } from 'react-redux';
         import { counterActions } from '../store/index';
         ...
         const Counter = () => {
            const dispatch = useDispatch();
            const counter = useSelector((state) => state.counter.counter);
            const show = useSelector((state) => state.counter.showCounter);
            ...
         };

   > Import the useSelector function from the react-redux library in order to tap into a Redux store and retrieve/read a state from the store. The useSelector function always takes in another function which receives the state as a argument/parameter automatically passed by the Redux (react-redux to be precise) library.
   > Whenever drilling into the state of the store to extract a state you would need to use the identifiers (property names) for the slice reducer you wish to tap into e.g. 'state.auth.isAuthenticated', 'store.counter.counter' and 'state.counter.showCounter' seen above.
   > The Header Component will only display navigation links when the isAuth is true (i.e. isAuthenticated state is set to true). The Auth Component has a login form and would dispatch an action to authenticate and login a user updating the isAuthenticated state from false to true. Note: the above example does not demonstrate authentication, the demo code purpose is to show Redux and working with multiple slices.
   > The useDispatch function must also be imported from the react-redux library. The reducer action must also be imported into the Component which wishes to dispatch an action to the Redux store (e.g. authActions).
   > The useDispatch should be stored in a variable and then the Component can use this variable and pass in the imported actions which will expose action creators which will create an actual action object to dispatch the action to the Redux store slice.
   > You can use an onClick event listener to trigger an event which will trigger a dispatch action on the login and logout button to dispatch the .login() and .logout actions. The action creator exposed by the exported actions will create an actual action object to dispatch to the Redux store which will trigger the particular action and update the store which will update the subscribed Component UI.
   > This is how you can create multiple slices to a Redux store and then read and dispatch actions to the Redux store triggering the particular slice for particular Components that are interested in subscribing to the state slice. This app-wide state allows multiple Components to subscribe and update their UI based on state changes to the Redux store.
   > As you can see that it is very easy to create and manage multiple slices when using Redux Toolkit.

------------------------------------------------------------------------------------
12. Splitting Redux Store Code:
------------------------------------------------------------------------------------
   > In a typical React project where you would have multiple state slices the Redux store file (i.e. the src/store/index.js file) can become very long. Therefore, it may be worth splitting the file into smaller pieces.
   > When using Redux Toolkit it could make total sense to put every slice in its own file (the file name is entirely up to you for the slices e.g. counter.js or counter-slice.js).

   Splitting Redux Store Code Example:
      src/store/auth.js:
         import { createSlice } from "@reduxjs/toolkit";
         const initialAuthState = { isAuthenticated: false };
         const authSlice = createSlice({
            name: 'authentication',
            initialState: initialAuthState,
            reducers: {
               login(state) {
                  state.isAuthenticated = true
               },
               logout(state) {
                  state.isAuthenticated = false
               }
            }
         });
         export const authActions = authSlice.actions;
         export default authReducer.reducer;
      src/store/counter.js:
         import { createSlice } from "@reduxjs/toolkit";
         const initialCounterState = { counter: 0, showCounter: true };
         const counterSlice = createSlice({
            name: 'counter',
            initialState: initialCounterState,
            reducers: {
               increment(state) {
                  state.counter++;
               },
               decrement(state) {
                  state.counter--;
               },
               increase(state, action) {
                  state.counter = state.counter + action.payload;
               },
               toggleCounter(state) {
                  state.showCounter = !state.showCounter;
               }
            }
         });
         export const counterActions = counterSlice.actions;
         export default counterSlice.reducer;
      src/store/index.js:
         import { configureStore } from '@reduxjs/toolkit';
         import authReducer from './auth';
         import counterReducer from './counter';
         const store = configureStore({
            reducer: { counter: counterReducer, auth: authReducer }
         });
         export default store;

   > Each slice is stored in its own file which is then imported into the index.js store file to create the single Redux store.
   > More specifically since the createStore requires only the .reducer from the slice, the individual slice files should export the .reducer function and not the whole slice itself (e.g. 'export default counterSlice.reducer' and not 'export default counterSlice;').
   > In index.js when importing the default exported slice reducers we could name the default import as e.g. 'authReducer' and 'counterReducer' to make it clear that the reducer is being imported and used in the configureStore function.
   > Component files that require the dispatch actions would need to now import the named exported actions from the particular slice file and not from the index.js (store) file.
   > The Redux store is now more manageable by splitting the code and can now be maintained and scaled as the application grows in functionality and complexity.