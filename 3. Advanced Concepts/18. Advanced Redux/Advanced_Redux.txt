Advanced Redux - Summary:
1. Redux & Side Effects (Asynchronous Code)
2. Where to Put the Side Effect (Async Code) Logic
3. Method 1 - Using useEffect with Redux

------------------------------------------------------------------------------------
1. Redux & Side Effects (Asynchronous Code):
------------------------------------------------------------------------------------
   > One important rule any reducer functions is that they must be pure i.e. side-effect free and synchronous. The reducer function should simply take in some input (i.e. old state + action) and produces some out (i.e. new state). For the same input and values it should always produce the same output without any side-effects that happen along the way and without any asynchronous code that blocks it.
   > This is a general reducer concept and is not Redux Reducer Function specific (e.g. even React useReducer() Hook abides by the same concept).
   > This should lead to one important question. When working with Redux and dispatching some action that would involve some side-effect such as a HTTP request where would you put that side-effect (asynchronous) code? The Reducer Function is clearly thr wrong place. There are two possible places where side-effect code can live:
      1. Inside the Component (e.g. with useEffect() Hook) - Redux will not be aware of anything to do with the side-effect code; or
      2. Inside the Actions Creator - Not using the automatically generated actions provided by the Redux Toolkit but writing your own action creator code.

   > Redux actually has a solution that allow us to perform side effects and run asynchronous tasks as part of these action creators without changing the reducer function.
   > Remember: Do not perform side effect code inside of Reducers no matter if it is synchronous or asynchronous (and also do not run any asynchronous code in a reducer in general).
   > It is important to recognise that the code you need to write on the frontend and where you write that code will depend on your backend code. This is because the backend API server will talk to the frontend application with the help of HTTP and Responses being sent around.
      - If you had a backend API that does a lot of work (i.e. transform and stores data) then the front-end application can do less work. It could send data like a product to be added to cart, allow the backend perform the transformation and then use the response on the frontend to then just hand it off to the reducer to store that response. This allows you to slim down the reducer to store the response in Redux.
      - If you had a backend API that does not do a lot of work (i.e. just stored incoming data in the format it receives it in) then the front-end application needs to do more work. Here it needs to prepare/transform the data before saving to the Redux store. However, the sending of the data to the backend store must be done outside of the Reducer Function. Therefore, with this approach you would need to decide where best to place your code.

                                                      ------------------------------------[Backend]------------------------------------
                                                      |                                      ^                                        |
                                                      v                                      |                                        v
                                          Does a lot of working                              |                          Does not do a lot of work
                                    (i.e. transform data + store data)                       |                       (i.e. just stores incoming data)
                                                      ^                                      |                                        ^
                                                      |                                      |                                        |
                                                      v                                      |                                        v
                                       Send & Receive Data + use response                    |                          Transform Data & Send Data
                                    (i.e. less code on the fontend, ahead of the reducer)    |                 (i.e. more code on the frontend, ahead of the reducer)
                                                      ^                                      |                                        ^
                                                      |                                      v                                        |
                                                      ------------------------------[Frontend React App]-------------------------------

------------------------------------------------------------------------------------
2. Where to Put the Side Effect (Async Code) Logic:
------------------------------------------------------------------------------------
   > You can use the useSelector() function from React-Redux within a Component to get the cart before it is updated and then do all that transformation inside of the Component (without mutating the state) and then send the HTTP request. The code would look like something of the below example:

   Transformation in Component Example:
      src/store/cart-slice.js:
         import { createSlice } from '@reduxjs/toolkit';
         const cartSlice = createSlice({
               name: 'cart',
               initialState: { items: [], totalQuantity: 0
            },
            reducers: {
               replaceCart(state, action) {
                  state.totalQuantity = action.payload.totalQuantity;
                  state.items = action.payload.items;
               },
               addItemToCart(state, action) { ... },
               removeItemFromCart(state, action) { ... },
            }
         });
         export const cartActions = cartSlice.actions;
         export default cartSlice;
      src/components/Shop/ProductItem.js:
         import { useDispatch, useSelector } from 'react-redux';
         ...
         const ProductItem = (props) => {
            const cart = useSelector((state) => state.cart);
            const dispatch = useDispatch();
            const { title, price, description, id } = props;
            const addToCartHandler = () => {
               const newTotalQuantity = cart.totalQuantity + 1;
               const updatedItems = cart.items.slice();                                   // create copy via slice to avoid mutating original state
               const existingItem = updatedItems.find((item) => item.id === id);
               if (existingItem) {
                  const updatedItem = { ...existingItem };                                // new object + copy existing properties to avoid state mutation
                  updatedItem.quantity++;
                  updatedItem.totalPrice = updatedItem.totalPrice + price;
                  const existingItemIndex = updatedItems.findIndex((item) => item.id === id);
                  updatedItems[existingItemIndex] = updatedItem;
               } else {
                  updatedItems.push({ id: id, price: price, quantity: 1, totalPrice: price, name: title });
               };
               const newCart = { totalQuantity: newTotalQuantity, items: updatedItems};
               dispatch(cartActions.replaceCart(newCart));
               fetch('firebase-url', { method: 'POST', body: JSON.stringify(newCart) })   // Then send Http request
               dispatch(cartActions.addItemToCart({ id, title, price }));
            };
            return (...);
         };

   > The code above would work but the problem with the above example approach is that where you need this addToCartHandler logic in a Component file, you would need to copy all that code to the other Component (e.g. a Cart.js Component file). You could outsource the code into its own file to export that as a function to prevent code duplication.
   > However, you would have another problem. The data transformation is done in some helper function and then in the end directly within the Component. The transformation is not done within the Reducer Function and could end up using the 'replaceCart' approach in all the places within the application. This would mean the Redux Reducers would not do a lot of work i.e they get some data and store it.
   > This can be fine (and is a personal preference which is not necessarily bad); however, it is not the main idea behind using Redux.
   > When it comes to the question of where to put your code you have the choice between "Fat Reducers", "Fat Components" or "Fat Actions".

   > Where should the logic (code) go?
      [Synchronous, side-effect free code (i.e. data transformation)]                  [Asynchronous code or code with side-effects]
         - Prefer Reducers                                                                - Prefer Action Creators or Components
         - Avoid Action Creators or Components                                            - Avoid Reducers
   
   > Therefore, if the code is more leaning towards the left side (i.e. data transformation), then you should prefer Reducers. While you could have code in your Components (which is perfectly fine), it is generally considered a bit better to prefer Reducers and avoid Action Creators or Components.
   > If the code is leaning towards the right side (i.e. async/async side-effect code) then you should prefer Action Creators or Components and must never use Reducers.
   > Therefore, looking at the above code example, the data transformation is occurring in the Component and not inside of the Reducer (if you relied on the 'replaceCart') and that is sub-optimal code. But what would be a better way of doing it then? You need to prepare the data before you can send it off to a backend database using HTTP but this cannot be done inside the Reducer.
   > The next sections will explore how you can use the two methods mentioned previously to make the above example code more optimal.

------------------------------------------------------------------------------------
3. Method 1 - Using useEffect with Redux:
------------------------------------------------------------------------------------
   Using useEffect Example:
      src/App.js:
         import React, { useEffect } from 'react';
         import { useSelector } from 'react-redux';
         ...
         function App() {
            ...
            const cart = useSelector(state => state.cart);
            useEffect(() => {
               fetch('https://advanced-redux-demo-default-rtdb.firebaseio.com/cart.json', {
                  method: 'PUT',
                  body: JSON.stringify(cart)
               });
            }, [cart]);
            return (...);
         };
      src/components/Shop/ProductItem.js:
         ...
         const ProductItem = (props) => {
            const dispatch = useDispatch();
            const { title, price, description, id } = props;
            const addToCartHandler = () => {
               dispatch(
                  cartActions.addItemToCart({
                     id,
                     title,
                     price,
                  })
               );
            };
            ...
         };
   src/store/cart-slice.js:
      import { createSlice } from '@reduxjs/toolkit';
      const cartSlice = createSlice({
         name: 'cart',
         initialState: {
            items: [],
            totalQuantity: 0,
         },
         reducers: {
            addItemToCart(state, action) {
               const newItem = action.payload;
               const existingItem = state.items.find((item) => item.id === newItem.id);
               state.totalQuantity++;
               if (!existingItem) {
                  state.items.push({
                     id: newItem.id,
                     price: newItem.price,
                     quantity: 1,
                     totalPrice: newItem.price,
                     name: newItem.title
                  });
               } else {
                  existingItem.quantity++;
                  existingItem.totalPrice = existingItem.totalPrice + newItem.price;
               };
            },
            ...
         };

   > You would want to dispatch the action from the Component file and do all of the heavy work inside of the Reducer Function.
   > If you now want to sync (update) the server with the new state derived from the frontend you can simply switch the order. You can either do the work on the front-end and let Redux update its store and in a second step thereafter we send a request to the server but do not necessarily need to do this inside of the Reducer Function (which you would not be allowed to do asynchronous/side-effect code).
   > The second step (i.e.syncing code) can be done inside of the Component file or a separate file such as the App.js root Component file. For example, you can listen to changes to the overall "cart" in the App.js Component using the useSelector and whenever the state changes we can send a HTTP request as seen in the example above.
   > The useEffect Hook can be used to watch for changes in the "cart" state. The useEffect Hook allows you to run a side-effect and allows you to run an effect whenever some dependency changes.
   > Note that this could be applied to any Component and does not have to be the root Component.
   > A 'PUT' request method allows you to POST/PUT new data into a database. The difference between the 'POST' and 'PUT' request is that the 'PUT' request will overwrite the existing data with the incoming data. The "cart" state data is a JSON object which is converted into a string JSON data to send across to the server. The "cart" state is used as a dependency to trigger the useEffect side-effect upon any changes to that state.
   > The useSelector() function sets up a subscription to the Redux store and so the Component will be re-executed whenever the state changes triggering the HTTP request. This simple addition allows you to add side-effect/asynchronous code without placing the code inside of the Reducer Function (which you are not allowed to do). The synchronous code for updating the state can remain inside of the Reducer Function.
   > You simply switch the order i.e. you update the Redux store and then select the updated store to send the request to the server. This allows you to keep a lean Components, create a Fat Reducer and then perform any side-effects (asynchronous) code that might depend on the Redux state in the Component or a separate file.
   > Important Note: there is one problem with using the useEffect method the way it is shown in the above example - the useEffect side-effect will execute when the app starts. This is a problem because it will send an empty "cart" state to the backend server overwriting any existing data stored in the database.
   > In the above example the HTTP request is being sent but we are not doing anything with the response and the code does not handle any potential errors.

   Handling HTTP States and Feedback with Redux Example:
      src/components/UI/Notifications.js:
         import classes from './Notification.module.css';
         const Notification = (props) => {
            let specialClasses = '';
            if(props.status === 'error') {
               specialClasses = classes.error;
            };
            if(props.status === 'success') {
               specialClasses = classes.success;
            };
            const cssClasses = `${classes.notification} ${specialClasses}`;
            return (
               <section className={cssClasses}>
                  <h2>{props.title}</h2>
                  <p>{props.message}</p>
               </section>
            );
         };
      src/store/ui-slice.js:
         import { createSlice } from '@reduxjs/toolkit';
         const uiSlice = createSlice({
            name: 'ui',
            initialState: { cartIsVisible: false, notification: null },
            reducers: {
               toggle(state) {
                  state.cartIsVisible = !state.cartIsVisible;
               },
               showNotification(state, action) {
                  state.notification = {
                     status: action.payload.status,
                     title: action.payload.title,
                     message: action.payload.message
                  };
               }
            }
         });
         export const uiActions = uiSlice.actions;
         export default uiSlice;
      src/App.js:
         import React, { Fragment, useEffect } from 'react';
         import { useSelector, useDispatch } from 'react-redux';
         import Notification from './components/UI/Notification';
         import { uiActions } from './store/ui-slice';
         ...
         let isInitial = true;
         function App() {
            const dispatch = useDispatch();
            const showCart = useSelector((state) => state.ui.cartIsVisible);
            const cart = useSelector(state => state.cart);
            const notification = useSelector(state => state.ui.notification);
            useEffect(() => {
               const sendCartData = async () => {
                  dispatch(
                     uiActions.showNotification({
                        status: 'pending',
                        title: 'Sending...',
                        message: 'Sending cart data!'
                     })
                  );
                  const response = await fetch('https://advanced-redux-demo-default-rtdb.firebaseio.com/cart.json', {
                     method: 'PUT',
                     body: JSON.stringify(cart)
                  });
                  if(!response.ok) { throw new Error('Sending cart data failed') };
                  dispatch(uiActions.showNotification({ status: 'success', title: 'Success!', message: 'Sent cart data successfully!' }));
               };
               if(isInitial) {
                  isInitial = false;
                  return;
               };
               sendCartData().catch(error => {
                  dispatch(uiActions.showNotification({ status: 'error', title: 'Error!', message: 'Sending cart data failed!' }));
               }); 
            }, [cart, dispatch]);
            return (
               <Fragment>
                  {notification && <Notification status={notification.status} title={notification.title} message={notification.message}/>}
                  <Layout>...</Layout>
               </Fragment>
            );
         };

   > The Notification Component is a simple component which can display different notifications with different CSS styles which will show at the top of the page.
   > We can use the .then() syntax or async/await syntax to add the notification to the side effect code. Note that if using async/await syntax inside of useEffect, you should wrap the side-effect code in another function and call async on that function as seen above with the "sendCartData" function which wraps the fetch request. Do not add async in-front of the anonymous function argument for useEffect as this will cause an error.
   > The Redux store "ui-slice" can store a state for the notification which Components can then use to to listen to and dynamically display notifications such as sending a HTTP request, success and error messages, etc. The showNotification action can be dispatched from a Component whenever we perform fetch requests.
   > The dispatch function is now also a dependency. React-Redux will ensure this dispatch function will never change and will never trigger the useEffect to re-run again.
   > The "notification" Redux state will either be "null" or a state we set when dispatching the showNotification action. This will then allow us to conditionally render the Notification Component and provide extra data to this Component.
   > To avoid the application running the side-effect HTTP request previously mentioned above, we can add a variable outside the Component function (e.g. "isInitial") and set its value to true. Using an if statement we can check whether the application is executing for the first time using this variable and if return from the function (avoid executing the sendCartData() function).
   > The variable can then be set to false so that the sendCartData() function can be executed thereafter.