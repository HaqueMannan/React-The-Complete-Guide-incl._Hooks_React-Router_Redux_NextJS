A Look Behind the Scenes of React & Optimisation Techniques - Summary:
1. How React Really Works
2. A Close Look at Component Updates in Action
3. A Closer Look at Child Component Re-Evaluation
4. Preventing Unnecessary Re-Evaluations with React.memo()
5. Preventing Function Re-Creation with useCallback() Hook
6. The useCallback() Hook and its Dependencies
7. A Closer Look at State and Components
8. Understanding State Scheduling & Batching
9. Optimising with the useMemo() Hook

------------------------------------------------------------------------------------
1. How React Really Works:
------------------------------------------------------------------------------------
   > React is a JavaScript library for building user interfaces.
   > React is all about building Components (i.e. it embraces this concept of Components).
   > ReactDOM is the interface to the web.
   > ReactJS (i.e. React) itself does not know nothing about the web. It only knows how to work with Components. It does not care whether those Components contains HTML elements or totally fictional elements.
   > ReactDOM at the end cares about HTML elements and bringing in real HTML elements to the screen.
   > React is a library that manages Components, Props, Context, State, and different Component States. React hands over all the information regarding what changed and what should be visible on the screen off to the interface it is working with i.e. ReactDOM. ReactDOM is then responsible for working with the real DOM (which is part of the browser) and therefore ReactDOM is actually responsible for what is rendered to the real DOM and what the user actually sees on their screen.
   > 'Props' are Data from Parent Component, 'State' is the internal data inside of a Component and 'Context' is the Component-wide data.
   > Whenever 'props', 'state' or 'context' changes the Components that use these concepts are updated by React and React checks whether the Component wants to draw something new onto the screen and if that should be the case then React will let ReactDOM know about that so that it can bring that new render/output to the screen.
   > The question is how does the Components to Real DOM communication actually work?
   > React uses a concept called the 'Virtual DOM'. React determines how the current Component tree (which the app is building in the end and every Component itself has a sub tree that the JSX code returned by that Component) looks like and what it should look like for example, after a state update. That information is handed off to ReactDOM which now knows about the differences and which then knows how it should manipulate the real DOM to match that virtual DOM.
   > There is one important thing to note: whenever a 'prop', 'state' or 'context' of a Component changes, that Component function is re-executed (i.e. that Component is re-evaluated by React). However, re-evaluating a Component is not the same as re-rendering the DOM. Therefore, just because a Component function is re-executed by React does not mean that the respective part of the actual real DOM is re-rendered or re-evaluated.
   > We have to differentiate between our Component/React part and the real DOM.
   > The real DOM is only updated in the places where it needs to be changed based on that difference React derived between the previous state of a Component and its tree and the current state after the prop/state/context change.
   > Therefore, the real DOM is not changed all the time and it is changed rarely and only when need (i.e. only made for differences in evaluation). This is important for performance because making a virtual comparison between the previous state and the current state is cheap and easy to do because it only occurs in memory. Reaching out to the real DOM that is rendered to the Browser is expensive from a performance perspective (i.e. working with the real DOM is a performance intensive task).
   > If you make tiny changes in a lot of places all the time then the page might become slow because you end up working with the real DOM too much. This is the reason for why React has this structure of doing virtual comparisons with the virtual DOM and then only passing the changes between the last and current snapshot to the real DOM.
   > This is how React works ie. by doing this 'Virtual DOM Diffing' - finding the differences between two snapshots. Below is an Example:

   Virtual DOM Diffing Illustration Example:
      Previous Evaluation Result:            Current Evaluation Result:
         <div>                               <div>
            <h1>Hello World!</h1>               <h1>Hello World!</h1>
         </div>                                 <p>This paragraph is new!</p>
                                             </div>

   > React will determine the difference between both snapshots is the paragraph element.
   > React will report this change to ReactDOM (i.e. the '<p>This paragraph is new!</p>' should be inserted to the DOM and the rest should stay unchanged).
   > ReactDOM will update the real DOM and insert this paragraph element. It will not re-render the whole entire DOM i.e. it will not touch the existing <div/> and <h1/> elements but instead insert the <p/> element after the <h1/> element inside of the <div/> element.
   > This is how React works behind the scenes in a nutshell.
   > It is very crucial that you understand how all of this behind the scenes actually behaves to extend your knowledge about how React works with ReactDOM which will make you a better developer and help you to identify and resolve bugs within a React project code much faster and easily.

------------------------------------------------------------------------------------
2. A Close Look at Component Updates in Action:
------------------------------------------------------------------------------------
   > To illustrate and view the Component Update in action we will use the below code as a demonstration to render a new paragraph to a Component.
   > React will only re-run the Component function and re-evaluate what is on the screen if the 'props', 'state' or 'context' changes.
   > Remember: Ultimately, it all comes down to 'State' changes. Even context internally will use some state that might change the value which is then distributed through context. If we also think about props being passed from a parent to a child, how could the value passed through 'props' change? Again, only if 'state' in a parent changed. Hence, it all comes down to 'State' changes in the end if you think about it.

   Component Update Example:
      import React, { useState } from 'react';
      import Button from './components/UI/Button/Button';
      function App() {
         const [showParagraph, setShowParagraph] = useState(false);
         const toggleParagraphHandler = () => {
            setShowParagraph((prevShowParagraph) => !prevShowParagraph);
         };
         return (
            <div className="app">
               <h1>Hello World!</h1>
               {showParagraph && <p>This paragraph is new!</p>}
               <Button onClick={toggleParagraphHandler}>Toggle Paragraph</Button>
            </div>
         );
      };

   > The toggleParagraphHandler function could have been written shorter using 'setShowParagraph(!showParagraph);' syntax (i.e. set the showParagraph value to be the opposite of the old value). However, since you rely on the previous State snapshot you would want to use the function form for the state update. We will revisit and explain why you would do this in a later section. But note that the above example is the cleaner way for updating state that relies on the previous state snapshot.
   > The Component has the logic to conditionally show a paragraph when you click the button.

   Analysing the Component Updates in Action:
      > If you add a 'console.log('APP RUNNING');' code before the 'const toggleParagraphHandler = () => {...}' line, you should see "APP RUNNING" in the browser's console whenever you click the button. This should demonstrate that the Component function is re-evaluated whenever there is a 'prop', 'state' or 'context' change within a Component.
      > Therefore, when the application runs for the first time and runs the Component function for the first time you should see the "APP RUNNING" within the browser's console.
      > On the first execution (render cycle) React found out that it wants a <div>, <h1> and a <Button> (actual HTML will be <button>) element and no <p> element because it is not shown. It checks this with the last output it saved. Since this rendered the Component for the first time, there is essentially no previous output/snapshot and therefore the difference comparison in the end resulted in the <div>, <h1> and <button> to be rendered. This information is sent off to ReactDOM library which renders real HTML elements to the actual DOM (i.e. to the browser screen).
      > If you click on the the "Toggle Paragraph" button you should see "APP RUNNING" printed again in the browser's console. This proves the point that for every 'State' change, the entire Component in which the state changed is re-executed and re-evaluated.
      > How is the real DOM affected? If you go to the "Elements" tab within the browser's developer tools and expand the "<div class="app">" element you will notice that things that are changed within the real DOM will be flashed on screen in the "Elements" developer tool which shows where the real DOM was re-rendered or updated.
      > You will notice when you click the "Toggle Paragraph" button to add the paragraph, only the <p> element would flash and nothing else. If you click the "Toggle Paragraph" button again to remove the paragraph then only the parent "<div class="app">" element will flash because the <p> element was removed from that parent element. The <h1> and <button> elements will not flash again because they are  not re-rendered again by the real DOM.
      > This should visually demonstrate that only the differences between those virtual snapshots was considered for the updates made to the real DOM. This is really crucial to understand. 

------------------------------------------------------------------------------------
3. A Closer Look at Child Component Re-Evaluation:
------------------------------------------------------------------------------------
   > The below example code will provide a closer look at how a Child Component Re-Evaluates in React.
   > To demonstrate this, the Child Component will receive a prop from the Parent Component to conditionally render the text within the paragraph.

   Child Component Re-Evaluation Example:
      App (Parent) Component:
         import React, { useState } from 'react';
         import Button from './components/UI/Button/Button';
         import DemoOutput from './components/Demo/DemoOutput';
         function App() {
            const [showParagraph, setShowParagraph] = useState(false);
            const toggleParagraphHandler = () => { setShowParagraph((prevShowParagraph) => !prevShowParagraph)};
            return (
               <div className="app">
                  <h1>Hello World!</h1>
                  <DemoOutput show={false} />
                  <Button onClick={toggleParagraphHandler}>Toggle Paragraph</Button>
               </div>
            );
         };

      Button (Child) Component:
         const Button = (props) => {
            console.log('Button RUNNING');
            return (
               <button type={props.type || 'button'} onClick={props.onClick} disabled={props.disabled}>
                  {props.children}
               </button>
            );
         };

      DemoOutput (Child) Component:
         const DemoOutput = (props) => {
            console.log('DemoOutput RUNNING');
            return(
               <p>{props.show ? 'This paragraph is new!' : ''}</p>
            );
         };

   > The paragraph element in the DemoOutput Component is always rendered; however, only the text will change based on the 'show' prop value which comes from the Parent Component via 'props'.
   > The show prop is set to the showParagraph state which will result in a true or false value based on the "Toggle Paragraph" button.
   > This logic will dynamically change what is displayed in the Child Component's paragraph element. The behaviour of the app is the same as before but now using a Child Component to control the paragraph element.

   Analysing the Child Component Re-Evaluation in Action:
      > If you go to the "Elements" tab within the browser's developer tools you will notice the <p> element is already rendered to the screen after the first execution and always appears. However, when you click the button to toggle between displaying a text you will see the <p> element flashing. This is treated as a change for the entire paragraph element, which is why the <p>> flashes on real DOM changes and not just the text.
      > The <h1> and <button> elements do not change/flash. The fact that you use a custom Component/element does not change this. The updating mechanism should always work by comparing differences.
      > You will also notice in the browser's developer tool console that the "APP RUNNING" is being printed every time we click the button. The actual change occurs in the DemoOutput Component but the App Component runs again as well because that is where we manage the state.
      > The Component where you manage 'State' or have 'Props' or 'Context' and that state/prop/context changes then that Component will be re-evaluated and re-executed. Therefore, just because the change visually affects the paragraph in another Component does not mean that the Parent Component which manages the state/prop/context is not re-evaluated.
      > This is also what was meant earlier with 'Props' and 'Context' in the end always come down to 'State' changes.
      > You will also notice the "DemoOutput RUNNING" also printing everytime the "Toggle Paragraph" button is clicked (including when the Child Component initially renders).

      > The above example is simple to understand the logic. Taking the above example, if we were to change the 'show' prop in the Parent App Component to be a hard coded value (i.e. "<DemoOutput show={false}" />) and therefore the paragraph will never show. The showParagraph state will change on the "Toggle Paragraph" button click but we are no longer using the value for the 'show' prop.
      > If we were to now click the "Toggle Paragraph" button we will now see something more confusing: both the "APP RUNNING" and "DemoOutput RUNNING" are printed to the browser's console on every click even though the value to the show prop does not change. Why is this?
         - We can understand "APP RUNNING" will continue to be printed on every button click because the 'showParagraph' state changed in that Component causing a re-evaluation.
         - The props in the DemoOutput did not change (i.e. it is always false) but it was re-rendered which is interesting. Why was the DemoOutput re-evaluated?
            - The App Component function is re-executed because the state changed. Part of the App function is the return statement which returns JSX code.
            - All the JSX code within the return statement are like function calls to the respective Component functions. Therefore, we cal the function for the <DemoOutput/> and <Button/> Child Components.
            - Hence, this is the reason for why the Child Components are also re-executed and re-evaluated just because the Parent Component has changed. The Child Component are part of the Parent Component function body.
            - If the Parent Component function re-runs again, so does all the Child Components re-run again.
            - The prop value does not matter for the Component to be executed again. It is just the fact that the Parent Component changed. Changes in props might lead to actual changes to the real DOM but for the Child Component function to be re-evaluated, it is enough for the Parent Component function was re-evaluated.
            - The fact that the DemoOutput Component function runs again does not mean that the real DOM is touched. This is verified by the Elements tab whereby the <p> element does not flash or change.
            - React re-evaluating a Component and re-running its Component function is not the same as re-rendering/manipulating the real DOM.
            - You should also notice that the <Button/> Component will also re-run when the Parent App Component function is re-executed (and can see this if you add the console.log('Button RUNNING') within that function).
      > This should bring up an important question: If the Child Components were to have their own Child Components, would they be re-evaluated? The answer would be yes. This can be seen if the above code was updated to the below example:

         DemoOutput (Child Component):
            import MyParagraph from './MyParagraph';
            const DemoOutput = (props) => {
               console.log('DemoOutput RUNNING');
               return(
                  <MyParagraph>{props.show ? 'This paragraph is new!' : ''}</MyParagraph>
               );
            };

         MyParagraph (DemoOutput Child's Child) Component:
            const MyParagraph = (props) => {
               console.log('MyParagraph RUNNING');
               return(
                  <p>{props.children}</p>
               );
            };

   > You should also see "MyParagraph RUNNING" in the console to demonstrate that the Child's Children Components will also re-execute for every "Toggle Paragraph" button click.
   > Therefore the re-execution of Child Component will continue down the Component tree. This now brings up the next question of: is this bad because that leads to a lot of ongoing function executions and virtual comparisons that would certainly cost some performance?
   > This will be bad because in the above example, there is no actual real reason for re-evaluating the <DemoOutput/> Component because it can never change (i.e. the only prop it has has a hard coded value and the same will be true if it had no props at all being passed down from the Parent Component). Therefore, re-executing <DemoOutput/> Component and all of it's child Components down the Component Tree will be a waste.

------------------------------------------------------------------------------------
4. Preventing Unnecessary Re-Evaluations with React.memo():
------------------------------------------------------------------------------------
   > Ongoing function executions and virtual comparisons does cost some performance. It is needless to say that React is highly optimised for those executions and comparisons. So in a lot of React Apps including simple apps like the previous example, the re-evaluation will not matter.
   > Nonetheless, in larger apps you may wish to optimise it. Therefore, you as the developer can tell React that it should only re-execute a Child Component (e.g. the DemoOutput Child Component) under certain circumstances e.g. the props for that Component changed.
   > How would you tell React that it should behave like this?
      - You would need to go into the Component that you want to opt into the example "did the prop change check".
      - Wrap the Component in the export line with React.memo() method.
      - Important Note: The React.memo() wrapper method will only work with React Functional Components (and does not work for Class-Based Components).

   Preventing Unnecessary Re-Evaluation with React.memo() Wrapper Method Example:
      DemoOutput (Child Component):
         import MyParagraph from './MyParagraph';
         const DemoOutput = (props) => {
            console.log('DemoOutput RUNNING');
            return(
               <MyParagraph>{props.show ? 'This paragraph is new!' : ''}</MyParagraph>
            );
         };
         export default React.memo(DemoOutput);

   Analysing the React.memo() method in Action:
      > The .memo() method tells React that for the Component that it receives as an argument/parameter, React should look at the props that this Component receives and check the new value for all those props and compare it with the previous values those props got. Only when the value of a prop changed the Component should be re-executed and re-evaluated.
      > Therefore, if the Parent Component changed but the prop values for the specified Component (i.e. <DemoOutput/>) did not change, then the Component execution will be skipped for that specified Component (and so will all of it's children down the Component Tree will be skipped).
      > This can be seen in the console (after the initial Component Function execution) that the "DemoOutput RUNNING" and "MyParagraph RUNNING" will no longer be printed to the browser console on the "Toggle Paragraph" button clicks.
      > This optimisation avoids unnecessary re-rendering. This would lead to the next question: why are we not using this optimisation on all components if it allows us to optimise them?
         - The reason is because this optimisation comes at a cost. The .memo() method in the above example tells React that whenever the App Component has changed, it should go to the specified Component (e.g. <DemoOutput/>) and compare the new prop values to the previous prop values.
         - Therefore, React will need to do two things: store the previous prop values and make that comparisons. This in itself has its own performance cost.
         - Hence, it greatly depends on whether or not it is worth optimising the Component you are applying the .memo() optimisation to. This is because you are trading the performance cost of re-evaluating the Component for the performance cost of comparing props.
         - It is impossible to say which cost is higher because this will depend on the number of props you have and the complexity of your Component and the number of Child Components the Component has.
         - The React.memo() can be a great optimisation tool if you have a huge Component tree with a lot of Child Components and the Component in question is on a high level within the Component tree can help avoid unnecessary re-render cycles for the entire branch of the Component tree.
         - If on the other hand you have a Component where you know it is going to change or its props values are going to change with pretty much every re-evaluation of the Parent Component anyway, then the React.memo() will not make sense in such scenario i.e. if the result is that the Component should re-render anyway then you can save that extra comparison of the props values overhead.
         - Ultimately, it depends on the App size i.e. for small applications/Component trees it is not worth to add the optimisation. On the other hand, for larger applications, where you can cut off entire branches of unnecessary re-evaluations then it might be well worth the optimisation.
         - To conclude, you do not want to wrap every Component with React.memo() optimisation but rather pick key Components within the Component tree which allows you to cut off an entire branch of Child Components which is way more effective than applying it on every Child Component.

      > Now lets apply the .memo() optimisation to the Button Component (e.g. 'export default React.memo(Button);'). You will notice something rather strange.
      > When you click the "Toggle Paragraph" button the "Button RUNNING" continues to print to the browser's console indicating the re-evaluation. Why is this?
         - The reason you would continue to see the <Button/> Component re-evaluating is because its' props values did actually change.
         - In the Parent App Component, the <Button/> Child Component receives an "onClick" prop which is set to the "toggleParagraphHandler" pointer function and a children prop (the contents between the Opening and closing <Button></Button> tags i.e. the text "Toggle Paragraph") which never change.
         - This is a common gotcha with React. Keep in mind the App Component is a function in the end and it re-executes like a normal JavaScript function because it is a normal JavaScript function. The only magic is that the function is going to be called by React and not by you, but then it executes like a normal function. Therefore all the code gets executed again.
         - This has one important implication, the 'toggleParagraphHandler' function which is passed to the <Button/> Component on the "onClick" prop is recreated. Therefore, the "toggleParagraphHandler" is a brand new function for every execution cycle of the App function.
         - Thus, the function is not the same one passed all the time but it is a new function that does the same thing as the previous function. Technically to JavaScript the function is a brand new function for everytime the App function is being executed.
         - This logic is also true for the "{false}" value being passed to the <DemoOutput/> Components "show" prop. Previously, we said the {false} value never changes but that technically was not correct. When the App Component is re-executed a new "false" value is created. This leads to the question: should <DemoOutput/> Component also be re-evaluated regardless of the .memo() optimisation?
         - You need to keep in mind that false is a boolean value. Boolean like other data types such as strings and numbers are primitive values in JavaScript. With primitive values if you compare for example two Booleans you will get true or false whether or not they evaluate to be the same (e.g. false === false evaluates to true and 'hi' ==== 'hi' evaluates to true i.e. the values are the same).
         - When comparing reference data types such as arrays, object or functions the evaluation would result to false. While the data type would look the same to a human, to JavaScript they are not the same (e.g. [1,2,3] === [1,2,3] will evaluate to false).
         - For more information on reference vs primitive values refer to https://academind.com/tutorials/reference-vs-primitive-values/ - this is a core concept in JavaScript that you should understand.
         - Functions are just objects in JavaScript. Two object, even if they have the same content are never equal with compared to each other in JavaScript.
         - Therefore, the .memo() method when it compares reference type prop values, it will always evaluate to false and will consider the prop value has changed and re-evaluates the Component. 
         - Understanding this information is crucial and to get right when using the .memo() optimisation.
      > The next question: Does this mean that React.memo() is useless for Components that receive reference type values through their props? The short answer is no.

------------------------------------------------------------------------------------
5. Preventing Function Re-Creation with useCallback() Hook:
------------------------------------------------------------------------------------
   > To make React.memo() optimisation to work with prop values that are objects (i.e. reference values) requires us to tweak the way we create and store those objects.
   > React provides the useCallback() Hook. This Hook allows us to store a function across Component executions i.e. tell React to save a function and that this function should not be recreated with every execution. Therefore, one and the same function is stored in the same place in memory.
   > This tweak allows the .method() to evaluate to true because the prop will point to the same function in memory and therefore the previous and new prop would be the same and the prop would not be considered to have changed.

   Preventing Function Re-Creation with useCallback() Example:
      import React, { useState, useCallback } from 'react';
      ...
      function App() {
         ...
         const toggleParagraphHandler = useCallback(() => {
            setShowParagraph((prevShowParagraph) => !prevShowParagraph);
         }, []);
         return (...);
      };

   Analysing the .useCallback() Hook in Action:
      > We know that in JavaScript obj = {} and object obj2 = {} will evaluate to false because obj1 === obj2 is false. However, if obj2 = obj1 i.e. it points to the same object in memory then obj1 === obj2 will evaluate to true.
      > This is what the useCallback() Hook allows us to do. It will save the function of our choice somewhere in Reacts' internal storage and always re-use that same function object when the Component function re-executes.
      > To use the .useCallback() Hook you would need to import it from the React library. Then wrap the function you want to save with the useCallback() Hook.
         - The .useCallback() Hook takes a function as its first argument/parameter.
         - In the example this is the function form (i.e. anonymous function) that calls the setShowParagraph function to toggle this state.
      > Whenever the App Component function re-runs, React will look for that function that it stored for us and re-use that same function object.
      > Thus, if you know that a function should never change then you should use the .useCallback() Hook to store the function.
      > The .useCallback() Hook requires a array of dependencies (similar to the useEffect Hook). The dependencies are the same as they are for the .useEffect() Hook i.e. anything you use in the function which is coming from the surrounding Component (i.e. any 'State', 'Prop' or 'Context') should be specified here.
         - In the above this is the "setShowParagraph" State. However, as an exception to this rule, you do not need to reference the State function because (with the help of .useCallback() React guarantees that the State function will never change and will be the same function object).
         - Note that the '(prevShowParagraph) => !prevShowParagraph' line is a function that is passed to the setShowParagraph function as an argument and does not need to be referenced as a dependency because the function is totally contained inside of the .useCallback() Hook function.
         - The above code tells React that the callback function which will be stored in "toggleParagraphHandler" will never change and has no dependencies and therefore always re-use the same function object whenever the App Component re-renders.
      > The "Button RUNNING" will print to the browser's console when the <Button/> Component initialises for the first time but thereafter when you now click on the "Toggle Paragraph" button the "Button RUNNING" message will no longer appear because the React.memo() optimisation will now be able to do its job i.e. cut off any unnecessary re-evaluations on that Child Component tree branch if no props for the specified Component has not changed. This is because the "toggleParagraphHandler" is guaranteed to be the same function object in memory because of the .useCallback() Hook.

------------------------------------------------------------------------------------
6. The useCallback() Hook and its Dependencies:
------------------------------------------------------------------------------------
   > The useCallback allows you to save a function so that you can reuse it.
   > You have to specify the dependencies array. initially you might think why would you need this for? The function always has the same logic across re-render cycles.
   > Keep in mind that in JavaScript, functions are closures. This means that functions close over the values that are available in their environment. You can learn more about closures on the following web resource link:
   https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures
   > You would need to fully understand how closures work in order to understand how React works. Below is an example code:

   Function Closure Example:
      ...
      function App() {
         const [showParagraph, setShowParagraph] = useState(false);
         const [allowToggle, setAllowToggle] = useState(false);
         console.log('APP RUNNING');
         const toggleParagraphHandler = useCallback(() => {
            if(allowToggle) {
               setShowParagraph((prevShowParagraph) => !prevShowParagraph);
            };
         }, []);
         const allowToggleHandler = () => {
            setAllowToggle(true);
         };
         return (
            <div className="app">
               <h1>Hello World!</h1>
               <DemoOutput show={showParagraph} />
               <Button onClick={allowToggleHandler}>Allow Toggling</Button>
               <Button onClick={toggleParagraphHandler}>Toggle Paragraph</Button>
            </div>
         );
      };

   Analysing the .useCallback() Hook and its Dependencies in Action:
      > In this example, we have a second button called "Allow Toggling". This buttons onClick is set to the allowToggleHandler function which will set the "allowToggle" state from false to true which should then allow the "Toggle Paragraph" button to start working and toggle the "showParagraph" (in theory).
      > You will notice when you run the App for the first time, clicking the "Toggle Paragraph" button does nothing. If you click the "Allow Toggling" button, the "Toggle Paragraph" button should start to do something; however, it continues to do nothing.
      > The reason for this unexpected behaviour is because functions are closures within JavaScript and also due to the fact that the above is not using .useCallback() properly (in your IDE you will notice a yellow squiggly line for the dependencies array).
      > When a function is defined, which happens when the App Component function runs, JavaScript locks in all the variables that are defined outside of the function that are being used within the function. In the above example this is the "allowToggle" variable which is coming from outside the "toggleParagraphHandler" function. JavaScript closes over that const variable and stores that const variable for the function definition.
      > Therefore, this means that when the next time the "toggleParagraphHandler" function is executed, the stored "allowToggle" variable within this function will be used. Therefore, the value of that variable would be the value at the time it was stored.
      > This generally is perfect because it allows you to use variables from outside the function within the function and call that function at any point you want (which is what you would want for a function that you bind to a button). However, the problem with this and the .useCallback() Hook is that by using the .useCallback() Hook you are telling React to store that exact function somewhere in memory.
      > When the App function is re-evaluated and re-executed, React will not recreate the function because you told it not to at all circumstances using the .useCallback() Hook. Therefore, the "allowToggle" value is still the old value from the first time the Component was executed and not the most recent one.
      > This is a problem because there are cases where you would actually want to recreate the function because the values being used in that function that are coming from outside the function might have changed. Therefore, you would add "allowToggle" as a dependency within the useCallback() Hook's dependencies array.
      > The dependencies array tells React that we generally want to store the function but whenever the value of a dependency changes and has a new value, we want to recreate that function and store the new re-created function. This ensures that we always used the latest variable value inside of the stored function (in the above example this would be the "allowToggle" dependency variable).

         const toggleParagraphHandler = useCallback(() => {
            if(allowToggle) {
               setShowParagraph((prevShowParagraph) => !prevShowParagraph);
            };
         }, [allowToggle]);

      > The .useCallback() Hook will only recreate and store the new re-created function if the dependency changed on the re-execution of the App Component function. This will now fix the issue and the "Toggle Paragraph" button will start to work after you clicked the "Allow Toggling" button to change the "allowToggle" state from false to true.
      > This concept may seem confusing but this concept of closures has nothing to do with React but more to do with JavaScript. Therefore, you should make sure to understand JavaScript concepts of closures and primitive reference values. Once you understand these concepts then React would become very clear since it is all JavaScript code at the end of the day.

------------------------------------------------------------------------------------
7. A Closer Look at State and Components:
------------------------------------------------------------------------------------
   > Before we look at State and Component, a quick summary of what we have learnt thus far.
   > In React Apps you work with Components typically with function Component in modern React. Those Components have one job which is to return JSX Code. This tells React what the output of that Component should be.
   > In your React Components, you can work with 'State', 'Props' or 'Context' (although with 'props' and 'context' all come down to State changes at the end of the day) to make changes to a Component i.e. to its data which affects the Component itself or affects parts of your application.
   > Whenever you change the state in a Component, that Component where the state changed is re-evaluated which simply means that Component function is executed again. When the code runs again the JSX code output could either be exactly the same output as before or something different. React takes the result of the latest evaluation and compares it to the previous evaluation's results. It does this for all affected Components.
   > Any changes detected is handed off to ReactDOM (because ReactDOM.render() is being used to render the React App). ReactDOM will take only those changes and apply them to the real DOM in the browser.
   > When React Re-evaluates a Component, it does not do this for just that Component. Since the JSX is also rerun within the Component function it will therefore also rerun all other Components that are within the JSX code.
   > To avoid unnecessary re-executions of Child Components, React provides a .memo() method to tell React to only re-evaluates a Child Component if its props has actually changed.
   > Re-evaluating a Component can have a strange effect if you are not aware of the fact that re-evaluation means that everything in the function runs again. Therefore, function created inside of the function Component and pass those functions through props to other Components, you will get a new function object which React.memo() method will not be able to help.
   > Functions are objects in JavaScript which are a reference data type values. Comparing two reference values using the equality operator (===) will not work, which is what the React.memo() method uses under the hood. This is not a problem for primitive values.
   > This is where the .useCallback() Hook comes in and can help this situation because the .useCallback() Hook tells React to store a function and not recreate it when the surrounding function reruns again as long as certain dependencies did not change.
   > Now there are still a couple of open questions left, for instance: If the Component function runs again whenever the 'State' changes does this not mean that the state is reinitialised all the time because it is executed with "useState()" over and over again. Why does this not cause any problems in React?.

   A .useState() Hook Example:
      function App() {
         const [showParagraph, setShowParagraph] = useState(false);
         const [allowToggle, setAllowToggle] = useState(false);
         ...
         return (...);
      };

   Analysing the useState() Hook in Action:
      > State is a crucial concept in React. Ultimately, everything comes down to 'State' when it comes to re-rendering Components and changing what is rendered on the screen.
      > Therefore, Components and their interaction with 'State' is a core aspect of React. It is worth noting that both (Components and 'State') are managed by React. The Components concept comes from the React library and React also takes care of your 'State' that is attached to the Components by using useState() Hook (which is how the interaction between Component and 'State' are handled).
      > One of the most common forms of managing state is to use the useState() Hook. This allows you to create a new piece of state which is automatically attached to the Component you called the useState() Hook. This attachment is done behind the scenes by React i.e. it creates a new state variable which it manages and ties it to the Component for you.
      > Even though the useState() Hook is called everytime the App Component function runs again, we do not seem to lose or reinitialise the state all the time. The reason for this is simple, this is because it the useState() comes from React which React manages the state and connection for you. As part of the management process, React ensures the useState() and value(s) you pass as a default value essentially is only considered once.
      > The first time a Component is rendered the useState() Hook when executed will create a new state variable which is handed off and managed by React. React then memorises to which Component the state variable belongs and uses the default value to initialise the state with that passed in argument/parameter value.
      > For subsequent App Component function calls (i.e. re-evaluation of the App Component function), when the useState() Hook is being called again, no new state is being created. Instead, React recognises that it already has a state for the Component and instead simply updates that state as needed. 
         - It will never re-initialise the state unless the Component was totally removed from the DOM (in the case of the App Component, this will never occur since it is our root Component).
         - For Child Components being rendered conditionally the Component might be removed and in that case if the Component is later re-attached to the DOM then a new state would be initialised.
         - As long as a Component stays attached to the DOM, state is only updated after that first initialisation.
      > The same also applies for the useReducer() Hook.

------------------------------------------------------------------------------------
8. Understanding State Scheduling & Batching:
------------------------------------------------------------------------------------
   > Calling the State updating functions provided by the useState() Hook schedules a State update with the data passed in. It is important to note that this is a scheduled state change and not an instantaneous one.
   > React is aware of the the state change and plans on processing the change but it is not done so immediately.
   > In reality scheduled state changes will be processed very fast/instantly. Therefore, in reality the state change may feel instant.
   > React reserves the right of actually postponing the state change for example because a lot of other performance intensive tasks are going on at the same moment (potentially tasks that React considers to have a higher priority). For example, if you have an input field where users are able to type something, reacting to that user input would have a higher priority than changing some text on the screen.
   > For reasons as mentioned, React might postpone scheduled state changes.

   State Scheduling Diagram Example:
   [Application Code]                                    [React]
   [<MyProduct/>] [setNewProduct('Book')]                [Current State: 'DVD']
                           |
      [Schedules a State Update with data 'Book']------->[Scheduled State Change]      Multiple updates can be scheduled
      [Schedules a State Update with data 'Carpet']----->[Scheduled State Change]      at the same time!
   [<MyProduct/>]<--------re-evaluate/re-execute---------[New State: 'Book']
   [<MyProduct/>]<--------re-evaluate/re-execute---------[New State: 'Carpet']

   > React guarantees the order of state changes for one in the same type of state is guaranteed.
   > For example, if you used setNewProduct('Book') and then setNewProduct('Carpet'), etc. the state change would perform the functions the order it was requested i.e. 'Book' before 'Carpet' (preserving the order). However, the execution of the state functions are not necessarily executed immediately.
   > Once the state change has been processed, React will re-evaluate the Component function.
   > Because of this scheduling, where you can have multiple outstanding scheduled state changes at the same time, it is recommended to use the function form for updating your state if you depend on the previous state snapshot.

   Analysing the State Scheduling in Action:
      > Both example below demonstrate how to use the function form for the state changes; however, the second example uses the useCallback() Hook to ensure the outside dependencies changes can be taken into account on the Component function re-evaluation/re-execution.

      Function Form State Changes Example:
         const toggleParagraphHandler = () => { 
            setShowParagraph((prevShowParagraph) => !prevShowParagraph)
         };

         const toggleParagraphHandler = useCallback(() => {
            if(allowToggle) {
               setShowParagraph((prevShowParagraph) => !prevShowParagraph);
            };
         }, [allowToggle]);

      > In a lot of cases this will probably not matter because it is processed so quickly that you cannot even click fast enough to see a delay. However, because it theoretically can be postponed, the function form is a safe way of ensuring that state changes are processed in order and for every state change where you depend on the previous state you will get the latest state.
      > Without using function form you may get the latest state when the Component function was executed last which is not necessarily the same state as if the state changes are executed in order.
      > This is an important difference between when the Component was re-rendered and when a state change was scheduled.
      > You can have multiple outstanding state changes from one and the same Component re-evaluation and should be the key takeaway here and why using the function form matters.
      > The above example, we want a state update that depends on the same state but just a previous snapshot of that state.

      Function Form State Changes in useEffect Hook Example:
         useEffect(() => {
            const identifier = setTimeout(() => {
               console.log('Checking Form Validity');
               setFormIsValid(emailIsValid && passwordIsValid);
            }, 500)
            return () => {
               console.log('CLEANUP');
               clearTimeout(identifier);
            };
         }, [emailIsValid, passwordIsValid])

      > In this example, it was safe to actually update the form validity based on the emailIsValid and passwordIsValid states inside of the useEffect() Hook. This is because just like using the function form for updating a state based on a previous snapshot, the useEffect() Hook dependencies mechanism ensures to rerun the side effect every time a state or a value which is a dependency changed.
      > Therefore, you cannot miss outstanding state changes because it will simply rerun the effect for every time the Component was re-executed. Hence, you are always guaranteed to get the latest state when using the above example pattern.
      > It can be said that these are simply two different patterns for dealing with one and the same problem depending on what you are trying to achieve. In the useEffect() Hook pattern example, we want state updates that depend on some other state while in the "toggleParagraphHandler" example(s) we want a state update that depends on the same state but just the previous snapshot of that state.
      > The State Scheduling mechanism is something you must keep in mind not because you actively need to do something about that (React manages those scheduled updates for you) but because you need to write your code accordingly to rule out any danger of potentially working with outdated data. This is mitigated by using the function form or useEffect pattern.

      > There is another important thing you need to know about State in React. If you call two state updating functions one after other, you have just learned that just because you call such a function does not mean that it the very next line the state was updated. Instead, the update will be scheduled and eventually the entire Component will rerun and once the Component does rerun you will then have the latest state and not earlier.
      > Take the below code as an example:

         const navigateHandler = (navPath) => {
            setCurrentNavPath(navPath);
            setDrawerIsOpen(false);
         };

      > In this example, there are two state updates which means that two state changes will be scheduled. Does this mean that the Component will be re-executed/re-evaluated twice? The answer is no.
      > Where you have two state updates in the same synchronous code snippet after each other (e.g. within the same function and not for example in a promise within different .then() blocks, where nothing will cause a time delay), in such cases, React will batch those state updates together in one long synchronous process.
      > React takes all the state updates produced by that function and will batch them together into one state update. This will therefore be one scheduled state update that changes two different states within one process. Therefore, the Component will only re-evaluate/re-execute once in such circumstances.
      > State Batching is another important concept you have to be aware of when working with React.

------------------------------------------------------------------------------------
9. Optimising with the useMemo() Hook:
------------------------------------------------------------------------------------
   > Sometimes in your Component's logic you might have logic that are more performance intensive (i.e. code that might take some time to resolve). Eventually the code will need to execute but you certainly do not want to run the code again everytime the Component function re-evaluated/re-executed.
   > We learnt that to avoid any unnecessary re-evaluations, you can use React.memo() method. Take the below example:

   App (Parent) Component:
      import React, { useState, useCallback } from 'react';
      import DemoList from './components/Demo/DemoList';
      import Button from './components/UI/Button/Button';
      function App() {
         const [listTitle, setListTitle] = useState('My List');
         const changeTitleHandler = useCallback(() => {
            setListTitle('New Title');
         }, []);
         return (
            <div className="app">
               <DemoList title={listTitle} items={[5,3,1,10,9]} />
               <Button onClick={changeTitleHandler}>Change List Title</Button>
            </div>
         );
      };

   DemoList (Child) Component:
      import React from 'react';
      const DemoList = (props) => {
         const { items } = props;
         const sortedList = return props.items.sort((a, b) => a - b);
         console.log('DemoList RUNNING');
         return (
            <div className={classes.list}>
               <h2>{props.title}</h2>
               <ul>
                  {sortedList.map((item) => (
                     <li key={item}>{item}</li>
                  ))}
               </ul>
            </div>
         );
      };
      export default React.memo(DemoList);

   > The DemoList component sorts a unordered list of numbers into an order list. While the list of numbers is small, this task cause become more process intensive with a larger unordered list. Therefore, logic such as this would not want to be re-run on the Component function re-evaluation.
   > The React.memo() method wraps around the DemoList Component export which will prevent any unnecessary re-evaluation.
   > We can see that this Component will not re-run unnecessarily with the 'console.log('DemoList RUNNING');' line of code for demonstration. You will notice that when you click the button to change the title the Component would rerun again because the prop.title value (one of its props) has changed. Therefore, the React.memo() method is not failing in this scenario because the Component would need to re-run in this case.
   > As a side note, the <DemoList/> Component will also always rerun when the Parent Component re-renders because the array of "items" (i.e. items={[5,3,1,10,9]}) is re-created in the Parent Component whenever the Parent App Component reruns. Therefore, even if the title did not change and the Parent App Component was to rerun for some other reasons, the <DemoList/> Component will be re-executed because we are always generating a new items array.
   > Like functions, arrays are Objects within JavaScript which are of Reference Value Types. Two arrays, even if they both contains exactly the same elements and order, will always evaluate as not being the same. This is because reference values occupy two different places in memory.
   > Sometimes, the component has a valid reason to re-evaluate and rebuild the Component, however, you might not want to repeat every piece of work/logic within the Component function that was done in the past especially if the work/logic you would have to redo is more performance intensive. Sorting is one of the more performance intensive tasks you can do in your Components.
   > The useCallback() Hook is used to store function objects and only re-build them when some input changed. There is something similar for all other kinds of data called the useMemo() Hook.

   App (Parent) Component:
      import React, { useState, useCallback, useMemo } from 'react';
      ...
      function App() {
         ...
         const listItems = useMemo(() => [5, 3, 1, 10, 9], []);
         return (
            <div className="app">
               <DemoList title={listTitle} items={listItems} />
               <Button onClick={changeTitleHandler}>Change List Title</Button>
            </div>
         );
      };

   DemoList (Child) Component:
      import React, { useMemo } from 'react';
      const DemoList = (props) => {
         const { items } = props;
         const sortedList = useMemo(() => {
            console.log('Items sorted');
            return items.sort((a, b) => a - b);
         }, [items]); 
         console.log('DemoList RUNNING');
         return (...);
      };
      export default React.memo(DemoList);

   Analysing the useMemo() Hook in Action:
      > The useMemo() Hook needs to be imported from the React library.
      > The useMemo() Hook allows you to memorise (i.e. to store) any kind of data which you want to store, similar to how useCallback() Hook does for functions.
      > In the example above we use the useMemo() Hook to memoise the result of the sorting. The useMemo() Hook wants a function as its first argument/parameter. That function will not be memorised, instead it should return what you would want to store i.e. memoise (note that memoise and memorise are two different terms but mean similar things in this context).
      > The useMemo() Hook also wants a second argument which is an array of dependencies (similar to the useCallback() Hook). This will ensure the stored value is updated whenever one of the value used in useMemo() Hook changes. Therefore, whenever the item array changes we would want to resort them and store that new sorted value.
      > Instead of using props as a dependencies which will mean the entire props object will become the dependency and would essentially always re-calculate; a more elegant way is to destructuring to pull something out of the props object. In the above example this was to pull out the "items" array that is passed down through the props object.
      > The "sortedList" will only be re-built if the items array passed down from the Parent Component actually changed.
      > To ensure that we do not unnecessarily pass in a new array, we can also use the useMemo in the Parent App Component. This allows us to wrap the array with useMemo() Hook and pass an empty dependencies array as the second argument/parameter (e.g. 'useMemo(() => [5, 3, 1, 10, 9], [])'). In the above example, this is pulled out into its own variable called listItems which is then passed as a value to the "items" prop.
      > You should now notice that the application no longer unnecessarily sorts the list again if the list values did not change - this can be seen in the browser's console whereby "Items sorted" is printed for the first initialisation but never again even if we were to click the Change List Title button. Note: that the <DemoList/> Component will (and should) rerun because the title prop changed.

   > The useMemo() Hook is used far less often compared to the useCallback() Hook. This is because memorising functions is much more useful and needed more often than memorising data. You essentially want to memorise data if it would be performance intensive to re-calculate something based on it, otherwise it might not really be worth it.
   > You need to keep in mind that if you store data with useMemo() it occupies some memory and also the stored function takes up some performance. Therefore, this is not something you want to use in every value you are using.
   > However, if you have a scenario like the above (i.e. where you want to sort something) then it might be useful to take a look at using the useMemo() Hook because it will avoid unnecessary logic steps (such as sorting) in future Component updates.
   > There is no clear right or wrong, but with experience you will know when to use what in different scenarios and circumstances.
   > Being aware of all these optimisation tricks will help you to resolve issued whereby the application is either slow or you want to improve some parts of the application for better user experience.