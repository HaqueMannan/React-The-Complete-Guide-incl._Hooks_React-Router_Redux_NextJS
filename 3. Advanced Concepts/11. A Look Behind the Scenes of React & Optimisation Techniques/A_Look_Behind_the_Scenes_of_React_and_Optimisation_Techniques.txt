A Look Behind the Scenes of React & Optimisation Techniques - Summary:
1. How React Really Works
2. A Close Look at Component Updates in Action
3. A Closer Look at Child Component Re-Evaluation
4. Preventing Unnecessary Re-Evaluations with React.memo()

------------------------------------------------------------------------------------
1. How React Really Works:
------------------------------------------------------------------------------------
   > React is a JavaScript library for building user interfaces.
   > React is all about building Components (i.e. it embraces this concept of Components).
   > ReactDOM is the interface to the web.
   > ReactJS (i.e. React) itself does not know nothing about the web. It only knows how to work with Components. It does not care whether those Components contains HTML elements or totally fictional elements.
   > ReactDOM at the end cares about HTML elements and bringing in real HTML elements to the screen.
   > React is a library that manages Components, Props, Context, State, and different Component States. React hands over all the information regarding what changed and what should be visible on the screen off to the interface it is working with i.e. ReactDOM. ReactDOM is then responsible for working with the real DOM (which is part of the browser) and therefore ReactDOM is actually responsible for what is rendered to the real DOM and what the user actually sees on their screen.
   > 'Props' are Data from Parent Component, 'State' is the internal data inside of a Component and 'Context' is the Component-wide data.
   > Whenever 'props', 'state' or 'context' changes the Components that use these concepts are updated by React and React checks whether the Component wants to draw something new onto the screen and if that should be the case then React will let ReactDOM know about that so that it can bring that new render/output to the screen.
   > The question is how does the Components to Real DOM communication actually work?
   > React uses a concept called the 'Virtual DOM'. React determines how the current Component tree (which the app is building in the end and every Component itself has a sub tree that the JSX code returned by that Component) looks like and what it should look like for example, after a state update. That informaton is handed off to ReactDOM which now knows about the differences and which then knows how it should manipulate the real DOM to match that virtual DOM.
   > There is one important thing to note: whenever a 'prop', 'state' or 'context' of a Component changes, that Component function is re-executed (i.e. that Component is re-evaluated by React). However, re-evaluating a Component is not the same as re-rendering the DOM. Therefore, just because a Component function is re-executed by React does not mean that the respective part of the actual real DOM is re-rendered or re-evaluated.
   > We have to differentiate between our Component/React part and the real DOM.
   > The real DOM is only updated in the places where it needs to be changed based on that difference React derived between the previous state of a Component and its tree and the current state after the prop/state/context change.
   > Therefore, the real DOM is not changed all the time and it is changed rarely and only when need (i.e. only made for differences in evaluation). This is important for performance because making a virtual comparison between the previous state and the current state is cheap and easy to do because it only occurs in memory. Reaching out to the real DOM that is rendered to the Browser is expensive from a performance perspective (i.e. working with the real DOM is a performance intensive task).
   > If you make tiny changes in a lot of places all the time then the page might become slow because you end up working with the real DOM too much. This is the reason for why React has this structure of doing virtual comparisons with the virtual DOM and then only passing the changes between the last and current snapshot to the real DOM.
   > This is how React works ie. by doing this 'Virtual DOM Diffing' - finding the differences between two snapshots. Below is an Example:

   Virtual DOM Diffing Illustration Example:
      Previous Evaluation Result:            Current Evaluation Result:
         <div>                               <div>
            <h1>Hello World!</h1>               <h1>Hello World!</h1>
         </div>                                 <p>This paragraph is new!</p>
                                             </div>

   > React will determine the difference between both snapshots is the paragraph element.
   > React will report this change to ReactDOM (i.e. the '<p>This paragraph is new!</p>' should be inserted to the DOM and the rest should stay unchanged).
   > ReactDOM will update the real DOM and insert this paragraph element. It will not re-render the whole entire DOM i.e. it will not touch the existing <div/> and <h1/> elements but instead insert the <p/> element after the <h1/> element inside of the <div/> element.
   > This is how React works behind the scenes in a nutshell.
   > It is very crucial that you understand how all of this behind the scenes actually behaves to extend your knowledge about how React works with ReactDOM which will make you a better developer and help you to identify and resolve bugs within a React project code much faster and easily.

------------------------------------------------------------------------------------
2. A Close Look at Component Updates in Action:
------------------------------------------------------------------------------------
   > To illustrate and view the Component Update in action we will use the below code as a demonstration to render a new paragraph to a Component.
   > React will only re-run the Component function and re-evaluate what is on the screen if the 'props', 'state' or 'context' changes.
   > Remember: Ultimately, it all comes down to 'State' changes. Even context internally will use some state that might change the value which is then distributed through context. If we also think about props being passed from a parent to a child, how could the value passed through 'props' change? Again, only if 'state' in a parent changed. Hence, it all comes down to 'State' changes in the end if you think about it.

   Component Update Example:
      import React, { useState } from 'react';
      import Button from './components/UI/Button/Button';
      function App() {
         const [showParagraph, setShowParagraph] = useState(false);
         const toggleParagraphHandler = () => {
            setShowParagraph((prevShowParagraph) => !prevShowParagraph);
         };
         return (
            <div className="app">
               <h1>Hello World!</h1>
               {showParagraph && <p>This paragraph is new!</p>}
               <Button onClick={toggleParagraphHandler}>Toggle Paragraph</Button>
            </div>
         );
      };

   > The toggleParagraphHandler function could have been written shorter using 'setShowParagraph(!showParagraph);' syntax (i.e. set the showParagraph value to be the opposite of the old value). However, since you rely on the previous State snapshot you would want to use the function form for the state update. We will revisit and explain why you would do this in a later section. But note that the above example is the cleaner way for updating state that relies on the previous state snapshot.
   > The Component has the logic to conditionally show a paragraph when you click the button.

   Analysing the Component Updates in Action:
      > If you add a 'console.log('APP RUNNING');' code before the 'const toggleParagraphHandler = () => {...}' line, you should see "APP RUNNING" in the browser's console whenever you click the button. This should demonstrate that the Component function is re-evaluated whenever there is a 'prop', 'state' or 'context' change within a Component.
      > Therefore, when the application runs for the first time and runs the Component function for the first time you should see the "APP RUNNING" within the browser's console.
      > On the first execution (render cycle) React found out that it wants a <div>, <h1> and a <Button> (actual HTML will be <button>) element and no <p> element because it is not shown. It checks this with the last output it saved. Since this rendered the Component for the first time, there is essentially no previous output/snapshot and therefore the difference comparison in the end resulted in the <div>, <h1> and <button> to be rendered. This information is sent off to ReactDOM library which renders real HTML elements to the actual DOM (i.e. to the browser screen).
      > If you click on the the "Toggle Paragraph" button you should see "APP RUNNING" printed again in the browser's console. This proves the point that for every 'State' change, the entire Component in which the state changed is re-executed and re-evaluated.
      > How is the real DOM affected? If you go to the "Elements" tab within the browser's developer tools and expand the "<div class="app">" element you will notice that things that are changed within the real DOM will be flashed on screen in the "Elements" developer tool which shows where the real DOM was re-rendered or updated.
      > You will notice when you click the "Toggle Paragraph" button to add the paragraph, only the <p> element would flash and nothing else. If you click the "Toggle Paragraph" button again to remove the paragraph then only the parent "<div class="app">" element will flash because the <p> element was removed from that parent element. The <h1> and <button> elements will not flash again because they are  not re-rendered again by the real DOM.
      > This should visually demonstrate that only the differences between those virtual snapshots was considered for the updates made to the real DOM. This is really crucial to understand. 

------------------------------------------------------------------------------------
3. A Closer Look at Child Component Re-Evaluation:
------------------------------------------------------------------------------------
   > The below example code will provide a closer look at how a Child Component Re-Evaluates in React.
   > To demonstrate this, the Child Component will receive a prop from the Parent Component to conditionally render the text within the paragraph.

   Child Component Re-Evaluation Example:
      App (Parent) Component:
         import React, { useState } from 'react';
         import Button from './components/UI/Button/Button';
         import DemoOutput from './components/Demo/DemoOutput';
         function App() {
            const [showParagraph, setShowParagraph] = useState(false);
            const toggleParagraphHandler = () => { setShowParagraph((prevShowParagraph) => !prevShowParagraph)};
            return (
               <div className="app">
                  <h1>Hello World!</h1>
                  <DemoOutput show={false} />
                  <Button onClick={toggleParagraphHandler}>Toggle Paragraph</Button>
               </div>
            );
         };

      Button (Child) Component:
         const Button = (props) => {
            console.log('Button RUNNING');
            return (
               <button type={props.type || 'button'} onClick={props.onClick} disabled={props.disabled}>
                  {props.children}
               </button>
            );
         };

      DemoOutput (Child) Component:
         const DemoOutput = (props) => {
            console.log('DemoOutput RUNNING');
            return(
               <p>{props.show ? 'This paragraph is new!' : ''}</p>
            );
         };

   > The paragraph element in the DemoOutput Component is always rendered; however, only the text will change based on the 'show' prop value which comes from the Parent Component via 'props'.
   > The show prop is set to the showParagraph state which will result in a true or false value based on the "Toggle Paragraph" button.
   > This logic will dynamically change what is displayed in the Child Component's paragraph element. The behaviour of the app is the same as before but now using a Child Component to control the paragraph element.

   Analysing the Child Component Re-Evaluation in Action:
      > If you go to the "Elements" tab within the browser's developer tools you will notice the <p> element is already rendered to the screen after the first execution and always appears. However, when you click the button to toggle between displaying a text you will see the <p> element flashing. This is treated as a change for the entire paragraph element, which is why the <p>> flashes on real DOM changes and not just the text.
      > The <h1> and <button> elements do not change/flash. The fact that you use a custom Component/element does not change this. The updating mechanism should always work by comparing differences.
      > You will also notice in the browser's developer tool console that the "APP RUNNING" is being printed every time we click the button. The actual change occurs in the DemoOutput Component but the App Component runs again as well because that is where we manage the state.
      > The Component where you manage 'State' or have 'Props' or 'Context' and that state/prop/context changes then that Component will be re-evaluated and re-executed. Therefore, just because the change visually affects the paragraph in another Component does not mean that the Parent Component which manages the state/prop/context is not re-evaluated.
      > This is also what was meant earlier with 'Props' and 'Context' in the end always come down to 'State' changes.
      > You will also notice the "DemoOutput RUNNING" also printing everytime the "Toggle Paragraph" button is clicked (including when the Child Component initially renders).

      > The above example is simple to understand the logic. Taking the above example, if we were to change the 'show' prop in the Parent App Component to be a hard coded value (i.e. "<DemoOutput show={false}" />) and therefore the paragraph will never show. The showParagraph state will change on the "Toggle Paragraph" button click but we are no longer using the value for the 'show' prop.
      > If we were to now click the "Toggle Paragraph" button we will now see something more confusing: both the "APP RUNNING" and "DemoOutput RUNNING" are printed to the browser's console on every click even though the value to the show prop does not change. Why is this?
         - We can understand "APP RUNNING" will continue to be printed on every button click because the 'showParagraph' state changed in that Component causing a re-evaluation.
         - The props in the DemoOutput did not change (i.e. it is always false) but it was re-rendered which is interesting. Why was the DemoOutput re-evaluated?
            - The App Component function is re-executed because the state changed. Part of the App function is the return statement which returns JSX code.
            - All the JSX code within the return statement are like function calls to the respective Component functions. Therefore, we cal the function for the <DemoOutput/> and <Button/> Child Components.
            - Hence, this is the reason for why the Child Components are also re-executed and re-evaluated just because the Parent Component has changed. The Child Component are part of the Parent Component function body.
            - If the Parent Component function re-runs again, so does all the Child Components re-run again.
            - The prop value does not matter for the Component to be executed again. It is just the fact that the Parent Component changed. Changes in props might lead to actual changes to the real DOM but for the Child Component function to be re-evaluated, it is enough for the Parent Component function was re-evaluated.
            - The fact that the DemoOutput Component function runs again does not mean that the real DOM is touched. This is verified by the Elements tab whereby the <p> element does not flash or change.
            - React re-evaluating a Component and re-running its Component function is not the same as re-rendering/manipulating the real DOM.
            - You should also notice that the <Button/> Component will also re-run when the Parent App Component function is re-executed (and can see this if you add the console.log('Button RUNNING') within that function).
      > This should bring up an important question: If the Child Components were to have their own Child Components, would they be re-evaluated? The answer would be yes. This can be seen if the above code was updated to the below example:

         DemoOutput (Child Component):
            import MyParagraph from './MyParagraph';
            const DemoOutput = (props) => {
               console.log('DemoOutput RUNNING');
               return(
                  <MyParagraph>{props.show ? 'This paragraph is new!' : ''}</MyParagraph>
               );
            };

         MyParagraph (DemoOutput Child's Child) Component:
            const MyParagraph = (props) => {
               console.log('MyParagraph RUNNING');
               return(
                  <p>{props.children}</p>
               );
            };

   > You should also see "MyParagraph RUNNING" in the console to demonstrate that the Child's Children Components will also re-execute for every "Toggle Paragraph" button click.
   > Therefore the re-execution of Child Component will continue down the Component tree. This now brings up the next question of: is this bad because that leads to a lot of ongoing function executions and virtual comparisons that would certainly cost some performance?
   > This will be bad because in the above example, there is no actual real reason for re-evaluating the <DemoOutput/> Component because it can never change (i.e. the only prop it has has a hard coded value and the same will be true if it had no props at all being passed down from the Parent Component). Therefore, re-executing <DemoOutput/> Component and all of it's child Components down the Component Tree will be a waste.

------------------------------------------------------------------------------------
4. Preventing Unnecessary Re-Evaluations with React.memo():
------------------------------------------------------------------------------------
   > Ongoing function executions and virtual comparisons does cost some performance. It is needless to say that React is highly optimised for those executions and comparisons. So in a lot of React Apps including simple apps like the previous example, the re-evaluation will not matter.
   > Nonetheless, in larger apps you may wish to optimise it. Therefore, you as the developer can tell React that it should only re-execute a Child Component (e.g. the DemoOutput Child Component) under certain circumstances e.g. the props for that Component changed.
   > How would you tell React that it should behave like this?
      - You would need to go into the Component that you want to opt into the example "did the prop change check".
      - Wrap the Component in the export line with React.memo() method.
      - Important Note: The React.memo() wrapper method will only work with React Functional Components (and does not work for Class-Based Components).

   Preventing Unnecessary Re-Evaluation with React.memo() Wrapper Method Example:
      DemoOutput (Child Component):
         import MyParagraph from './MyParagraph';
         const DemoOutput = (props) => {
            console.log('DemoOutput RUNNING');
            return(
               <MyParagraph>{props.show ? 'This paragraph is new!' : ''}</MyParagraph>
            );
         };
         export default React.memo(DemoOutput);

   Analysing the React.memo() method in Action:
      > The .memo() method tells React that for the Component that it receives as an argument/parameter, React should look at the props that this Component receives and check the new value for all those props and compare it with the previous values those props got. Only when the value of a prop changed the Component should be re-executed and re-evaluated.
      > Therefore, if the Parent Component changed but the prop values for the specified Component (i.e. <DemoOutput/>) did not change, then the Component execution will be skipped for that specified Component (and so will all of it's children down the Component Tree will be skipped).
      > This can be seen in the console (after the initial Component Function execution) that the "DemoOutput RUNNING" and "MyParagraph RUNNING" will no longer be printed to the browser console on the "Toggle Paragraph" button clicks.
      > This optimisation avoids unnecessary re-rendering. This would lead to the next question: why are we not using this optimisation on all components if it allows us to optimise them?
         - The reason is because this optimisation comes at a cost. The .memo() method in the above example tells React that whenever the App Component has changed, it should go to the specified Component (e.g. <DemoOutput/>) and compare the new prop values to the previous prop values.
         - Therefore, React will need to do two things: store the previous prop values and make that comparisons. This in itself has its own performance cost.
         - Hence, it greatly depends on whether or not it is worth optimising the Component you are applying the .memo() optimisation to. This is because you are trading the performance cost of re-evaluating the Component for the performance cost of comparing props.
         - It is impossible to say which cost is higher because this will depend on the number of props you have and the complexity of your Component and the number of Child Components the Component has.
         - The React.memo() can be a great optimisation tool if you have a huge Component tree with a lot of Child Components and the Component in question is on a high level within the Component tree can help avoid unnecessary re-render cycles for the entire branch of the Component tree.
         - If on the other hand you have a Component where you know it is going to change or its props values are going to change with pretty much every re-evaluation of the Parent Component anyway, then the React.memo() will not make sense in such scenario i.e. if the result is that the Component should re-render anyway then you can save that extra comparison of the props values overhead.
         - Ultimately, it depends on the App size i.e. for small applications/Component trees it is not worth to add the optimisation. On the other hand, for larger applications, where you can cut off entire branches of unnecessary re-evaluations then it might be well worth the optimisation.
         - To conclude, you do not want to wrap every Component with React.memo() optimisation but rather pick key Components within the Component tree which allows you to cut off an entire branch of Child Components which is way more effective than applying it on every Child Component.

      > Now lets apply the .memo() optimisation to the Button Component (e.g. 'export default React.memo(Button);'). You will notice something rather strange.
      > When you click the "Toggle Paragraph" button the "Button RUNNING" continues to print to the browser's console indicating the re-evaluation. Why is this?
         - The reason you would continue to see the <Button/> Component re-evaluating is because its' props values did actually change.
         - In the Parent App Component, the <Button/> Child Component receives an "onClick" prop which is set to the "toggleParagraphHandler" pointer function and a children prop (the contents between the Opening and closing <Button></Button> tags i.e. the text "Toggle Paragraph") which never change.
         - This is a common gotcha with React. Keep in mind the App Component is a function in the end and it re-executes like a normal JavaScript function because it is a normal JavaScript function. The only magic is that the function is going to be called by React and not by you, but then it executes like a normal function. Therefore all the code gets executed again.
         - This has one important implication, the 'toggleParagraphHandler' function which is passed to the <Button/> Component on the "onClick" prop is recreated. Therefore, the "toggleParagraphHandler" is a brand new function for every execution cycle of the App function.
         - Thus, the function is not the same one passed all the time but it is a new function that does the same thing as the previous function. Technically to JavaScript the function is a brand new function for everytime the App function is being executed.
         - This logic is also true for the "{false}" value being passed to the <DemoOutput/> Components "show" prop. Previously, we said the {false} value never changes but that technically was not correct. When the App Component is re-executed a new "false" value is created. This leads to the question: should <DemoOutput/> Component also be re-evaluated regardless of the .memo() optimisation?
         - You need to keep in mind that false is a boolean value. Boolean like other data types such as strings and numbers are primitive values in JavaScript. With primitive values if you compare for example two Booleans you will get true or false whether or not they evaluate to be the same (e.g. false === false evaluates to true and 'hi' ==== 'hi' evaluates to true i.e. the values are the same).
         - When comparing reference data types such as arrays, object or functions the evaluation would result to false. While the data type would look the same to a human, to JavaScript they are not the same (e.g. [1,2,3] === [1,2,3] will evaluate to false).
         - For more information on reference vs primitive values refer to https://academind.com/tutorials/reference-vs-primitive-values/ - this is a core concept in JavaScript that you should understand.
         - Functions are just objects in JavaScript. Two object, even if they have the same content are never equal with compared to each other in JavaScript.
         - Therefore, the .memo() method when it compares reference type prop values, it will always evaluate to false and will consider the prop value has changed and re-evaluates the Component. 
         - Understanding this information is crucial and to get right when using the .memo() optimisation.
      > The next question: Does this mean that React.memo() is useless for Components that receive reference type values through their props? The short answer is no.