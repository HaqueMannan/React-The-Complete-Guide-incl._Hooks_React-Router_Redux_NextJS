Handling Side Effects, Using Reducers & Using the Context API - Summary:
1. What are 'Side Effects' & Introducing useEffect
2. Using the useEffect() Hook
3. useEffect and Dependencies
4. Dependencies Rules and Exceptions
5. Using the useEffect Cleanup Function 
6. Introducing useReducer() Hook and Reducers in General
7. Using the useReducer() Hook
8. useReducer() and useEffect() Hooks and Object Destructuring Optimisation
9. useReducer() vs useState() for State Management
10. Introducing React Context (Context API)
11. Using the React Context API (Provider and Consumer Pattern)
12. Using the React Context API (useContext() Hook)

------------------------------------------------------------------------------------
1. What are 'Side Effects' & Introducing useEffect:
------------------------------------------------------------------------------------
   > Effects are sometimes referred to as 'Side Effects' and the terms can be used interchangeably.
   > The React Library, Components and the React application as a whole has one main job which is to render the UI and react to user inputs.
   > We can say React is used to manage the following:
      - Evaluates and renders JSX
      - Manage State and Props
      - React to (User) Events & Input
      - Re-evaluate Component upon State & Prop Changes
   > All the above are "baked into" React via the "tools" and features that we have analysed within the Basic & Foundations Sections (i.e. useState(), Hooks, Props, etc.)
   > Side Effects are anything else that may be occuring within your application (other than those mentioned above).
   > For example: storing data in Browser Storage, sending HTTP Requests to the Backend Servers, Setting and Managing Timers, etc.
   > All these tasks are not related to bringing something onto the screen (at least not directly).
   > React does not care about Side Effect and is not what React was built for i.e. React only cares about drawing domething directly to the screen (front-end).
   > Tasks that must happen outside of the normal Component evalution and render cycle (especially since they might block/delay rendering e.g. HTTP requests) are known as Side Effects (back-end).
   > Side Effects should not go directly into a Component function because it would most likely create bugs, infinate loops or simply send too many HTTP requests to the server.
   > For example: You have an App Component which is re-executed by React automatically whenever e.g. the State within the Component function changes e.g. a isLoggedIn state. When the Component re-executes, React will check what the new result of the function execution should look like and compares with the Real DOM to make the changes rendered onto the screen. If you would send a HTTP request directly within the Component, this request would be sent whenever the function re-runs i.e. re-evaluates. This might sometimes be what you would want but not necessarily always. However, this could also create an infinate loop i.e. you send a request whenever the function re-runs and in response to the request you change some state which triggers the function re-evaluation. Therefore, such 'Side Effects' should not go directly into the Component function for the issues mentioned in the point above.
   > The useEffect() Hook is another built-in Hook i.e. function that you can use inside of your Component function that would do something special.

   The useEffect() Hook Example:
      useEffect(() => {...}, [dependencies]);

   > The useEffect() Hook function is called with two arguments/parameters. 
   > The first argument is a function that should be executed AFTER every Component evaluation IF the specified dependencies change.
   > The second argument is the specified dependencies that you would pass in. This is an array full of dependencies and whenever such a dependency changes, the first function argument will re-run.
   > Therefore, the side effect code/function goes in as the first argument of the useEffect() Hook. You would specify your dependencies of your side effect function as the second argument. Therefore, the first argument will only execute when your second argument dependencies changes.
   > This prevents any infinite loops from occurring.

------------------------------------------------------------------------------------
2. Using the useEffect() Hook:
------------------------------------------------------------------------------------
   > When using State a variable is being managed by React behind the scenes. The nature of this means that when you reload the application the entire script restarts and all variables from the last execution are lost. This is how the web and scripts within the browser works and is nothing React specific.
   > It would be nice to store certain information somewhere where that data persists the reload for example a login details so that the user does not have to re-log back in when the page refreshes (provided the login details has persisted).
   > This is one such scenario where you would use the useEffect() Hook.
   > The browser has multiple storages you can use such as cookies or local storage which are built into the browser and independent from React (Note: typically you would use some sort of database to store data).

   useEffect() Hook without Dependencies Example:
      src/App.js:
         import React, { useState, useEffect } from 'react';
         function App() {
            const [isLoggedIn, setIsLoggedIn] = useState(false);
            useEffect(() => {
               const storedUserLoggedInInformation = localStorage.getItem('isLoggedIn');
               if(storedUserLoggedInInformation === '1') {
                  setIsLoggedIn(true);
               };
            }, []);
            const loginHandler = (email, password) => {
               localStorage.setItem('isLoggedIn', '1');
               setIsLoggedIn(true);
            };
            const logoutHandler = () => {
               localStorage.removeItem('isLoggedIn');
               setIsLoggedIn(false);
            };
            return(...);
         };

   > To use the useEffect Hook you would need to import it from the 'react' library as a named import.
   > The function within the useEffect() Hook is executed by React after every Component re-evaluation and only if a change has occurred to the dependencies array.
   > Therefore, when the application runs for the first time the useEffect() Hook anonymous function will run for the first time because it is considered that the dependencies have changed i.e. no dependencies to some dependencies. However, after the first initial execution, the effectHook() will no longer run again (even on a Component re-evaluation) until a dependency has been detected to have changed.
   > This is the exact behaviour you would want to avoid any infinite loop.
   > The data-fetching is a side effect and is not directly related to the UI (although the result of fetching the data would be related to the UI).

------------------------------------------------------------------------------------
3. useEffect and Dependencies:
------------------------------------------------------------------------------------
   > In the previous section we seen an example of using the useEffect() Hook without any dependencies. However, often you would need dependencies because you do not want to run the anonymous useEffect() function once when the application first starts up but after every Component re-evaluation if a dependency has changed.

   Original ChangeHandler Functions without useEffect() Hooks:
      const emailChangeHandler = (event) => {
         setEnteredEmail(event.target.value);
         setFormIsValid(
            event.target.value.includes('@') && enteredPassword.trim().length > 6
         );
      };
      const passwordChangeHandler = (event) => {
         setEnteredPassword(event.target.value);
         setFormIsValid(
            event.target.value.trim().length > 6 && enteredEmail.includes('@')
         );
      };

   useEffect() Hook with Dependencies Example:
      src/components/Login/Login.js:
         import React, { useState, useEffect } from 'react';
         const Login = (props) => {
            const [enteredEmail, setEnteredEmail] = useState('');
            const [enteredPassword, setEnteredPassword] = useState('');
            const [formIsValid, setFormIsValid] = useState(false);
            ...
            useEffect(() => {
               setFormIsValid(
                  enteredEmail.includes('@') && enteredPassword.trim().length > 6
               );
            }, [setFormIsValid, enteredEmail, enteredPassword]);
            const emailChangeHandler = (event) => {
               setEnteredEmail(event.target.value);
            };
            const passwordChangeHandler = (event) => {
               setEnteredPassword(event.target.value);
            };
            ...
            render(...);
         };

   > In the above example, the useEffect() Hook with dependencies is used to control a setFormIsValid logic which are used by two separate functions (i.e. emailChangeHandler and passwordChangeHandler). Previously, the setFormIsValid would have been in both functions but with slight variations to the logic. Using the useEffect() Hook allows you to create one area for the logic and only trigger this function when the dependency changes.
   > There is a simple rule that you add as dependencies what is being used within your side effect anonymous function. In the above example you are using setFormIsValid function, enteredEmail state and enteredPassword state.
   > Not that when you reference a function as a dependency that you reference the pointer to the function and do not execute it using the round brackets at the end of the function name. If you executed the function (e.g. setFormIsValid()) then this would add the result of the function execution as the dependencies.
   > This tells React that after every Login Component function execution to re-run the useEffect() function only if either the setFormIsValid, enteredEmail or enteredPassword has changed since the last Component re-render cycle. If neither changed then the useEffect() function will not re-run.
   > Important Note: you could actually omit the setFormIsValid as a dependencies because the State updating functions by default are ensured by React to never change. Therefore, these State set functions are always going to be the same across re-render cycles, hence, you can omit them as a dependencies as seen below:
      useEffect(() => {
         setFormIsValid(
            enteredEmail.includes('@') && enteredPassword.trim().length > 6
         );
      }, [enteredEmail, enteredPassword]);

   > This demonstrates another use case where the useEffect() Hook shines. You can have one code in one place which re-runs whenever one of the dependencies change.
   > This is one such example where you would use the useEffect() Hook and it is not only for when a Component was created for the first time. It is equally common to use this feature to re-run logic when certain data (typically some State or Props) has changed.
   > One aspect of the above example that can be confusing here is that in this useEffect example you are not working with localStorage, sending HTTP request, setting a timer, etc. Instead, you are updating the React State. This can be contradictory to what was mentioned in 1. What are 'Side Effects' & Introducing useEffect.
   > To clear this confusion, you must not forget that it is called useEffect and it has one main job which is to handle side effects. Often side effects are HTTP requests, setting a timer, etc.
   > But it is a side effect if you listen to every keystroke and save that entered data which you then you would want to trigger another action in response to that. Thus, checking and updating the form validity in response to a keystroke within a field is also something you can call a side effect i.e. it is a side effect of the user entering data.
   > Using this logic should not confuse you when you use sideEffect as seen in the above example.
   > The useEffect() Hook in general is a very useful Hook that helps you with code that should be executed in response to something (and that something could be a Component being loaded, input fields updated, etc. - i.e. it could be anything whenever you have an action that should be executed in response to some other action then that is a side effect).

------------------------------------------------------------------------------------
4. Dependencies Rules and Exceptions:
------------------------------------------------------------------------------------
   > You learned, that you should add "everything" you use in the effect function as a dependency - i.e. all state variables and functions you use in there.
   > There are a few exceptions you should be aware of:
      - You do not need to add state updating functions because React guarantees that those functions never change; hence, you do not need to add them as dependencies (although you could without any issues).
      - You also do not need to add "built-in" APIs or functions like fetch(), localStorage etc (functions and features built-into the browser and hence available globally). These browser APIs / global functions are not related to the React component render cycle and they also never change.
      - You also do not need to add variables or functions you might have defined outside of your components (e.g. if you create a new helper function in a separate file). Such functions or variables are also not created inside of a Component function; hence, changing them would not affect your Components (the Components would not be re-evaluated if such variables or functions change and vice-versa).
   > To conclude, you must add all "things" you use in your effect function if those "things" could change because your Component (or some parent component) re-rendered. That is why Variables or State defined in Component functions, Props or Functions defined in Component Functions have to be added as dependencies.

   Dependencies Rules Demonstration Example:
      import { useEffect, useState } from 'react';
      let myTimer;
      const MyComponent = (props) => {
         const [timerIsActive, setTimerIsActive] = useState(false);
         const { timerDuration } = props; // using destructuring to pull out specific props values
         useEffect(() => {
            if (!timerIsActive) {
               setTimerIsActive(true);
               myTimer = setTimeout(() => {
               setTimerIsActive(false);
               }, timerDuration);
            };
         }, [timerIsActive, timerDuration]);
      };

   > The timerIsActive is added as a dependency because it is a Component State that may change when the Component changes (e.g. because the state was updated).
   > The timerDuration is added as a dependency because it is a Prop value of that Component. So it may change if a parent Component changes that value (causing the MyComponent Component to re-render as well).
   > The setTimerIsActive is not added as a dependency because it is one of the exception rule. The State updating functions could be added but does not need to be added since React guarantees that the functions themselves never change.
   > The myTimer is not added as a dependency because it is not a Component-internal variable (i.e. not some State or a Prop value). It is defined outside of the Component and changing it (no matter where) would not cause the Component to be re-evaluated.
   > The setTimeout is not added as a dependency because it is a built-in API (built-into the browser). Thus, it is independent from React and your Components and does not change.

------------------------------------------------------------------------------------
5. Using the useEffect Cleanup Function:
------------------------------------------------------------------------------------
   > Sometimes you may need a side effect to perform some cleanup work.
   > For example, you may need to send a HTTP request to some backend where you check if a username is already in use. If you had a useEffect() that runs on every keystroke this would end up sending unnecessary HTTP requests (network traffic) to your backend. This is something you would want to avoid.
   > Alternatively, you may not want to listen to every keystroke to check the validation of an input field. Instead, you might want to collect a certain amount of keystrokes or simply wait for a pause of a certain time duration after a keystroke and only if the pause is long enough then you would perform the operation/function. This is technique is known as debouncing.
   > You would want to debounce a user input and ensure that you are doing something on every keystroke. This can be achieved with the inbuilt browser setTimeout() function.

   Debouncing Example:
      useEffect(() => {
         const identifier = setTimeout(() => {
            console.log('Checking for Validity');
            setFormIsValid(
               enteredEmail.includes('@') && enteredPassword.trim().length > 6
            );
         }, 500);

         return () => {
            console.log('CLEANUP');
            clearTimeout(identifier);
         };
      }, [enteredEmail, enteredPassword]);
   
   > The above would not do much other than delay the side effects validation output by 500 milliseconds.
   > The trick is to save the timer and for the next keystroke you would clear it so that you only have one ongoing timer at a time. Therefore, only the last timer would complete. Therefore, as long as the user keeps typing you would always clear other timers leaving just the one timer to complete after 500 milliseconds.
   > Within the useEffect() Hook, the first argument/parameters passed in can return something. This must be one specific thing i.e. a function itself.
   > This can be a named or anonymous function.
   > Returning an anonymous function (as seen in the above) which is known as a cleanup function. This cleanup function will run as a cleanup process before the useEffect() Hook executes the function next time.
   > In the above example, the useEffect() Hook for the first time will run the setTimeout function. On every re-evaluation of the Component file, the anonymous cleanup function will run before the execution of the side effect function. Additionally, the anonymous cleanup function would run whenever the Component, that specifies the effect within, unmounts from the DOM.
   > Remember: setTimeout and clearTimeout are both browser functions and has nothing to do with React.
   > You will notice that the 'CLEANUP' console log will be printed before the 'Checking for Validity' console log message (after the first execution the useEffect() Hook) which clearly demonstrates that the cleanup function runs before the actual side effect function after the first initial execution.

------------------------------------------------------------------------------------
6. Introducing useReducer() Hook and Reducers in General:
------------------------------------------------------------------------------------
   > The useReducer() Hook is another built-in Hook which helps with State Management.
   > This is similar to the useState() Hook but with more capabilities and is especially useful for more complex State (e.g. multiple states, multiple ways of changing the state or dependencies to other states).
   > The useState() then often becomes hard or error-prone to use and manage. It then becomes easy to write bad, inefficient or buggy code in such complex state scenarios.
   > The useReducer() is an alternative i.e a replacement for useState() if you need a "more powerful state management".
   > This does not mean that you should always use useReducer() over useState(). This is because the useReducer() while powerful is also more complex to use and setup and may not be suitable for certain simple state cases.
   > Below is an example of when the useReducer() Hook is a better fit for the scenario:

   const Login = (props) => {
      const [enteredEmail, setEnteredEmail] = useState('');
      const [emailIsValid, setEmailIsValid] = useState();
      const [enteredPassword, setEnteredPassword] = useState('');
      const [passwordIsValid, setPasswordIsValid] = useState();
      const [formIsValid, setFormIsValid] = useState(false);
      ...
   };

   > In the above you can see that a lot of state snapshot are being managed in one Component. Furthermore, there are some related states such as the entered value and the validity of the entered value and finally the overall form validity. Thus, it can be argued overall the above is one big state that describes the overall form state.
   > Alternatively, you would treat each form input as one single entity and one state which simply has two aspects of value and validity of that input.
   > It becomes clear in this example that you have some work to do and there are some redundancy if you consider the fact that you are setting the overall form validity by checking the validity of each input but also checking validity on the input handlers.

   Original ChangeHandler Functions without useEffect() Hooks:
      const emailChangeHandler = (event) => {
         setEnteredEmail(event.target.value);
         setFormIsValid(
            event.target.value.includes('@') && enteredPassword.trim().length > 6
         );
      };
      const passwordChangeHandler = (event) => {
         setEnteredPassword(event.target.value);
         setFormIsValid(
            event.target.value.trim().length > 6 && enteredEmail.includes('@')
         );
      };

   > Using the original version to handle the change event not only causes redundancy in repeat code; however, it can cause another problem where the setFormIsValid state relies on a snapshot of two other states.
   > We have previously learned that when you want to update some state on some older state that you should use the function form. However, this can only work if your next state update depends on the previous state snapshot of the same state. However, in the above example, it relies on two other snapshots of different state i.e. enteredEmail and enteredPassword and not the last snapshot of setFormIsValid.
   > In the above example, it is doing something that you should not do because of the way React schedules State updates. This could lead to a bug in a rare scenario where the setEmailIsValid function runs before the setEnteredEmail or setEnteredPassword was processed.
   > This is a good example of a scenario when you can use useReducer() Hook for managing state that belong together and/or if you have state updates that depends on other state.
   > It is always a good choice to use useReducer() Hook where you update a state which depends on another state. But note that it can also be managed without a useReducer() Hook by managing both the input and validity within one useState() rather than two separate states.

------------------------------------------------------------------------------------
7. Using the useReducer() Hook:
------------------------------------------------------------------------------------
   useReducer() Hook Example:
      const [state, dispatchFn] = useReducer(reducerFn, initialState, initFn);

   > The useReducer() Hook always returns an array with exactly two values (i.e. the same as the useState() Hook). Thus, you can use array destructuring to pull out these values and store them in variables.
   > The first value extracted is the latest 'state' snapshot used in the component re-render/re-evaluation cycle.
   > The second value extracted is a function that can be used to dispatch a new action (i.e. trigger an update of the state) also known as the dispatch function.
   > The second value acts slightly differently to useState(). Instead of setting a new state value, you would dispatch an action and that action would be consumed by the first argument passed into the useReducer() Hook.
   > The first argument/parameter you pass to the useReducer() Hook is a reducer function. The reducer function is a function that is triggered automatically once an action is dispatched via the dispatch function (i.e. 'dispatchFn')). It receives the latest state snapshot and should return a new updated state.
   > We could say that this is similar to the function form of the useState() Hook; however, it is an extended version that uses dispatched actions.
   > The second argument/parameter passed to the useReducer() Hook is an initial state.
   > Finally, the last argument/parameter passed to the useReducer() Hook is an initial function that you want to run to set the initial state programmatically (in the event the initial state is a little more complex e.g. as a result of a HTTP request).

   Using useReducer() Hook Example:
      src/components/Login/Login.js:
         import { useReduce } from 'react';
         const emailReducer = (state, action) => {
            if(action.type === 'USER_INPUT') {
               return {value: action.val, isValid: action.val.includes('@')};
            };
            if(action.type === 'INPUT_BLUR') {
               return {value: state.value, isValid: state.value.includes('@')};
            };
            return {value: '', isValid: false};
         };
         const Login = (props) => {
            const [emailState, dispatchEmail] = useReducer(emailReducer, {value: '', isValid: null});
            const emailChangeHandler = (event) => {
               dispatchEmail({type: 'USER_INPUT', val: event.target.value})
               setFormIsValid(
                  event.target.value.includes('@') && enteredPassword.trim().length > 6
               );
            };
            const passwordChangeHandler = (event) => {
               setEnteredPassword(event.target.value);
               setFormIsValid(
                  emailState.isValid && event.target.value.trim().length > 6
               );
            };
            const validateEmailHandler = () => {
               dispatchEmail({type: 'INPUT_BLUR'});
            };
            ...
            render(...)
         };

   > First you need to import useReducer from the 'react' library as a named import.
   > Use destructuring to extract the state and the dispatch function (e.g. emailState and dispatchEmail) into variables. The name is entirely up to you as a developer.
   > The useReducer() Hook takes in a function as the first argument. This can be either a named function or an anonymous function.In the above example the named function approach is used to make it easier to read the code.
   > Notice that the named function is created outside of the Component function. This is because the reducer function does not need any data created inside of the function. Hence, it can be created outside of the scope of the Component function because it does not need to interact with anything defined inside of the Component function. All the data which will required and used inside of the reducer function will be passed into the function when it is executed by React automatically.
   > The reducer function receives two arguments/parameters: the last state snapshot and the action that was dispatched.
   > The reducer function should return a new state.
   > The useReducer() Hook second argument is the initial state i.e. the initial state snapshot for the extracted 'emailState' const variable.
   > The destructed 'emailState' values can be used within your Component code (e.g. emailState.value or emailState.isValid which are the two keys/state stored within the emailState).
   > The dispatchEmail dispatch function requires an action to be passed to it as an argument/parameter. The action is totally up to you as the developer such as a string identifier, number identifier or an object.
   > In the above example, the action dispatched is an object. This object has a 'type' key which stores an string. The string is in upper case letters but is not necessary as it is only a naming convention for actions. You can add extra payloads to the action if you use an object as your dispatched action. Again, it is totally up to you what the dispatched action is at the end of the day.
   > The extra payload in the above example is the input value which is captured by the 'event.target.value'.
   > The 'dispatchEmail' dispatch function will trigger the 'emailReducer' function because this was the function passed in as the first argument to the useReducer() function.
   > You can handle the 'emailReducer' function using an if statement to check the 'action' type which is passed/received to the 'emailReducer' function automatically by React. The action is whatever was passed as the action within the 'dispatchEmail' dispatch function (in the above example it is an object).
   > You can now check for the action type and decide what to return i.e. instead of an empty state snapshot you can now return a snapshot of the new state value.
   > Both the 'value' and 'isValid' states for the email input are now being updated using the useReducer() Hook whenever it receives the 'USER_INPUT' action. For any other action that might reach the 'emailReducer' function then the default state would be returned.
   > Important Note: Dispatched Actions should always be consistent within your code.
   > The 'state' argument within the 'emailReducer' function is always the last state snapshot. React guarantees to automatically pass the last state snapshot. Therefore, for the 'INPUT_BLUR' action uses the last snapshot value when setting the new snapshot to return from the reducer function.
   > The form now works as you would expect but using the useReducer() Hook to control the multiple state values as one larger state all managed in one place.

------------------------------------------------------------------------------------
8. useReducer() and useEffect() Hooks and Object Destructuring Optimisation:
------------------------------------------------------------------------------------
   > You can use both the useReducer and useEffect Hooks together. However, the problem you would run into is the useEffect() Hook will run too often. For example, the useEffect() Hook will run whenever the emailStat or passwordState changes. This will include where only the value state changes but not the isValid state and you are only interested in the isValid state (e.g. another character is added but the validity has not changed).
   > This would cause the side effect to run unnecessarily and something you would want to avoid with your useEffect() Hook dependencies that are useReducers state.
   > To avoid this issue you should use a technique called object destructuring.

   Object Destructuring Example:
      src/components/Login/Login.js:
         import { useReduce } from 'react';
         const emailReducer = (state, action) => {...}
         const passwordReducer = (state, action) => {...}
         const Login = (props) => {
            const [formIsValid, setFormIsValid] = useState(false);
            const [emailState, dispatchEmail] = useReducer(emailReducer, {value: '', isValid: null});
            const [passwordState, dispatchPassword] = useReducer(passwordReducer, {value: '', isValid: null});
            const { isValid: emailIsValid } = emailState;
            const { isValid: passwordIsValid } = passwordState;
            useEffect(() => {
               const identifier = setTimeout(() => {
                  console.log('Checking for Validity');
                  setFormIsValid(
                     emailIsValid && passwordIsValid
                  );
               }, 500);
               return () => {
                  console.log('CLEANUP');
                  clearTimeout(identifier);
               };
            }, [emailIsValid, passwordIsValid]);
            render(...);
         };

   > In the above example, the isValid object properties are being destructed and stored in a constant (this can be in the same name using the following syntax 'const { isValid } = emailState;').
   > Since there is already a isValid const extracted you cannot use the same variable name within the same scope. Therefore, using a colon (:) after the property allows you to provide an alias for the destructed object property to avoid any variable conflicts.
   > Therefore, the syntax 'const { isValid: emailIsValid } = emailState;' is extracting the 'isValid' property from the 'emailState' object but storing it within a const variable that has an alias of 'emailIsValid'. This is known as alias assignment and not a value assignment because it is part of the object destructuring syntax (i.e. when you use the curly brackets ob the left side of the equal operator).
   > You can now use the destructed object properties as dependencies for the useEffect() Hook to target changes to the 'isValid' property only of your useReducer() Hook state object.
   > Whenever only the value changes and the validity does not change the useEffect will no longer re-run which is much better code on performance because the useEffect no longer re-runs unnecessarily.
   > This is Important concept to understand to further optimise using the useEffect() with useReducer() Hooks and avoid any unnecessary useEffect() Hook execution.
   > This concept can also be used even if you do not use the useReducer() Hook. For example, if you have 'Props' as a dependencies for your useEffect() Hook. You do not want to re-run the side effect when the 'props' change but only when some 'props' change - object destructuring will help you for useEffect() Hook execution optimisation.

   Important Note:
   > You could use nested properties as dependencies to useEffect. The below example works the same way:
      useEffect(() => {
         // code that only uses someProperty ...
      }, [someObject.someProperty]);

   > The key thing is not that you use destructuring but that you pass specific properties instead of the entire object as a dependency. This is to avoid the side effect function re-running whenever any properties of 'someObject' changes and not just the one property ('someProperty' in the above example) or some specific properties that your side effect might depend on.

------------------------------------------------------------------------------------
9. useReducer() vs useState() for State Management:
------------------------------------------------------------------------------------
   > Generally, you will know when you need to use useReducer() for example when using useState() becomes cumbersome or you are getting a lot of bugs/unintended behaviours.
   > The useState() Hook is your main state management "tool".
   > The useState() Hook is great for independent pieces of state/data.
   > The useState() Hook is great if state updates are easy and limited to few kinds of updates.
   > The useReducer() Hook is great if you need "more power" (i.e. write reducer function that can take in a more complex state update logic where you are guaranteed to always work with the latest snapshot and where you can move that complex logic out of the Component function body into a separate reducer function).
   > The useReducer() Hook should be considered if you have related pieces of state/data.
   > The useReducer() Hook can be helpful if you have a more complex state updates.
   > There are no hard rule when to use either Hooks for State Management and is purely up to you as the developer to choose which to implement for your scenario.
   > You should not always use the useReducer() Hook because often it will be an overkill for example if you have a simple state that switches between two different values.

------------------------------------------------------------------------------------
10. Introducing React Context (Context API):
------------------------------------------------------------------------------------
   > A common problem that occurs in larger React projects is where a lot of data are being passed through a lot of components via "props".
   > For example, a login state and function would be managed in the App.js Component because the state needs to be lifted up to that Component because the state and update function is needed everywhere within the application.
   > Passing the state to multiple different Components in a small project is not a problem. It is quite common to pass data to Components through props but it is always a problem if you forward state through multiple Components (i.e. leveraging "props" to forward the data to another Component).

   Forwarding Props through Component Example:
      src/App.js
         ...
         function App() {
            ...
            return (
               <React.Fragment>
                  <MainHeader isAuthenticated={isLoggedIn} onLogout={logoutHandler} />
                  <main>
                     {!isLoggedIn && <Login onLogin={loginHandler} />}
                     {isLoggedIn && <Home onLogout={logoutHandler} />}
                  </main>
               </React.Fragment>
            );
         };

      src/components/MainHeader/MainHeader.js:
         ...
         const MainHeader = (props) => {
            return (
               <header className={classes['main-header']}>
                  <h1>A Typical Page</h1>
                  <Navigation isLoggedIn={props.isAuthenticated} onLogout={props.onLogout} />
               </header>
            );
         };

      src/components/MainHeader/Navigation.js:
         ...
         const Navigation = (props) => {
            return (
               <nav className={classes.nav}>
                  <ul>
                     {props.isLoggedIn && (<li><a href="/">Users</a></li>)}
                     {props.isLoggedIn && (<li><a href="/">Admin</a></li>)}
                     {props.isLoggedIn && (<li><button onClick={props.onLogout}>Logout</button></li>)}
                  </ul>
               </nav>
            );
         };

   > Within the App Component file the 'isLoggedIn' state is being passed through the 'isAuthenticated' prop to the <MainHeader/> Component and the same is true for the 'logoutHandler' function pointer via the 'onLogout' prop.
   > Within the MainHeader Component file, neither the 'isLoggedIn' or 'logoutHandler' props are being used by the Component. Instead, the props are only being used to forward them again onto the <Navigation /> Component.
   > It is the Navigation Component at the end of the day that requires the 'isLoggedIn' or 'logoutHandler' props to render the different navigation links.
   > This is not necessarily a problem but with larger application that chain of forwarding may become longer and longer.

   Fictitious Application Example:
         ------------------<App/> ------------------
         |                    |                    |
      <Auth/>              <Shop/>              <Cart/>
         |                    |
      <LoginForm/>         <Products/>
      [Login]                 |
                           <Products/>
                              |
                           <Product/>
                           [Add to Cart]

   > In this example, the LoginForm has a Login event where the user fills out and submits the form which will validate the data and finds the data is now logged in. The logged in status data might be needed in different parts of the application e.g. the <Shop /> and <Cart/> Components. You may have something similar to when adding a product to the Cart which you need that information to show the product in the <Cart/> Component.
   > Since the <LoginForm> is a direct child of <Auth/> which is a child of <App/> and similarly the <Product/> is a direct child of <Products/> which is a child of <Shop/> which is a child of <App/>, there are no direct connections to the other Components where the data might be needed.
   > If the user clicks a button in the <Product/> Component to add a product to the <Cart/> Component, the information needs to reach the <Cart/> Component but there are no direct connections between the <Product/> and <Cart/> Components (and similar for the Login scenario). Consequently, you would typically use Props and Functions passed via "props" through the chain.
   > This behaviour leads to forwarding data through different Components. This would mean the prop/function would be managed in the <App/> Component because the state has been lifted up to the level that has access to both Components that require the data (i.e. like creating a middleman even though the middleman does not need the prop/function but to solely forward them on to the Components that do need them).
   > In larger apps this could easily lead to building large "prop" chains which are used to forward data through Components to update other Components. This is something you can do and is not necessarily bad but the larger your application becomes the more inconvenient it becomes to pass props through the chain.
   > Instead, it would be nicer if you could use "props" in a Component to only receive the data that the Component really needs from it's Parent and not to forward other data through the Parent which the Parent neither manages nor needs the data itself.
   > React provides out of the box a Component-wide "behind the scenes" State Storage solution. The concept is called React Context which will allow you to trigger an action in the Component-wide State Storage and directly pass that to the Component that is interested without building such a long "prop" chain. This solution allows you to solve your problem in a more elegant way.

------------------------------------------------------------------------------------
11. Using the React Context API (Provider and Consumer Pattern):
------------------------------------------------------------------------------------
   > Create a new folder called "Context" (or whatever you would like to call it e.g. state, store, etc.) within the "src" directory.
   > Create a JavaScript file within this folder the name is entirely up to you as a developer e.g. auth-context.js (you could use Pascal casing like AuthContext; however, this may imply that you are going to store a Component within the file which is not what you are intending to do).
   > You can have multiple context files for multiple global states within your application or you could use one large context for larger applications - it is entirely up to you how you design your application state.
   > import React as you would normally would do but you would call the .createContext() method on the 'React' import object.

   React Context Example:
      src/store/auth-context.js:
         import React from 'react;
         const AuthContext = React.createContext({
            isLoggedIn: false
         });
         export default AuthContext;

   > The .createContext() method creates a "context" object. This method takes in a default context. The "context" here is really just your App or Component-wide State. This can be a simple string but often it would be an object managing multiple state properties.
   > What is returned by the .createContext() method is a Component (or an Object that contains Components) which you can store in a variable to reference the object.
   > In the above example, we named it "AuthContext" similar to how you would name a Component. While AuthContext itself is not a Component, it is an object that will contain a Component.
   > You can now export this variable to make the Context Object available within other files.
   > To user the context within your application you need to do two things. First you need to provide the context (i.e. to let React know about the context) and secondly you need to consume the context (i.e. listen/hook into the Context).
   > Providing the context is always the first step and it means that you wrap in JSX code all the Components that should be able to tap into (i.e. listen) to that context. Any Components that are not wrapped cannot listen to the context.

   Providing the Context Example:
      src/App.js:
         import AuthContext from './store/auth-context';
         function App() {
            ...
            return (
               <AuthContext.Provider>
                  <MainHeader isAuthenticated={isLoggedIn} onLogout={logoutHandler} />
                  <main>
                     {!isLoggedIn && <Login onLogin={loginHandler} />}
                     {isLoggedIn && <Home onLogout={logoutHandler} />}
                  </main>
               </AuthContext.Provider>
            );
         };

   > To wrap Component that needs to listen to the context you first need to import the Context Object and within the return JSX code use the context as a wrapper.
   > In the above example the AuthContext is needed by every Components within the application hence it was imported in the App.js file and wraps everything within the return statement.
   > The "AuthContext" object is not a Component itself (in JSX you require a Component) but the object has a property that contains a Component called 'Provider'.
   > All Components wrapped in the wrapper and their descendant Components will now have access to the Context. In the above example MainHeader, Login, Home and all their children Components such as Navigation will have access to the Context.
   > There are two ways to consume (listen) to the Context API. You can listen by using AuthContext Consumer or by using a React Hook.

   Consuming the Context via Consumer Example:
      src/components/MainHeader/Navigation.js:
         ...
         import AuthContext from '../../store/auth-context';
         const Navigation = (props) => {
            return (
               <AuthContext.Consumer>
                  {(ctx) => {
                    return(
                        <nav className={classes.nav}>
                           <ul>
                              {ctx.isLoggedIn && (<li><a href="/">Users</a></li>)}
                              {ctx.isLoggedIn && (<li><a href="/">Admin</a></li>)}
                              {ctx.isLoggedIn && (<li><button onClick={props.onLogout}>Logout</button></li>)}
                           </ul>
                        </nav>
                    )
                  }}
               </AuthContext.Consumer>
            );
         };

   > With the AuthContext Consumer method you would import the AuthContext object and then within the return JSX code you would wrap the entire Component with the AuthContext.Consumer property Component.
   > The consumer works a little differently to the Provider property i.e. it takes in a child which should be a function between curly brackets. This function will receive the context data as a argument/parameter (i.e. the exported object defined in the auth-context.js file). Within this function you should then "return" your JSX code which should now be able to consume and have access to the data.
   > The app would crash if saved. This is because the auth-context.js context API object has a default value for isLoggedIn. This default value will actually only be used if you would consume without having a Provider. Therefore, technically, the <AuthContext.Provider> wrapper is not needed in such a case where you have a default value.
   > However, you should memorise this pattern where you would need the <AuthContext.Provider> because you would typically have a context where the value can change and is only possible with having the <AuthContext.Provider> wrapper pattern implemented.
   > To make sure the above does not crash you could add a "value" prop (and has to be named value) to the <AuthContext.Provider>. You can then pass the object setup from the context file as demonstrated below:

   Providing the Context Static Object State Example:
      src/App.js:
         import AuthContext from './store/auth-context';
         function App() {
            ...
            return (
               <AuthContext.Provider value={
                  {isLoggedIn: false}
               }>
                  <MainHeader isAuthenticated={isLoggedIn} onLogout={logoutHandler} />
                  <main>
                     {!isLoggedIn && <Login onLogin={loginHandler} />}
                     {isLoggedIn && <Home onLogout={logoutHandler} />}
                  </main>
               </AuthContext.Provider>
            );
         };

   > This now allows you to change that Object (e.g. through state in the App Component) and whenever it changes the new value will be passed down to all consuming Components (i.e. those wrapped by the <AuthContext.Consumer>).
   > The application will now be able to load without any problems because the Provider no longer receives a static context state object and the state object can now be changed by other components and this context state can be consumed by the Consumer.

   Final Provider/Consumer Context API Pattern Code Example:
      src/store/auth-context.js:
         import React from 'react;
         const AuthContext = React.createContext({
            isLoggedIn: false
         });
         export default AuthContext;

      src/App.js:
         import AuthContext from './store/auth-context';
         function App() {
            ...
            return (
               <AuthContext.Provider value={
                  {isLoggedIn: isLoggedIn}
               }>
                  <MainHeader onLogout={logoutHandler} />
                  <main>
                     {!isLoggedIn && <Login onLogin={loginHandler} />}
                     {isLoggedIn && <Home onLogout={logoutHandler} />}
                  </main>
               </AuthContext.Provider>
            );
         };

      src/components/MainHeader/MainHeader.js:
         ...
         const MainHeader = (props) => {
            return (
               <header className={classes['main-header']}>
                  <h1>A Typical Page</h1>
                  <Navigation onLogout={props.onLogout} />
               </header>
            );
         };

      src/components/MainHeader/Navigation.js:
         ...
         import AuthContext from '../../store/auth-context';
         const Navigation = (props) => {
            return (
               <AuthContext.Consumer>
                  {(ctx) => {
                     return(
                        <nav className={classes.nav}>
                           <ul>
                              {ctx.isLoggedIn && (<li><a href="/">Users</a></li>)}
                              {ctx.isLoggedIn && (<li><a href="/">Admin</a></li>)}
                              {ctx.isLoggedIn && (<li><button onClick={props.onLogout}>Logout</button></li>)}
                           </ul>
                        </nav>
                     )
                  }}
               </AuthContext.Consumer>
            );
         };

   > The isLoggedIn does not need to have a hardcoded value. It can have a dynamic value from the Component file. In the above example {isLoggedIn: false} has been updated to be {isLoggedIn: isLoggedIn}. Therefore, this property will be updated by React whenever isLoggedIn has changed. That new Provider context object will be passed down to all listening Components that consumes the context.
   > The difference here is that you no longer require to pass a "prop" to forward the state. It is set on the Provider and then in every child Components can listen to that state change. Therefore, the MainHeader no longer needs to pass the 'isAuthenticated' state and within the MainHeader Component stop forwarding the 'isAuthenticated' to the Navigation Component. The Navigation Component can now use the 'ctx.isLoggedIn' context everywhere that it is needed. The final code would look like the above using the React Context API's Provider/Consumer pattern.
   > The isLoggedIn prop is no longer needed to be passed through Component as it is now captured within the AuthContext Context API and the Provider will always provide the updated state value while all Consumers can listen to the context state and React to the changes within the Components file that needs the context. This breaks the "props" chaining solution leveraging Reacts Context API instead.
   > This is one syntax patten that you can use to implement the REACT Context API. The second and possible more elegant method is to use Reacts useContext() Hook.

------------------------------------------------------------------------------------
12. Using the React Context API (useContext() Hook):
------------------------------------------------------------------------------------
   > Setting up the Context JavaScript file and Providing th Context Object remain the same as before.
   > To consume the context using the useContext() Hook is demonstrated below:

   Consuming React Context API with useContext() Hook Example:
      src/components/MainHeader/Navigation.js:
         import React, { useContext } from 'react';
         import AuthContext from '../../store/auth-context';
         ...
         const Navigation = (props) => {
            const ctx = useContext(AuthContext);
            return (
               <nav className={classes.nav}>
                  <ul>
                     {ctx.isLoggedIn && (<li><a href="/">Users</a></li>)}
                     {ctx.isLoggedIn && (<li><a href="/">Admin</a></li>)}
                     {ctx.isLoggedIn && (<li><button onClick={props.onLogout}>Logout</button></li>)}
                  </ul>
               </nav>
            );
         };

   > To use the useContext() Hook, you would need to import the named export from the 'react' library.
   > Call on the useContext() Hook within the React Component function and pass in a pointer to the context you want to use to it. You should import the exported Context Object.
   > The useContext() Hook returns the context value which you can store in a variable to use i.e. in the above example it is stored in a 'ctx' variable (you could have named this anything you would like).
   > The code would now work as it did before. This is a more elegant method of consuming the Context API compared to the Provider/Consumer method.