Handling Side Effects, Using Reducers & Using the Context API - Summary:
1. What are 'Side Effects' & Introducing useEffect
2. Using the useEffect() Hook
3. useEffect and Dependencies
4. Dependencies Rules and Exceptions
5. Using the useEffect Cleanup Function 
6. Introducing useReducer() Hook and Reducers in General

------------------------------------------------------------------------------------
1. What are 'Side Effects' & Introducing useEffect:
------------------------------------------------------------------------------------
   > Effects are sometimes referred to as 'Side Effects' and the terms can be used interchangeably.
   > The React Library, Components and the React application as a whole has one main job which is to render the UI and react to user inputs.
   > We can say React is used to manage the following:
      - Evaluates and renders JSX
      - Manage State and Props
      - React to (User) Events & Input
      - Re-evaluate Component upon State & Prop Changes
   > All the above are "baked into" React via the "tools" and features that we have analysed within the Basic & Foundations Sections (i.e. useState(), Hooks, Props, etc.)
   > Side Effects are anything else that may be occuring within your application (other than those mentioned above).
   > For example: storing data in Browser Storage, sending HTTP Requests to the Backend Servers, Setting and Managing Timers, etc.
   > All these tasks are not related to bringing something onto the screen (at least not directly).
   > React does not care about Side Effect and is not what React was built for i.e. React only cares about drawing domething directly to the screen (front-end).
   > Tasks that must happen outside of the normal Component evalution and render cycle (especially since they might block/delay rendering e.g. HTTP requests) are known as Side Effects (back-end).
   > Side Effects should not go directly into a Component function because it would most likely create bugs, infinate loops or simply send too many HTTP requests to the server.
   > For example: You have an App Component which is re-executed by React automatically whenever e.g. the State within the Component function changes e.g. a isLoggedIn state. When the Component re-executes, React will check what the new result of the function execution should look like and compares with the Real DOM to make the changes rendered onto the screen. If you would send a HTTP request directly within the Component, this request would be sent whenever the function re-runs i.e. re-evaluates. This might sometimes be what you would want but not necessarily always. However, this could also create an infinate loop i.e. you send a request whenever the function re-runs and in response to the request you change some state which triggers the function re-evaluation. Therefore, such 'Side Effects' should not go directly into the Component function for the issues mentioned in the point above.
   > The useEffect() Hook is another built-in Hook i.e. function that you can use inside of your Component function that would do something special.

   The useEffect() Hook Example:
      useEffect(() => {...}, [dependencies]);

   > The useEffect() Hook function is called with two arguments/parameters. 
   > The first argument is a function that should be executed AFTER every Component evaluation IF the specified dependencies change.
   > The second argument is the specified dependencies that you would pass in. This is an array full of dependencies and whenever such a dependency changes, the first function argument will re-run.
   > Therefore, the side effect code/function goes in as the first argument of the useEffect() Hook. You would specify your dependencies of your side effect function as the second argument. Therefore, the first argument will only execute when your second argument dependencies changes.
   > This prevents any infinite loops from occurring.

------------------------------------------------------------------------------------
2. Using the useEffect() Hook:
------------------------------------------------------------------------------------
   > When using State a variable is being managed by React behind the scenes. The nature of this means that when you reload the application the entire script restarts and all variables from the last execution are lost. This is how the web and scripts within the browser works and is nothing React specific.
   > It would be nice to store certain information somewhere where that data persists the reload for example a login details so that the user does not have to re-log back in when the page refreshes (provided the login details has persisted).
   > This is one such scenario where you would use the useEffect() Hook.
   > The browser has multiple storages you can use such as cookies or local storage which are built into the browser and independent from React (Note: typically you would use some sort of database to store data).

   useEffect() Hook without Dependencies Example:
      src/App.js:
         import React, { useState, useEffect } from 'react';
         function App() {
            const [isLoggedIn, setIsLoggedIn] = useState(false);
            useEffect(() => {
               const storedUserLoggedInInformation = localStorage.getItem('isLoggedIn');
               if(storedUserLoggedInInformation === '1') {
                  setIsLoggedIn(true);
               };
            }, []);
            const loginHandler = (email, password) => {
               localStorage.setItem('isLoggedIn', '1');
               setIsLoggedIn(true);
            };
            const logoutHandler = () => {
               localStorage.removeItem('isLoggedIn');
               setIsLoggedIn(false);
            };
            return(...);
         };

   > To use the useEffect Hook you would need to import it from the 'react' library as a named import.
   > The function within the useEffect() Hook is executed by React after every Component re-evaluation and only if a change has occurred to the dependencies array.
   > Therefore, when the application runs for the first time the useEffect() Hook anonymous function will run for the first time because it is considered that the dependencies have changed i.e. no dependencies to some dependencies. However, after the first initial execution, the effectHook() will no longer run again (even on a Component re-evaluation) until a dependency has been detected to have changed.
   > This is the exact behaviour you would want to avoid any infinite loop.
   > The data-fetching is a side effect and is not directly related to the UI (although the result of fetching the data would be related to the UI).

------------------------------------------------------------------------------------
3. useEffect and Dependencies:
------------------------------------------------------------------------------------
   > In the previous section we seen an example of using the useEffect() Hook without any dependencies. However, often you would need dependencies because you do not want to run the anonymous useEffect() function once when the application first starts up but after every Component re-evaluation if a dependency has changed.

   Original ChangeHandler Functions without useEffect() Hooks:
      const emailChangeHandler = (event) => {
         setEnteredEmail(event.target.value);
         setFormIsValid(
            event.target.value.includes('@') && enteredPassword.trim().length > 6
         );
      };
      const passwordChangeHandler = (event) => {
         setEnteredPassword(event.target.value);
         setFormIsValid(
            event.target.value.trim().length > 6 && enteredEmail.includes('@')
         );
      };

   useEffect() Hook with Dependencies Example:
      src/components/Login/Login.js:
         import React, { useState, useEffect } from 'react';
         const Login = (props) => {
            const [enteredEmail, setEnteredEmail] = useState('');
            const [enteredPassword, setEnteredPassword] = useState('');
            const [formIsValid, setFormIsValid] = useState(false);
            ...
            useEffect(() => {
               setFormIsValid(
                  enteredEmail.includes('@') && enteredPassword.trim().length > 6
               );
            }, [setFormIsValid, enteredEmail, enteredPassword]);
            const emailChangeHandler = (event) => {
               setEnteredEmail(event.target.value);
            };
            const passwordChangeHandler = (event) => {
               setEnteredPassword(event.target.value);
            };
            ...
            render(...);
         };

   > In the above example, the useEffect() Hook with dependencies is used to control a setFormIsValid logic which are used by two separate functions (i.e. emailChangeHandler and passwordChangeHandler). Previously, the setFormIsValid would have been in both functions but with slight variations to the logic. Using the useEffect() Hook allows you to create one area for the logic and only trigger this function when the dependency changes.
   > There is a simple rule that you add as dependencies what is being used within your side effect anonymous function. In the above example you are using setFormIsValid function, enteredEmail state and enteredPassword state.
   > Not that when you reference a function as a dependency that you reference the pointer to the function and do not execute it using the round brackets at the end of the function name. If you executed the function (e.g. setFormIsValid()) then this would add the result of the function execution as the dependencies.
   > This tells React that after every Login Component function execution to re-run the useEffect() function only if either the setFormIsValid, enteredEmail or enteredPassword has changed since the last Component re-render cycle. If neither changed then the useEffect() function will not re-run.
   > Important Note: you could actually omit the setFormIsValid as a dependencies because the State updating functions by default are ensured by React to never change. Therefore, these State set functions are always going to be the same across re-render cycles, hence, you can omit them as a dependencies as seen below:
      useEffect(() => {
         setFormIsValid(
            enteredEmail.includes('@') && enteredPassword.trim().length > 6
         );
      }, [enteredEmail, enteredPassword]);

   > This demonstrates another use case where the useEffect() Hook shines. You can have one code in one place which re-runs whenever one of the dependencies change.
   > This is one such example where you would use the useEffect() Hook and it is not only for when a Component was created for the first time. It is equally common to use this feature to re-run logic when certain data (typically some State or Props) has changed.
   > One aspect of the above example that can be confusing here is that in this useEffect example you are not working with localStorage, sending HTTP request, setting a timer, etc. Instead, you are updating the React State. This can be contradictory to what was mentioned in 1. What are 'Side Effects' & Introducing useEffect.
   > To clear this confusion, you must not forget that it is called useEffect and it has one main job which is to handle side effects. Often side effects are HTTP requests, setting a timer, etc.
   > But it is a side effect if you listen to every keystroke and save that entered data which you then you would want to trigger another action in response to that. Thus, checking and updating the form validity in response to a keystroke within a field is also something you can call a side effect i.e. it is a side effect of the user entering data.
   > Using this logic should not confuse you when you use sideEffect as seen in the above example.
   > The useEffect() Hook in general is a very useful Hook that helps you with code that should be executed in response to something (and that something could be a Component being loaded, input fields updated, etc. - i.e. it could be anything whenever you have an action that should be executed in response to some other action then that is a side effect).

------------------------------------------------------------------------------------
4. Dependencies Rules and Exceptions:
------------------------------------------------------------------------------------
   > You learned, that you should add "everything" you use in the effect function as a dependency - i.e. all state variables and functions you use in there.
   > There are a few exceptions you should be aware of:
      - You do not need to add state updating functions because React guarantees that those functions never change; hence, you do not need to add them as dependencies (although you could without any issues).
      - You also do not need to add "built-in" APIs or functions like fetch(), localStorage etc (functions and features built-into the browser and hence available globally). These browser APIs / global functions are not related to the React component render cycle and they also never change.
      - You also do not need to add variables or functions you might have defined outside of your components (e.g. if you create a new helper function in a separate file). Such functions or variables are also not created inside of a Component function; hence, changing them would not affect your Components (the Components would not be re-evaluated if such variables or functions change and vice-versa).
   > To conclude, you must add all "things" you use in your effect function if those "things" could change because your Component (or some parent component) re-rendered. That is why Variables or State defined in Component functions, Props or Functions defined in Component Functions have to be added as dependencies.

   Dependencies Rules Demonstration Example:
      import { useEffect, useState } from 'react';
      let myTimer;
      const MyComponent = (props) => {
         const [timerIsActive, setTimerIsActive] = useState(false);
         const { timerDuration } = props; // using destructuring to pull out specific props values
         useEffect(() => {
            if (!timerIsActive) {
               setTimerIsActive(true);
               myTimer = setTimeout(() => {
               setTimerIsActive(false);
               }, timerDuration);
            };
         }, [timerIsActive, timerDuration]);
      };

   > The timerIsActive is added as a dependency because it is a Component State that may change when the Component changes (e.g. because the state was updated).
   > The timerDuration is added as a dependency because it is a Prop value of that Component. So it may change if a parent Component changes that value (causing the MyComponent Component to re-render as well).
   > The setTimerIsActive is not added as a dependency because it is one of the exception rule. The State updating functions could be added but does not need to be added since React guarantees that the functions themselves never change.
   > The myTimer is not added as a dependency because it is not a Component-internal variable (i.e. not some State or a Prop value). It is defined outside of the Component and changing it (no matter where) would not cause the Component to be re-evaluated.
   > The setTimeout is not added as a dependency because it is a built-in API (built-into the browser). Thus, it is independent from React and your Components and does not change.

------------------------------------------------------------------------------------
5. Using the useEffect Cleanup Function:
------------------------------------------------------------------------------------
   > Sometimes you may need a side effect to perform some cleanup work.
   > For example, you may need to send a HTTP request to some backend where you check if a username is already in use. If you had a useEffect() that runs on every keystroke this would end up sending unnecessary HTTP requests (network traffic) to your backend. This is something you would want to avoid.
   > Alternatively, you may not want to listen to every keystroke to check the validation of an input field. Instead, you might want to collect a certain amount of keystrokes or simply wait for a pause of a certain time duration after a keystroke and only if the pause is long enough then you would perform the operation/function. This is technique is known as debouncing.
   > You would want to debounce a user input and ensure that you are doing something on every keystroke. This can be achieved with the inbuilt browser setTimeout() function.

   Debouncing Example:
      useEffect(() => {
         const identifier = setTimeout(() => {
            console.log('Checking for Validity');
            setFormIsValid(
               enteredEmail.includes('@') && enteredPassword.trim().length > 6
            );
         }, 500);

         return () => {
            console.log('CLEANUP');
            clearTimeout(identifier);
         };
      }, [enteredEmail, enteredPassword]);
   
   > The above would not do much other than delay the side effects validation output by 500 milliseconds.
   > The trick is to save the timer and for the next keystroke you would clear it so that you only have one ongoing timer at a time. Therefore, only the last timer would complete. Therefore, as long as the user keeps typing you would always clear other timers leaving just the one timer to complete after 500 milliseconds.
   > Within the useEffect() Hook, the first argument/parameters passed in can return something. This must be one specific thing i.e. a function itself.
   > This can be a named or anonymous function.
   > Returning an anonymous function (as seen in the above) which is known as a cleanup function. This cleanup function will run as a cleanup process before the useEffect() Hook executes the function next time.
   > In the above example, the useEffect() Hook for the first time will run the setTimeout function. On every re-evaluation of the Component file, the anonymous cleanup function will run before the execution of the side effect function. Additionally, the anonymous cleanup function would run whenever the Component, that specifies the effect within, unmounts from the DOM.
   > Remember: setTimeout and clearTimeout are both browser functions and has nothing to do with React.
   > You will notice that the 'CLEANUP' console log will be printed before the 'Checking for Validity' console log message (after the first execution the useEffect() Hook) which clearly demonstrates that the cleanup function runs before the actual side effect function after the first initial execution.

------------------------------------------------------------------------------------
6. Introducing useReducer() Hook and Reducers in General:
------------------------------------------------------------------------------------
   > The useReducer() Hook is another built-in Hook which helps with State Management.
   > This is similar to the useState() Hook but with more capabilities and is especially useful for more complex State (e.g. multiple states, multiple ways of changing the state or dependencies to other states).
   > The useState() then often becomes hard or error-prone to use and manage. It then becomes easy to write bad, inefficient or buggy code in such complex state scenarios.
   > The useReducer() is an alternative i.e a replacement for useState() if you need a "more powerful state management".
   > This does not mean that you should always use useReducer() over useState(). This is because the useReducer() while powerful is also more complex to use and setup and may not be suitable for certain simple state cases.
   > Below is an example of when the useReducer() Hook is a better fit for the scenario:

   const Login = (props) => {
      const [enteredEmail, setEnteredEmail] = useState('');
      const [emailIsValid, setEmailIsValid] = useState();
      const [enteredPassword, setEnteredPassword] = useState('');
      const [passwordIsValid, setPasswordIsValid] = useState();
      const [formIsValid, setFormIsValid] = useState(false);
      ...
   };

   > In the above you can see that a lot of state snapshot are being managed in one Component. Furthermore, there are some related states such as the entered value and the validity of the entered value and finally the overall form validity. Thus, it can be argued overall the above is one big state that describes the overall form state.
   > Alternatively, you would treat each form input as one single entity and one state which simply has two aspects of value and validity of that input.
   > It becomes clear in this example that you have some work to do and there are some redundancy if you consider the fact that you are setting the overall form validity by checking the validity of each input but also checking validity on the input handlers.

   Original ChangeHandler Functions without useEffect() Hooks:
      const emailChangeHandler = (event) => {
         setEnteredEmail(event.target.value);
         setFormIsValid(
            event.target.value.includes('@') && enteredPassword.trim().length > 6
         );
      };
      const passwordChangeHandler = (event) => {
         setEnteredPassword(event.target.value);
         setFormIsValid(
            event.target.value.trim().length > 6 && enteredEmail.includes('@')
         );
      };

   > Using the original version to handle the change event not only causes redundancy in repeat code; however, it can cause another problem where the setFormIsValid state relies on a snapshot of two other states.
   > We have previously learned that when you want to update some state on some older state that you should use the function form. However, this can only work if your next state update depends on the previous state snapshot of the same state. However, in the above example, it relies on two other snapshots of different state i.e. enteredEmail and enteredPassword and not the last snapshot of setFormIsValid.
   > In the above example, it is doing something that you should not do because of the way React schedules State updates. This could lead to a bug in a rare scenario where the setEmailIsValid function runs before the setEnteredEmail or setEnteredPassword was processed.
   > This is a good example of a scenario when you can use useReducer() Hook for managing state that belong together and/or if you have state updates that depends on other state.
   > It is always a good choice to use useReducer() Hook where you update a state which depends on another state. But note that it can also be managed without a useReducer() Hook by managing both the input and validity within one useState() rather than two separate states.