Handling Side Effects, Using Reducers & Using the Context API - Summary:
1. What are 'Side Effects' & Introducing useEffect
2. Using the useEffect() Hook

------------------------------------------------------------------------------------
1. What are 'Side Effects' & Introducing useEffect:
------------------------------------------------------------------------------------
   > Effects are sometimes refferred to as 'Side Effects' and the terms can be used interchangeably.
   > The React Library, Components and the React application as a whole has one main job which is to render the UI and react to user inputs.
   > We can say React is used to manage the following:
      - Evaluates and renders JSX
      - Manage State and Props
      - React to (User) Events & Input
      - Re-evaluate Component upon State & Prop Changes
   > All the above are "baked into" React via the "tools" and features that we have analysed within the Basic & Foundations Sections (i.e. useState(), Hooks, Props, etc.)
   > Side Effects are anything else that may be occuring within your application (other than those mentioned above).
   > For example: storing data in Browser Storage, sending HTTP Requests to the Backend Servers, Setting and Managing Timers, etc.
   > All these tasks are not related to bringing something onto the screen (at least not directly).
   > React does not care about Side Effect and is not what React was built for i.e. React only cares about drawing domething directly to the screen (front-end).
   > Tasks that must happen outside of the normal Component evalution and render cycle (especially since they might block/delay rendering e.g. HTTP requests) are known as Side Effects (back-end).
   > Side Effects should not go directly into a Component function because it would most likely create bugs, infinate loops or simply send too many HTTP requests to the server.
   > For example: You have an App Component which is re-executed by React automatically whenever e.g. the State within the Component function changes e.g. a isLoggedIn state. When the Component re-executes, React will check what the new result of the function execution should look like and compares with the Real DOM to make the changes rendered onto the screen. If you would send a HTTP request directly within the Component, this request would be sent whenever the function re-runs i.e. re-evaluates. This might sometimes be what you would want but not necessarily always. However, this could also create an infinate loop i.e. you send a request whenever the function re-runs and in response to the request you change some state which triggers the function re-evaluation. Therefore, such 'Side Effects' should not go directly into the Component function for the issues mentioned in the point above.
   > The useEffect() Hook is another built-in Hook i.e. function that you can use inside of your Component function that would do something special.

   The useEffect() Hook Example:
      useEffect(() => {...}, [dependencies]);

   > The useEffect() Hook function is called with two arguments/parameters. 
   > The first argument is a function that should be executed AFTER every Component evaluation IF the specified dependencies change.
   > The second argument is the specified dependencies that you would pass in. This is an array full of dependencies and whenever such a dependency changes, the first function argument will re-run.
   > Therefore, the side effect code/function goes in as the first argument of the useEffect() Hook. You would specify your dependencies of your side effect function as the second argument. Therefore, the first argument will only execute when your second argument dependencies changes.
   > This prevents any infinate loops from occuring.

------------------------------------------------------------------------------------
2. Using the useEffect() Hook:
------------------------------------------------------------------------------------
   > When using State a variable is being managed by React behind the scenes. The nature of this means that when you reload the application the entire script restarts and all variables from the last execution are lost. This is how the web and scripts within the browser works and is nothing React specific.
   > It would be nice to store certain information somewhere where that data persists the reload for example a login details so that the user does not have to re-log back in when the page refreshes (provided the login details has persisted).
   > This is one such scenario where you would use the useEffect() Hook.
   > The browser has multiple storages you can use such as cookies or local storage which are built into the browser and independent from React (Note: typically you would use some sort of database to store data).

   Login useEffect() Hook Example:
      import React, { useState, useEffect } from 'react';
      function App() {
         const [isLoggedIn, setIsLoggedIn] = useState(false);
         useEffect(() => {
            const storedUserLoggedInInformation = localStorage.getItem('isLoggedIn');
            if(storedUserLoggedInInformation === '1') {
               setIsLoggedIn(true);
            };
         }, []);
         return(...);
         const loginHandler = (email, password) => {
            localStorage.setItem('isLoggedIn', '1');
            setIsLoggedIn(true);
         };
         const logoutHandler = () => {
            localStorage.removeItem('isLoggedIn');
            setIsLoggedIn(false);
         };
      };

   > To use the useEffect Hook you would need to import it from the 'react' library as a named import.
   > The function within the useEffect() Hook is executed by React after every Component re-evaluation and only if a change has occurred to the dependencies array.
   > Therefore, when the application runs for the first time the useEffect() Hook anonymous function will run for the first time because it is considered that the dependencies have changed i.e. no dependencies to some dependencies. However, after the first initial execution, the effectHook() will no longer run again (even on a Component re-evaluation) until a dependency has been detected to have changed.
   > This is the exact behaviour you would want to avoid any infinite loop.
   > The data-fetching is a side effect and is not directly related to the UI (although the result of fetching the data would be related to the UI).