Sending HTTP Requests: Connecting a Database - Summary:
1. How Not to Connect to a Database and Introduction to APIs
2. Sending a GET Request
3. Using Async/Await
4. Handling Loading & Data States

------------------------------------------------------------------------------------
1. How Not to Connect to a Database and Introduction to APIs:
------------------------------------------------------------------------------------
   > Browser-side code (i.e. Client Side Code) should never directly talk to a database.
   > You may have a database (SQL, NoSQL, ...) running on a database server which you might want to fetch and store some data and therefore might want to establish a connection between your React Application and the Database Server; however, that is something you should never do (and will never see this will real world application, unless it is a highly insecure and poorly written application).
   > If you directly connected to a database server from inside of your client-side JavaScript code, you will expose your database credentials to the public. All JavaScript code running in the browser can be accessed and read not just by the browser but also by the users of your web application (i.e. accessible via the Browser's Developer Tools). You can view this article on this: https://academind.com/tutorials/hide-javascript-code/.
   > Directly connecting to a database servers can bring other issues such as performance issues but the security problem is the biggest problem of all.
   > You would always take a different route. You should have a backend application running on another machine/server (not running on the browser). This can be on the same server as the database but is often on a different server.
   > The backend server can be written with any server-side language of your choice (e.g. NodeJS, PHP, ASP.NET, etc.) and it is this backend server that will do the talking to the database. This is because you can safely store and use database credentials on the backend application since that backend code cannot be viewed by your users. This is because it is on a different server and users of your website will never see that code.
   > Thus, React will then talk to that backend server (i.e. to the backend API typically - a server which exposes different URLs which requests can be sent to) which allows you to have a safe connection to the database.
   > Throughout this section we will use the Start Wars API (https://swapi.dev/) to explore how to send HTTP requests in React application. This is an API (i.e. a backend app) and not a database. Behind the scenes it probably uses some database to store some data about the Star Wars movies, but we as the user interact with this backend app.
   > API stands for Application Programming Interface. This is a very broad term and not just related to React and HTTP requests. In the end it means that in our code we are dealing with something which has a clearly defined interface/rules on how we can achieve certain results and perform certain tasks.
   > When we talk about APIs in the context of HTTP requests, we typically talk about "REST" or "GraphQL" APIs. These are two different standards for how a server should expose its data.
   > The Start Wars API uses a "REST API" which means it exposes a couple of URLs (e.g. 'https://swapi.dev/api/people/1') to which you send that request to get back data in a certain format. Different URLs to which you send different requests will give you different chunks of data. This is what makes it an API. You have different entry points which lead to different results.
   > You can read this article to learn more about APIs ad what they are: https://academind.com/tutorials/rest-vs-graphql/.

------------------------------------------------------------------------------------
2. Sending a GET Request:
------------------------------------------------------------------------------------
   > A React application at the end of the day is regular JavaScript code. Therefore, you can use any send HTTP requests in JavaScript solutions you want. For example, you can use the Axios library or the built-in Fetch API.
   > The Fetch API is built into browsers and allows us to fetch data and also to send data (even though the name does not imply it). We can use this API to send HTTP Requests and work with with responses.

   Fetch API code Example:
      src/App.js:
         function App() {
            function fetchMoviesHandler() {
               fetch('https://swapi.dev/api/films/').then(
                  response => { return response.json(); }
               ).then(
                  data => { setMovies(data.results); }
               );
            };
            return (
               <React.Fragment>
                  <section><button onClick={fetchMoviesHandler}>Fetch Movies</button></section>
                  <section><MoviesList movies={movies} /></section>
               </React.Fragment>
            );
         };

   > In the above example, we would create our own function. Within the function body we can use the 'fetch()' method. The browser makes the 'fetch()' function available to us.
   > In its simplest form, as the first argument/parameter, we only need to pass in the URL to which you want to send a HTTP request to as a string.
   > The second optional argument/parameter that can be passed into the 'fetch()' function is a JavaScript object. This object allows you to configure various options for the request e.g. adding an extra headers, body or change the HTTP request method. The default method is GET.
   > The GET request method sends a request to the URL link to retrieve data from that server.
   > The fetch() method returns a promise which then allows us to react to the returned HTTP response or any potential errors that you may receive.
   > A promise is an object which will eventually yield some data (instead of immediately providing the data) because sending a HTTP request is a asynchronous task. This means that the task could take a couple of seconds or milliseconds to complete (or fail).
   > Therefore, you cannot continue to execute the next line of code and use the result immediately, instead the result will be there at some point in the future. This is why promises exist for in JavaScript. You would use the '.then()' onto the function that will be called whenever we get a response.
   > The '.catch()' can be added to handle any potential errors (e.g. 'fetch('https://swapi.dev/api/films/').then(...).catch(...)').
   > We would use an arrow function inside of the .then() promise which receives the response object as an argument/parameter. We can then do anything we want with the response within the callback function body. The response object contains a bunch of data about the response such as the response headers, status code, etc.
   > The Star Wars API returns back a response body which is formatted as a JSON format. JSON is a very popular data format for exchanging data. JSON stands for JavaScript Object Notation and as its name suggest the data is formatted as a JavaScript Object using key:value pairs for each data property. Note that there are no methods but purely data.
   > The advantage of JSON data is that it is very easy to translate it to JavaScript objects. However, there is a translation step required to transform the JSON data. The response object has a built-in method for automatically translating JSON responses body to a real JavaScript object which you can use in your code. You would use the '.json()' method.
   > The '.json()' method itself returns a promise and therefore you should return the promise and then add another .then() .catch() block which will be fired once the data transformation has completed.
   > After the JSON transformation, you will receive the 'data' object as an argument/parameter to the '.then()' promise which you can use in your JavaScript code within the callback function body.
   > In the above example we use the 'data.results' (the API has a results key with a value of an array of movies) to store the information within some state which can then be used to display the array of movies.
   > To make everything work you would add the "fetchMoviesHandler" function to an event such as the 'onClick' event of the "Fetch Movies" button.

   https://swapi.dev/api/films/ Response Example:
      GET /api/films/
      HTTP 200 OK
      Content-Type: application/json
      Vary: Accept
      Allow: GET, HEAD, OPTIONS
      {
      "count": 6, 
      "next": null, 
      "previous": null, 
      "results": [
         {
               "title": "A New Hope", 
               "episode_id": 4, 
               "opening_crawl": "It is a period of civil war.\r\nRebel spaceships, striking\r\nfrom a hidden base, have won\r\ntheir first victory against\r\nthe evil Galactic Empire.\r\n\r\nDuring the battle, Rebel\r\nspies managed to steal secret\r\nplans to the Empire's\r\nultimate weapon, the DEATH\r\nSTAR, an armored space\r\nstation with enough power\r\nto destroy an entire planet.\r\n\r\nPursued by the Empire's\r\nsinister agents, Princess\r\nLeia races home aboard her\r\nstarship, custodian of the\r\nstolen plans that can save her\r\npeople and restore\r\nfreedom to the galaxy....", 
               "director": "George Lucas", 
               "producer": "Gary Kurtz, Rick McCallum", 
               "release_date": "1977-05-25", 
               ...
         }

   Fetch API Mapped Data Example:
      function fetchMoviesHandler() {
         fetch('https://swapi.dev/api/films/').then(
            response => { return response.json(); }
         ).then(
            data => {
               const transformedMovies = data.results.map(
                  movieData => {
                     return {
                        id: movieData.episode_id,
                        title: movieData.title,
                        openingText: movieData.opening_crawl,
                        releaseDate: movieData.release_date 
                     };
                  }
               );
               setMovies(transformedMovies);
            }
         );
      };

   > Important Note: You would need to ensure that you format the data in your React application to either a) match the same property names of the JSON response object or b) transform the incoming data from the response object to match the format of your react application code.
   > For example, the Start Wars API has a property called "opening_crawl" and "release_date" so either the react application uses those property name in its code or transforms the incoming data to use "openingText" and "releaseDate" instead. The above example demonstrates the latter method being used.
   > The .map() method allows you to convert every object in the results array into a new object. It is then the new object which will be stored in the "transformedMovies" variable. We can use the "movieData" object (note: this argument/parameter could have been named anything you want) and extract the id, title, opening text and release date informations (i.e. the data interested in) into a new object.
   > You will now see that the React application initially has no movies, but when you click on the "Fetch Movies" button, the HTTP request will be sent and the response will be used to populate the list of Star Wars movies that is received from the Star Wars APIs response. It will take a short while but the data will be populated from the GET request.
   > This in a nutshell is how you would send a HTTP request to connect within a React Application to connect securely to a backend e.g. a backend database.

------------------------------------------------------------------------------------
3. Using Async/Await:
------------------------------------------------------------------------------------
   > Promises are nothing React specific. Promises are a JavaScript language feature.
   > When working with promises you can easily build up '.then' and '.catch' chains which can make the code harder to read or cause unexpected bugs within your code.
   > The alternative syntax you could use async/await which is a syntactical sugar but allows you to write asynchronous code i.e. promises without the need of using the nested '.then()' and '.catch()' calls. JavaScript behind the scenes will convert the async/await code into the traditional promise using '.this()' and '.catch()' blocks.

   Async/Await Promise Syntax Example:
      async function fetchMoviesHandler() {
         const response = await fetch('https://swapi.dev/api/films/')
         const data = await response.json();
         const transformedMovies = data.results.map(
            movieData => {
               return {
                  id: movieData.episode_id,
                  title: movieData.title,
                  openingText: movieData.opening_crawl,
                  releaseDate: movieData.release_date 
               };
            }
         );
         setMovies(transformedMovies);
      };

   > Simply add the 'async' keyword before the function name.
   > You would then use the 'await' keyword on the operation which is returning a promise for example like the '.fetch()' function.
   > The 'await' function can be stored in a variable and you can use the variable's response from the 'await' promise to perform your code logic with the response data.
   > The .json() is a promise so you would also add the 'await' keyword again to await the response of that promise which we can store in a variable (e.g. data).
   > The code is much more cleaner and easy to read using the Async/Await syntax for handling promises. The code continues to be asynchronous code.
   > This is not React specific but a default JavaScript feature.

------------------------------------------------------------------------------------
4. Handling Loading & Data States:
------------------------------------------------------------------------------------
   > Typically, you would want to show some loading spinner or at least some loading text while the HTTP request is being issued to signal to your users that data is on its way and the application is doing some work.
   > How would we manage this in the React world? In the end it is all about managing state.
   > To tell whether we are waiting or not for some data, you can introduce a state for this. The below example continues to build on from the previous example to demonstrate.

   Loading State Example:
      function App() {
         ...
         const [isLoading, setIsLoading] = useState(false);
         async function fetchMoviesHandler() {
            setIsLoading(true);
            const response = await fetch('https://swapi.dev/api/films/')
            const data = await response.json();
            const transformedMovies = data.results.map(
               movieData => {
                  return {
                     id: movieData.episode_id,
                     title: movieData.title,
                     openingText: movieData.opening_crawl,
                     releaseDate: movieData.release_date 
                  };
               }
            );
            setMovies(transformedMovies);
            setIsLoading(false);
         };
         return (
            <React.Fragment>
               <section><button onClick={fetchMoviesHandler}>Fetch Movies</button></section>
               <section>
                  {!isLoading &&  movies.length > 0 && <MoviesList movies={movies} />}
                  {!isLoading && movies.length === 0 && <p>No Movies Found.</p>}
                  {isLoading && <p>Loading...</p>}
               </section>
            </React.Fragment>
         );
      };

   > Using the isLoading state which is initially set to false, within the "fetchMoviesHandler" function we could set the value to that state to true. This will change the state when we start to load. Once we are done loading the data you would want to set the state back to false.
   > Using this state you can now display a load spinner Component or some loading text to the screen.
   > It is important to note that loading is not the only state you might have. You might also want to show a different content if you are not loading but there are no movies within the list at the moment (i.e. movies is an empty array with nothing to display). The '!isLoading &&  movies.length > 0 &&' performs this check and will conditionally display the list if the movies array is greater than 0 items.
   > You can have a fallback content if there are no content to be displayed (e.g. '{!isLoading && movies.length == 0 && <p>No Movies Found.</p>}').
   > This is a crucial part of building User Interfaces. You would want to let your users know what state the application currently has (i.e. there is a difference between no movies, loading and there are movies).