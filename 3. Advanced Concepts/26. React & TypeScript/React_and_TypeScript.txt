React & TypeScript - Summary:
1. What is TypeScript and How to Install TypeScript
2. Exploring TypeScript Types
3. Creating a React & TypeScript Projects
4. Working with Components/Props & TypeScript
5. Adding a Data Model
6. Form Submissions in TypeScript Projects

------------------------------------------------------------------------------------
1. What is TypeScript and How to Install TypeScript:
------------------------------------------------------------------------------------
   > TypeScript is a so-called 'superset' to JavaScript. It is a programming language which builds upon and extends JavaScript.
   > The core programming language remains as JavaScript. Therefore, the base JavaScript syntax you know how to write does not change. TypeScript adds more features to the JavaScript syntax.
   > Unlike React, TypeScript is not a library for JavaScript i.e. it does not use JavaScript features to build on top of them i.e. build functionality around them. Instead, it extends the core JavaScript syntax.
   > Most importantly, TypeScript adds static typing to JavaScript and where its name comes from.
   > JavaScript on its own is a dynamically typed language.

   JavaScript Dynamically Types Language Code Snippet Example:
      addFunction.js:
         function add(a, b) {
            return a + b;
         };
         const result = add(2, 5);
         console.log(result);

   > The above JavaScript code is standard JavaScript which prints the sum of two passed in numbers as argument/parameters to the function.
   > JavaScript knows the concept of types and has types. In the above example the two values passed into the "add" function are a type number. This is something JavaScript knows on its own without TypeScript. The important thing is that JavaScript is dynamically typed. This means that the function does not expect any particular types but that it will receive two argument/parameters. Therefore, it is not statically typed.
   > Statically Typed means that the values are announced ahead of time.
   > JavaScript will take whatever it receives and tries to execute the code and the code happens to execute perfectly fine with numbers.
   > However, you will also notice that the above function would also work with strings passed as argument/parameters for example "add('2', '5')" will return "25" as a string instead of the expected 7 as a number. This is because the plus operator in JavaScript now does not add the two numbers in a mathematical way but instead joins/concatenates the two strings together.
   > This demonstrates why JavaScript alone is OK and great but also why JavaScript alone may not always be the best and why having Static Typing could enhance your code and prevent errors such as the above example from occurring.
   > Therefore, in bigger projects with lots of code files and potentially a lot of people working on the code base, you may sometimes call a function or use an object in an unintended way and run into the problem as demonstrated above because nothing is warning you that it is not how you should be using the function or object.
   > This is where TypeScript can help you as a developer.

   TypeScript Statically Typed Language Code Snippet Example:
      addFunction.ts
         function add(a: number, b: number) {
            return a + b;
         };
         const result = add(2, 5);
         console.log(result);

   > Note that TypeScript files have an extension of .ts to indicate the file uses TypeScript syntax.
   > With TypeScript you can add type annotations by simply adding a colon after the parameter followed by the type which should be used by the parameter.
   > You can use type annotations not only on function parameters but also in many other situations as well.
   > The IDE will highlight any errors in the code with a squiggly red underline whenever a Type definition is not being followed. This allows you to catch any errors (any unintended use of a function or object) before you run and test the code, for example, providing a string to a parameter which expected a number type as the value.
   > This allows you to write better code at the end of the day by avoiding such errors and you do not need to track them at runtime because you see such errors when you start writing code.
   > This is the main positive reason for using TypeScript.
   > You can see TypeScript being a pre-compiler to JavaScript like SASS/SCSS is for CSS.

   Installing TypeScript:
   > Now that you know what TypeScript is and how the syntax generally look like, how do you install and use TypeScript?
   > The official webpage for TypeScript can be found on https://www.typescriptlang.org/ where you can learn more about TypeScript and its features as a language as well as how to install TypeScript.
   > Run the following command to instal TypeScript locally on your machine. You would need NodeJS and NPM installed on your machine first before running the command:

      $: npm install typescript

   > Running the command while in a project directory in the terminal will install TypeScript to a specific project.
   > To install TypeScript globally you would need to add the -g (global) flag before typescript (i.e. $: npm install -g typescript).
   > Often installing TypeScript into a specific project is enough so that TypeScript can be used in that project.
   > This will create a standard TypeScript Project (note not a React project).
   > Now that TypeScript has been installed, you can invoke the TypeScript Compiler. This is super important because as you have learnt TypeScript is a superset to JavaScript extending the JavaScript syntax.
   > It is important to note that TypeScript code does not run in the browser i.e. executing TypeScript code in the browser will fail. Thus, you need to compile TypeScript into regular JavaScript code which the browser understands.
   > During that compilation process, all the type annotations will be removed because JavaScript does not know those annotations. It is during the compilation step where you will be notified of the errors in addition to the notification you get with the IDE. Hence, the compilation step which will warn you of potential code problems if you have not spotted them already in the IDE warnings.
   > It is the compiled code that will then run in the browser at the end of the day.
   > To invoke the compiler you need to run the below command:

      $: npx tsc

   > The compiler will throw an error because it expects a TypeScript configuration file in the project folder that will tell TypeScript which files to compile and what version of JavaScript to compile to. We will dive into this configuration file later in more detail.
   > You can modify the terminal command to point at the particular TypeScript file (i.e. $: npx tsc addFunction.ts) and the compiler will create a '.js' file version of the '.ts' file that was compiled (i.e addFunction.js).
   > If there were Type errors in the TypeScript file, the compilation process will display these errors in the terminal. For example, if you used a string value instead of a number then this type error will be displayed. It will still create the compiled JavaScript file because this is the default behaviour i.e. it only warns you of the error but completes the compilation of the JavaScript file.

   Compiled TypeScript File to JavaScript File Example:
      addFunction.ts
         function add(a: number, b: number) {
            return a + b;
         };
         const result = add(2, 5);
         console.log(result);
      addFunction.js:
         function add(a, b) {
            return a + b;
         };
         var result = add(2, 5);
         console.log(result);

   > You will noticed the compiled JavaScript file code is almost exactly the same as the TypeScript file code but without the annotations. You will also notice that the result variable uses var and not const and this is because by default the TypeScript compiler compiles down to ES5 syntax which is recognised by much older web browsers. This can be something that can be overridden with the TypeScript Config file.
   > Therefore, you can continue to work in the TypeScript file and then compile it to run in the browser, you now have Static Type syntax which can help you against these types of errors.
   > We can now dive into the core features you need to know when working with TypeScript before exploring how you can use TypeScript with React.

------------------------------------------------------------------------------------
2. Exploring TypeScript Types:
------------------------------------------------------------------------------------
   TypeScript Types:
      1) Primitive Types:
         - number, string, booleans, null, undefined and symbols

         > To declare a type for a variable you simply add a colon after the variable name followed by the type. For example, 'let age: number' will define the "age" variable with a type of number. Whenever you assign a value to the variable, TypeScript will let you know in the IDE if the value voids the type definition for the variable.
         > Assigning a type number can include whole and floating point numbers i.e. decimals are included. This is because JavaScript treats numbers as any numerical value including decimal values.
         > You can assign a value when you declare a variable, for example, 'let age: number = 12' which will also work perfectly fine.
         > It is important to note that when declaring the type the type name must be in lower case letters i.e. 'number' and not 'Number'. If you used 'Number' this will not error but instead it actually points at the Number object in JavaScript. Therefore, use the lowercase name to point at the primitive type.
         > Number, Strings and Booleans are the core base primitive types you can assign to variables as well as functions parameters. Note that there are more places where you can set type definitions.
         > While you can set types of null and undefined, it is not too useful because whenever you later assign a value to a null/undefined variable, the IDE will error as it expects a null/undefined type. There is a slightly different way in which you can use null and undefined which we will see later.

      2) More Complex Types:
         - arrays and objects

         > To assign a type of an array you simply add opening and closing square brackets. For example, the type ': string[]' will declare an array of strings. You can do this for any other primitive values i.e. for an array of numbers and booleans.
         > To assign a type for an entire object, TypeScript out of the box without configuration is quite forgiving. By default it allows you to assign any values in a variable because it has a special any type. For example, 'let person' will by default have a type of any which will therefore allow you to set the variable as any value including an object i.e. 'person = { name: 'John', age: 32 }'.
         > Note that you can explicitly assign a type of any by using ': any' as the type definition. However, this is a fallback type you do not want to use because it defeats the purpose of using TypeScript. Using the type any takes you back to standard JavaScript.
         > To add a type of object and define the properties the object should have you would use opening and closing curly brackets. For example, ': { name: string, age: number }' will create a object type definition. In this example the properties are given a type definition as well.
         > Therefore, if you try to create an object that has a property not defined in the object definition then the IDE will throw and error as well as assignment the incorrect type for the particular property.
         > You can combine array and object definitions to create a more complex type definition. For example, ': { name: string, age: number }[]' will create an assignment of an array of such objects.
         > This allows you to get a little advanced by combining different TypeScript features and by combining different types.

      3) Function Types and parameters
         > When you work with function there are different places where types can be assigned.
         > One place where types can be assigned in functions are the parameters. Just as you can set types for variables you can also assign types to function parameters. For example:
            function add(a: number, b: number) {
               return a + b;
            };
         > You can also infer a type in the function. In the above add function example, the return value of the sum is inferred a type definition of a number. You can see this inference if you hover over the 'add' function name which the IDE will display the inferred type retuned from the function.
         > You could explicitly set the type definition for example, 'function add(a: number, b: number): number | string' will explicitly define the return type for the function to be a number or string. You should not do this if you do not have a reason for explicitly defining the function's return value type (Refer to the below about Type Inference and Union Types for an explanation as to why).
         > Function not only have inputs but it also has outputs; hence a function can have a return type definition.
            function printOutput(value: any) {
               console.log(value);
            };
         > A function which has not return any value from its codeblock (as demonstrated in the above example) has a special return type definition inferred called void. The type void is comparable to null and undefined but is only used in conjunction with functions. It simply means that the function never returns. Therefore, if you want to work with the returned value from that function, you would work with undefined.
         > This is the special void type definition to work with returned values from a function that does not returns anything.

   Type Inference:
      > Remember: Anything at the right side of a colon is a type assignment and not a assignment of a value which is usually a value on the right side of the equal sign.
      > Typically, in programming you would create a variable and immediately assign an initial value right away in one step. For example, 'let age = 20' will create a variable and assign a number value. If you try to assign a different value for example "twenty" as a string the IDE will throw an error even though you did not specify a type definition.
      > TypeScript uses its powerful feature of Type Inference. By default TypeScript tries to infer as many types as possible i.e. it tries to know which types are used where without you explicitly stating the type definition. Hence, allowing you to write less code.
      > You could set your type (e.g. 'let age: number = 20') but it is a little redundant. This is because if you immediately initialised a variable with a value, TypeScript will look at that value that was stored in the variable and then use that value type as an inferred type for the variable. Therefore, if you try to assign a different type thereafter you will receive an error.
      > It is good practice to embrace the type inference feature i.e. to not unnecessarily specify the type in addition. You can explicitly state the type but it is redundant code and more work from your side.

   Union Types:
      > Sometimes you would want to allow multiple different types to be assigned to a variable. It is not unrealistic that you could have a variable where both a string as well as a number should be allowed to be stored in that variable. The TypeScript feature of Union allows such type definition.
      > A Union Type is a type definition that allows more than one type to be assigned.
      > You would use a pipe symbol (|) after a type definition to add another type after the pipe. You can have as many types as you would like to allow as needed.
      > Therefore, where a variable has been immediately assigned a variable, it is OK to define the type (i.e. ignoring type inference) if the type is a Union. For example, 'let age: number | string = 20' will now allow both a number or a string to be assigned to the variable.
      > You can also use a Union anywhere where you have a type assignment and does not need to be used only when you use Type Inference.

   Type Aliases:
      > The more TypeScript code you write the higher the chances at some point you might be repeating some type definitions.
      > You can, of course, duplicate the type definition but it is more realistic that you want to avoid duplication. For example, you could type define an object and then use the same object but defined as an array of that object. To avoid this duplicate you can create a so called Type Alias.
      > Type Alias allows you to define your own base type in which a more complex type definition is stored and then use that type alias instead of repeating the entire type definitions.
      > You can create a Type Alias by using the 'type' keyword. This is a keyword provided by TypeScript and is not part of standard JavaScript. After the keyword you can choose any name of your choice which will become your new type name (i.e. an alias for your type definition). After the name you use an equal sign to define your type definition for the alias.
      > The equal sign is used because Type Alias is a pure TypeScript feature. This code will be thrown out of the window when the code is compiled to regular JavaScript code.

         type Car = {
            make: string,
            model: string,
            doors: number
         };
         let car1: Car;
         car1 = {
            make: 'BMW',
            model: '4 Series',
            doors: 5
         }
         let cars: Car[];

      > From the example above the type definition was defined once as a Type Alias and that alias could be used wherever that definition is required without repeating the type definition wherever it is needed. This feature can save you a lot of typing work and make your code more concise and easier to maintain by abiding to the DRY principal of programming.

   Generics:
         function insertAtBeginning(array: any[], value: any) {
            const newArray = [value, ...array];
            return newArray;
         };
         const demoArray = [1, 2, 3];
         const updatedArray = insertAtBeginning(demoArray, 0);

      > In the above example, there is a utility function called insertAtBeginning which takes an array of type any and a value of type any. This simply create a newArray inserting the value at the beginning of the array and returning the newArray as the value. However, you will notice that the updatedArray has an inferred type of any[] and not numbers[] even though the items are all numbers. Why is this?
      > The reason is because the array argument/parameter in the insertAtBeginning function has the type of any[] which is used to create the newArray which is returned and so the updatedArray will have an inferred type definition of any[] as well.
      > You could update the array parameter to have a type definition of number[] but this will remove the utility function being used with strings. Therefore, while you would need any[] as the type definition for the flexibility it also at the same time removes all kind of TypeScript support you might be getting after calling the function i.e. there is no good TypeScript support for the updatedArray thereafter.
      > For example, 'updatedArray[0].split('')' would not return an error in the IDE but you would get a runtime error instead because you cannot call split() on a number. TypeScript does not know that the first element in the array is a type number to throw that error in the IDE. To work around such issues you have a feature called Generics.
      > Generics allows you to convert a function into a Generic Function. The special syntax is to add angle brackets between the function name and the opening and closing round brackets. For example, 'function insertAtBeginning<T>(array: T[], value: T)'. Inside of the angle brackets you would define the Generic Type, typically defined with 'T' but the name of the identifier is entirely your choice.
      > This is not a standard JavaScript feature but rather a feature that can only be used in TypeScript.
      > The Generic Type will only be available inside of the function.
      > Therefore, TypeScript is now able to understand that it should look at the concrete values of the arguments/parameter that are being passed into the function and it can now correctly infer updatedArray to be an array of numbers to provide better TypeScript Support to the IDE.
      > The utility function can continue to be used flexibly with different array types and values, for example, 'const stringArray = insertAtBeginning(['b', 'c', 'd'], 'a')' would correctly infer stringArray with the type definition of an array of strings. This is because TypeScript would look at both the concrete array and value passed into the function both being a type of string and so will infer the return type to also be an array of string. The IDE can now warn the developer when the split() function is being used on an array containing numbers before the compilation stage.
      > Therefore, Generics allows you to write functions (in this case) which are type safe yet flexible. The function can work with any type but once a certain type is used for that function execution, that type is locked in and known by TypeScript. This allows you to get the best of both worlds of flexibility and type safety.

   A Closer Look at Generics:
      > Generic Types ("Generics") can be tricky to wrap your head around. But indeed, we are working with them all the time - one of the most prominent examples is an array. Consider the below example array:
         let numbers = [1, 2, 3];
      > Here, the type is inferred, but if we would assign it explicitly, we could do it like this:
         let numbers: number[] = [1, 2, 3];
      > The 'number[]' is the TypeScript notation for saying "this is an array of numbers". But actually, 'number[]' is just syntactic sugar!
      > The actual type is Array. All arrays are of the Array type... BUT, since an array type really only makes sense if we also describe the type of items in the array, Array actually is a generic type.
      > You could also write the above example like the below instead:
         let numbers: Array<number> = [1, 2, 3];
      > Here we have the angle brackets (<>) again! But this time NOT to create our own type (as seen in the previous first Generics example) but instead to tell TypeScript which actual type should be used for the "generic type placeholder" (i.e. 'T' in the previous example). As shown in the first example, TypeScript would be able to infer this as well - we rely on that when we just write:
         let numbers = [1, 2, 3];
      > But if we want to explicitly set a type, we could do it like this:
         let numbers: Array<number> = [1, 2, 3];
      > Of course it can be a bit annoying to write this rather long and clunky type, that is why we have this alternative (syntactic sugar) for arrays:
         let numbers: number[] = [1, 2, 3];
      > If we take the example from the previous first Generics example, we could have also set the concrete type for our placeholder T explicitly:
         const stringArray = insertAtBeginning<string>(['a', 'b', 'c'], 'd');
      > So we can not just use the angle brackets to define a generic type but also to USE a generic type and explicitly set the placeholder type that should be used - sometimes this is required if TypeScript is not able to infer the (correct) type.

   Conclusion:
   > There are more core TypeScript features but the above are the core TypeScript features you should know when working with TypeScript.
   > You can learn more on TypeScript and its features on the official website (https://www.typescriptlang.org/).

------------------------------------------------------------------------------------
3. Creating a React & TypeScript Projects:
------------------------------------------------------------------------------------
   > To use TypeScript with React Projects you need to have React Project configured to use TypeScript instead of vanilla JavaScript.
   > The great thing is that you can continue to use 'create-react-app' to create a new React Project. In the official documentation there is a documentation on how to integrate TypeScript (https://create-react-app.dev/docs/adding-typescript). If the link was to change you could always google "create-react-app typescript" and find the documentation page.
   > It is easy if you start a new project with TypeScript integration, although you do also get instructions on how you can add TypeScript to an existing project. The command to create a new project is:
      $: npx create-react-app [app-name] --template typescript
   > Running this terminal command will create a new React Application with TypeScript integration in the directory that the terminal was 'cd' to.
   > YOu can continue to use 'npm start' to spin up a dev server as you would normally would do. However, you now have a project directory all configured to work with TypeScript.
   > You should notice that you now have '.tsx' files instead of '.jsx' files which will indicate that you are now using TypeScript. The file extension is '.jsx' and not '.js' because React uses JSX syntax which will avoid any unnecessary IDE complaints. The code is exactly the same as before and nothing else special.
   > One thing to note with the dev server is that it now does one thing more behind the scenes than it did before. It is also compiling the TypeScript code to regular JavaScript code. The same would also occur if you were to build your code for production by running the 'npm run build' command.
   > The 'package.json' file has the same dependencies as before but with some extra dependencies; specifically 'TypeScript' as well as '@types/' dependencies. The 'TypeScript' package is the language/compiler for TypeScript installed in the project.
   > The extra '@types/' packages are extra but important packages. They act as translation bridges between vanilla JavaScript libraries and TypeScript projects. For example, the 'react' and 'react-dom' libraries are written for just JavaScript. In order to work with them in TypeScript (and get TypeScript and IDE support) you need translations between the raw vanilla JavaScript libraries and the TypeScript project i.e. extra type annotations that are added to these JavaScript libraries you could say. This is what '@types/react' and '@types/react-dom' packages provides.
   > Not all libraries need translations because some libraries actually already have built-in type annotations even though you can use them with just JavaScript as well. However, some libraries do need these extra annotations which is why there are some extra packages installed to provide the annotations for those libraries.
   > You can now write React code with TypeScript.

------------------------------------------------------------------------------------
4. Working with Components/Props & TypeScript:
------------------------------------------------------------------------------------
   Working with Components & TypeScript:
      > Generally you continue to write the same code as you did before i.e. nothing has changed. You will notice that the new project does not use any special type annotations because it does not need them. It is generally using TypeScript's built-in type inference feature. Simply the boilerplate starting code does not use a lot of Types. We can now explore where we can use TypeScript to enhance your react application code.

      Component TSX File Example:
         src/components/ToDos.tsx:
            function ToDos() {
               return(
                  <ul>
                     <li>Learn React</li>
                     <li>Learn TypeScript</li>
                  </ul>
               );
            };
            export default ToDos;

      > You continue to build React Components generally as you have learnt it. The above ToDos Component renders a unordered list with two hardcoded list items. The code is exactly the same as using standard JavaScript. It gets slightly more interesting when the Component receives props to output a dynamic list.

   Working with Props & TypeScript:
      Component with Prop TSX File Example:
         src/components/ToDos.tsx:
            function ToDos(props) {
               return(
                  <ul>{}</ul>
               );
            };
            export default ToDos;

      > When you add props as an argument/parameter to a Component you will see a red squiggly line appearing in the IDE. The description when hovered will read as "The prop is declared but its value is never read." and "Parameter 'props' implicitly has an 'any' type". This is a little extra help you would get from TypeScript of which you would not get with regular JavaScript projects.
      > The warning tells you that you have unnecessary code you are not using as well as the implicit type for the 'props' variable. TypeScript warns you that you should not make any implicitly assumptions. You can configure the strictness of TypeScript in the 'tsconfig.json' file. To remove this warning, you need to make it clear which kind of 'props' (i.e. the type of prop) you are getting in the Component function.
      > Therefore, you could assign a type like so 'props: {}' which will assign the props variable of a type object. We know objects have key:value pairs in which case you can assign the type of object you expect to receive for props e.g. 'props: { items: string[] }'. This will define 'props' as and object with an "items" key which then itself stores an array of strings as a value. However, this would not actually be 100% correct.
      > Remember: 'props' does not just have the key:value pairs you add on the Component when you use it in JSX. Instead, 'props' is an object which does have those key:value pairs but it also always has a special 'children' prop. You do not know the type of children yet. You could find out the type and then add it but this will quickly become cumbersome if for every component you are defining that is using props you have to always add those built in props to that object along with your custom props.
      > Since you have that base prop object which you get in every Component, React and TypeScript provides a different way of defining the type. You can use a Generic Type instead. To be precise a functional Component out of the box can be converted into a generic function. This simply means in the end your functional Component will be configured such that you make it clear that it will be a React Component Function and it will have all those base props like children and you can define explicitly you own props e.g. "items" which should be combined into the overall props object.
      > The example code can be written differently as shown below:

         const ToDos: React.FC<{items: string[]}> = (props) => {
            return(
               <ul>{props.children}</ul>
            );
         };

   > The Generic 'FC' Type makes it clear to TypeScript that this function is a function that acts as a functional Component. Depending on the project setup you might not need to import the 'React' package into the Component file to use the 'FC' Generic Type which stands for Functional Component. You will now see the IDE red squiggly lines disappear.
   > If you now use the 'props' object you should now see autocompletion with the children prop. By adding the FC Type annotations, TypeScript and your IDE understands your code is a function that receives a props object as the first argument which will be an object that always has a 'children' property.
   > Since FC is a Generic Type, it allows you to merge your own props the functional Component will get with those built-in base props like 'children'. Hence, you add the angle brackets after 'FC' and between those angle brackets you simply define your own props.
   > The angle brackets are used slightly different to how we have previously seen it with creating your own Generic Types. Here, there 'React.FC' is already a Generic Type (i.e. it describes a type defined by the React package) that is already generic. When you add an angle brackets after 'FC', you are not setting up a new Generic Type with some placeholder type e.g. 'T' but instead you are plugging in a concrete value for that internally used Generic Type (i.e. the type 'T' defined by the React.FC type).
   > You do this because you are not calling some generic function with some parameters where the values then could be used for the inference. Instead, you are defining a function and you want to let TypeScript know how it should then treat this function internally i.e. it should get some props defined by us and merge those with some base props like the 'children' prop which all functional Components have.
   > Therefore, here we are seeing that you use a Generic Type and you explicitly set the concrete type that should be used for this usage of this Generic FC Type. It is generic because different functional Components have different props definitions. Thus, this is how you define the type with React and TypeScript.
   > If you now type "props." in your IDE you should get autocompletion suggestion for the props object. In the above example you would see "children" and "items" as autocompletion suggestions for this props object. It will also tell the type for the items property which should be a string array. This is because your own prop object definition is merged with the base prop object definition.
   > This may seem all confusing to explain the internal workings, but using 'FC' is super simple. You build functional Component with React and TypeScript by using the React.FC Generic Type on your function Component constant. You then use the angle brackets and between those angle brackets you define your own 'props' objects type definition if your Component gets some custom props (omitting the angle brackets means there are no custom props to be merged with the base props object type definition). In the Component you can then use those custom props defined. You will get autocompletion by your IDE as TypeScript will know the types e.g. a prop which has a type of string array can use array methods such as '.map()'.

      src/components/ToDos.tsx:
         const ToDos: React.FC<{items: string[]}> = (props) => {
            return(
               <ul>{props.items.map(item => <li key={item}>{item}</li>)}</ul>
            );
         };
      src/App.tsx:
         import ToDos from './components/ToDos';
            function App() {
               return (
                  <div>
                     <ToDos />
                  </div>
               );
            };
            export default App;

   > The above is the final code for the ToDos Component with proper Type annotations i.e. this Component uses 'props' to dynamically set list items in the unordered list.
   > The great thing about using TypeScript with React is now not just that the code is more descriptive and you get the autocompletion when you work inside of the Component, but you also now see that you have errors in the App Component file which imports the ToDos Component. Due to the Type annotations, the project setup now understands that you are using the ToDos Component in an incorrect way.
   > The above makes it clear that the ToDos Component will have an items prop which holds a string array and that this prop is not optional. To make something optional you simply add a question mark before the colon (e.g 'items?: string[]'). However, if you do this you should also make sure to handle in your JSX the case that you do not necessarily have items if it is optional.
   > Therefore, if the prop is not optional this will indicate that the prop is required when being used as a Component in other files. This is another strong reason for using TypeScript in React projects. You can really describe the shape of your Components and which props they need and therefore using the Component incorrectly is pretty much impossible because you get errors like this directly in the IDE.

      src/App.tsx:
         import ToDos from './components/ToDos';
            function App() {
               return (
                  <div>
                     <ToDos item={['Learn React', 'Learn TypeScript']} />
                  </div>
               );
            };
            export default App;

   > To correct the error in the App.tsx file you would simply define the items prop in the ToDos Component e.g. "<ToDos item={['Learn React', 'Learn TypeScript']} />" which will create the list items dynamically in the Component. All errors should be gone and your project compiles a working React project files.
   > It is the above Type annotation you want to add to every custom Component you are building and if you are using your own props you add the 'FC' Generic Type and describe your custom props between the angle brackets which gets merged with the base props.

------------------------------------------------------------------------------------
5. Adding a Data Model
------------------------------------------------------------------------------------
   > When working in your project you may want to work with objects to describe your data modals. For example, in the previous example the todo is simply a string and a list of ToDos is an array of string. However, it is not unrealistic that every todo is an object e.g. an object with ID, todo text, title, subtitle and maybe more meta-data attached to the todo like author, created data, etc. There are endless ways to describe a todo item.
   > You could create a subfolder in the src directory called models to hold .ts files for your models. Note: that these are .ts file and not .jsx because the code holds JavaScript code and not a Component file. In the .ts file you can describe how the model should look like. Below is an example for the ToDo model.

   Adding a Data Model Example:
      src/models/todo.ts:
         class Todo {
            id: string;
            text: string;
            constructor(todoText: string) {
               this.id = Math.random().toString();
               this.text = todoText;
            };
         };
         export default Todo;
      src/components/ToDos.tsx:
         import Todo from '../models/todo';
         const ToDos: React.FC<{items: Todo[]}> = (props) => {
            return(
               <ul>{props.items.map(item => <li key={item.id}>{item.text}</li>)}</ul>
            );
         };
         export default ToDos;
      src/app.tsx:
         import ToDos from './components/ToDos';
         import Todo from './models/todo';
         function App() {
            const todos = [
               new Todo('Learn React'),
               new Todo('Learn TypeScript')
            ];
            return (
               <div><ToDos items={todos} /></div>
            );
         };
         export default App;

   > You can create your own object model type. You can do this using the 'type' keyword, 'interface' keyword or you can create a JavaScript class object which you can instantiate. The above example uses the class method but wither approach will work. You would create the object as you would using vanilla JavaScript.
   > In the object you would describe how the class object would look like. It is here where it would look different to how you would have done it using regular JavaScript. When working with TypeScript in classes, if your class has different properties/attributes which you want to add, you do not need to add it to the constructor() method as you would have in regular JavaScript. You can add them directly to the class object (similar to other programming languages like C#). The properties will receive types.
   > You would see some errors regarding the properties that they have no initialisers and not assigned in the constructor. This warning tells you that you are defining a class which is meant to be instantiated (which is the main idea behind classes in general) but those properties which you setup and describe and set the types never receives a value. To ensure that they do you would use the 'constructor()' method.
   > The constructor method could also want some arguments/parameters. Inside of the constructor you would set the properties defined in the class object. Therefore, whenever you create a new object from the class, the properties will get instantiated with a value, which removes the error.
   > You can then export the model class object definition which can now be used as your data model type definition in other files of your application.
   > The class object is nearly the same as you would create it in regular JavaScript but in TypeScript you need to define the properties outside of the constructor method i.e. ahead of time to make it clear which type of values will be stored in the properties.
   > You would instantiate the class object as you would in regular JavaScript. In the App.tsx you now have an array of ToDos but instead of having a string of todo you now have and array of todo objects.
   > The data model defined as a class also acts not just as a constructor function which you can call to create new objects but also as a type. You can use the class name as a Type definition. In the Component class above the ToDos is defined as a React Function Component which holds an items prop that has a type definition of an array of Todo class objects.
   > The visual output does not change from the previous example but the code has definitely changed. With all the the type annotations and classes being used in your project you are making it very clear which shape the data should have and which shape the Components should have. This simply allows you as a developer to ensure the code is clean and has a clear structure and it is way harder to misuse your Components or data. This also prevents errors from being made during development instead of at runtime when you test the application (i.e warnings are presented in the IDE rather than an error at some point when running the application). This is the benefit of using TypeScript.

------------------------------------------------------------------------------------
6. Form Submissions in TypeScript Projects:
------------------------------------------------------------------------------------
   > It is typical to have Forms within your React Projects to get user inputs. Below is an example code for a Form Component that uses TypeScript.

   Form Submissions in TypeScript Example:
      src/components/NewTodo.tsx:
         const NewTodo = () => {
            const todoTextInputRef = useRef<HTMLInputElement>(null);
            const submitHandler = (event: React.FormEvent) => {
               event.preventDefault();
            };
            return(
               <form onSubmit={submitHandler}>
                  <label htmlFor="text">Todo Text</label>
                  <input id="text" type="text" />
                  <button>Add Todo</button>
               </form>
            );
         };
         export default NewTodo;

   > There are two approaches for listening to user inputs i.e. listing to the keystroke event or using the useState Hook. The above example takes the former approach using a event handler function.
   > While you as the developer know that the 'event' argument will be an event object which is passed automatically when you connect the function to the appropriate event listener; however, TypeScript does not know of this event object. Therefore, you need to add a type annotation here.
   > Since you will add the function to the submit event through React (i.e. with the help of React's onSubmit property) the type definition for the event argument/parameter will be 'React.FormEvent'. This is a special type provided by the React package which is the even object type that is expected to be received automatically when listening to the form submission.
   > Note: 'React.MouseEvent' type definition would be used if you were listening to the 'onClick' event listener. If you used the 'React.MouseEvent' type definition for a function that was used for the 'onSubmit' event function, you will receive this error in the IDE to point this out to you. This is an extra check which will help catch errors before runtime of the application.

   Working with useRef & Ref in TypeScript Example:
      src/components/NewTodo.tsx:
         import { useRef } from 'react';
         const NewTodo = () => {
            const todoTextInputRef = useRef<HTMLInputElement>(null);
            const submitHandler = (event: React.FormEvent) => {
               event.preventDefault();
               const enteredText = todoTextInputRef.current!.value;
               if(enteredText.trim().length === 0) {
                  // throw and error
                  return;
               };
            };
            return(
               <form onSubmit={submitHandler}>
                  <label htmlFor="text">Todo Text</label>
                  <input id="text" type="text" ref={todoTextInputRef} />
                  <button>Add Todo</button>
               </form>
            );
         };
         export default NewTodo;

   > To extract information from a Form you would use reference and the 'useRef' Hook. First import the 'useRef' Hook from react and then define a variable that calls and stores the 'useRef' hook to create such a reference. You can then go to the HTML element to which you want to connect this reference (typically an input, text area, etc. element) and set the special 'ref' property on that element and point at the reference variable.
   > However, you will notice that you will receive an error in TypeScript that the 'ref' property is receiving the wrong type of data. The 'ref' property wants a reference created with the 'useRef' Hook which is not wrong. However, you are not explicit enough about the reference you are creating with the 'useRef' Hook.
   > In vanilla JavaScript the code would work because it does not have the concept of extra type annotations. When working with TypeScript, it wants to know a little bit more about your reference. When you create the reference variable, TypeScript has no idea that you will connect it to an input element. It is only clear in the JSX part of the code.
   > Since it is not clear when you create the reference, you could use the variable in any possible way and connect it to any HTML element and this is the error you would get from TypeScript.
   > To be explicit about the kind of data you would store in the reference variable that uses the useHook function you would use a Generic Type. The 'useRef' Hook is a Generic Type out of the box. You can add the angle brackets after 'useRef' to explicitly set the concrete type of reference you want to create for the instance it is being called.
   > The 'useRef' is able to work with all kinds of data which you could store in the reference (i.e. all kinds of HTML object you could connect with the reference) but you need to specify which concrete value or HTML element you plan on storing into this specific instance of the reference object you are creating.
   > The 'HTMLInputElement' is a built-in type. All DOM elements have built-in types which you can use in TypeScript to refer to them for type definition. Therefore, for input element you would define the type as 'HTMLInputElement', for a button element it's type definition would be 'HTMLButtonElement', for a paragraph element it would be HTMLParagraphElement and so on.
   > You can always visit the Mozilla Developer Network (https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input) document page for an element to find these types of information on HTML elements even though it has nothing to do with TypeScript. For example input elements are based on the 'HTMLInputElement' interface which is why you would use the built-in type definition of 'HTMLInputElement' for input elements in TypeScript.
   > You now need to set a default value fort the 'useRef' to remove the TypeScript error on 'ref' because the reference could already be assigned to some other element out of the box by default maybe? Therefore, you should always provide a starting value in the 'useRef' argument/parameter. At the beginning you have no connections; thus, the starting value should be 'null'. The error should now go away from the 'ref' property in the JSX.
   > This is how you create reference in TypeScript and connect it to an element via the special 'ref' property.
   > You can now use the 'ref' prop to retrieve the user input in your event function handler to listen to every keypress entered into the input element connected.
   > Due to TypeScript and specifically defining the type for the reference variable you now get great autocompletion in the IDE for the variable when used since TypeScript knowns that the useRef Hook instance returns a HTMLInputElement object.
   > Your IDE may add a question mark automatically after the ".current?." when calling a method. This is because the reference is not necessarily set to a value yet when you use it. Of course as a developer we know that when the "submitHandler" is called the "todoTextInputRef" will be connected to an element because the function can only be called when the form was submitted and the form can only be submitted after the 'ref' property was connected to the "submitHandler" function. However, theoretically you could also try to extract the value after defining the reference variable, in which case the reference would not be connected yet to an element. TypeScript does not deeply analyse your code i.e. the "submitHandler" can't technically be called before the connection has been established. Hence, the question mark addition signals to TypeScript that when it tries to access the method/property and it succeeds the value you would be stored but if the connection failed then 'null' will be stored.
   > If you as a developer know that at this point of time there will be a non-null value you can use an exclamation mark instead of a question mark (e.g. "todoTextInputRef.current!.value"). This special annotation tells TypeScript that you know that this possible nullish value will never be null in this spot. You should only use this annotation if you are 100% certain that the value cannot be null (i.e. the connection will be established).
   > The "enteredText" variable now has a inferred type of 'string' instead of 'string|undefined' (undefined is similar to a null value).
   > Important Disclaimer: The question mark and exclamation mark operators are not related to 'refs' specifically. This is also not a React specific feature. Instead these are regular operators which you can use in TypeScript when you are working with values that could be null (or undefined). With '?' you are always saying to try to get the value and if it is null then store null in the variable storing the value. With '!' you are always saying that you are certain that you will not be dealing null (or undefined) as a return value and therefore drill into the object property and give you the actual stored non-null value. These are generally two important operators in TypeScript.
   > Once you make it pass the if check to see whether a todo was entered you now want to add the todo to the list of todos. You probably would not want to do this in the NewTodo Component function. Instead the list of ToDos are being managed in the App.tsx Component. Hence, you would need a way of communicating back to the App Component to add the new todo item there when the form is submitted.

   Working with Function Props in TypeScript Example:
      src/components/NewTodo.tsx:
         import { useRef } from 'react';
         const NewTodo: React.FC<{ onAddTodo: (text: string) => void }> = (props) => {
            const todoTextInputRef = useRef<HTMLInputElement>(null);
            const submitHandler = (event: React.FormEvent) => {
               event.preventDefault();
               const enteredText = todoTextInputRef.current!.value;
               if(enteredText.trim().length === 0) {
                  // throw and error
                  return;
               };
               props.onAddTodo(enteredText);
            };
            return(
               <form onSubmit={submitHandler}>
                  <label htmlFor="text">Todo Text</label>
                  <input id="text" type="text" ref={todoTextInputRef} />
                  <button>Add Todo</button>
               </form>
            );
         };
         export default NewTodo;
      src/App.tsx:
         import ToDos from './components/ToDos';
         import Todo from './models/todo';
         import NewTodo from './components/NewTodo';
         function App() {
            const todos = [ new Todo('Learn React'), new Todo('Learn TypeScript') ];
            const addTodoHandler = (todoText: string) => {

            };
            return (
               <div>
                  <NewTodo onAddTodo={addTodoHandler} />
                  <ToDos items={todos} />
               </div>
            );
         };
         export default App;

   > The "NewTodo" Component wants to call a function that is stored in the "App" Component. This is a pattern used a lot in React Projects. We know that pointers at functions can be passed as props to Components.
   > As seen previously when adding props you would need to define the Component Function as a 'React.FC' and in the angle brackets use an object passing in your own custom props that should be merged to the Functional Component default props. In the above the "onAddTodo" is a prop we expect to receive. However, what type should you use for this prop?
   > We know that the prop should be a function. In TypeScript you can define a so-called function type. To define a function type you simply add an arrow function which is TypeScript's syntax for defining the shape of a function. Between the brackets you would describe the parameters the function would get and after the arrow you describe the return type of the function.
   > If the function should not return anything you do not need a return value and hence can set the value to void as an expected return value of the function definition.
   > This will make it clear that the "onAddTodo" prop should be passed a function which receives a string as an argument and this function does not return any value. This is because the "NewTodo" Component does not execute the function but simply uses the function pointer which gets executed in the "App" Component.
   > In the place you use the "NewTodo" Component e.g. in the "App" Component you would now see an error on the "<NewTodo />" Component if the "onAddTodo" prop is not set which it expects a function that has the shape defined in the "NewTodo" Component. The "addTodoHandler" function mirrors the shape of the "onAddTodo" definition.
   > It is in the "addTodoHandler" where you want to manipulate the "ToDos" array using a state managed array.

   Managing State & TypeScript Example:
      src/App.tsx:
         import { useState } from 'react';
         import ToDos from './components/ToDos';
         import Todo from './models/todo';
         import NewTodo from './components/NewTodo';
         function App() {
            const [todos, setTodos] = useState<Todo[]>([]);
            const addTodoHandler = (todoText: string) => {
               const newTodo = new Todo(todoText);
               setTodos((prevTodos) => {
                  return prevTodos.concat(newTodo);
               });
            };
            return (
               <div>
                  <NewTodo onAddTodo={addTodoHandler} />
                  <ToDos items={todos} />
               </div>
            );
         };
         export default App;

   > You would do what you normally would with the useState Hook to manage state.
   > The state updating function is inferred the type of React.Dispatch by TypeScript. This is the type definition for the state updating function which you can call to dispatch a change action to the state.
   > The normal syntax for creating a state in React using the useState Hook for example is "const [todos, setTodos] = useState([]);"; hoever, this syntax would introduce an error. The "todo" state will be inferred a type of 'never[]' by TypeScript which basically means the todo must always be an empty array (that is what 'never' type means here).
   > TypeScript will infer the never type because it is not able to infer that it should eventually be a type of todos array. The initial value has no information about that.
   > To make it clear that the useState can have an initial empty array but that it eventually you want an array full of todo items you again need to tell TypeScript that. The useState out of the box is a generic function (a generic type exactly for the reason mentioned). Using angle brackets you can make it clear what type of data should be managed by the state eventually i.e. an array of "Todo" from the data model.
   > The initial empty array does not conflict with the Type definition of an array of "Todos". This is the proper way of defining the state.
   > You can now manipulate the state using the state updating function as you normally would do.
   > All of the above code allows you to have a Form Component which takes the input of the user to create a new Todo item to create a dynamic list of ToDos list using TypeScript to define the type definition.