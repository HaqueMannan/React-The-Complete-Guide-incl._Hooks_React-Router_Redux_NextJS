React & TypeScript - Summary:
1. What is TypeScript and How to Install TypeScript
2. Exploring TypeScript Types
3. Creating a React & TypeScript Projects
4. Working with Components/Props & TypeScript

------------------------------------------------------------------------------------
1. What is TypeScript and How to Install TypeScript:
------------------------------------------------------------------------------------
   > TypeScript is a so-called 'superset' to JavaScript. It is a programming language which builds upon and extends JavaScript.
   > The core programming language remains as JavaScript. Therefore, the base JavaScript syntax you know how to write does not change. TypeScript adds more features to the JavaScript syntax.
   > Unlike React, TypeScript is not a library for JavaScript i.e. it does not use JavaScript features to build on top of them i.e. build functionality around them. Instead, it extends the core JavaScript syntax.
   > Most importantly, TypeScript adds static typing to JavaScript and where its name comes from.
   > JavaScript on its own is a dynamically typed language.

   JavaScript Dynamically Types Language Code Snippet Example:
      addFunction.js:
         function add(a, b) {
            return a + b;
         };
         const result = add(2, 5);
         console.log(result);

   > The above JavaScript code is standard JavaScript which prints the sum of two passed in numbers as argument/parameters to the function.
   > JavaScript knows the concept of types and has types. In the above example the two values passed into the "add" function are a type number. This is something JavaScript knows on its own without TypeScript. The important thing is that JavaScript is dynamically typed. This means that the function does not expect any particular types but that it will receive two argument/parameters. Therefore, it is not statically typed.
   > Statically Typed means that the values are announced ahead of time.
   > JavaScript will take whatever it receives and tries to execute the code and the code happens to execute perfectly fine with numbers.
   > However, you will also notice that the above function would also work with strings passed as argument/parameters for example "add('2', '5')" will return "25" as a string instead of the expected 7 as a number. This is because the plus operator in JavaScript now does not add the two numbers in a mathematical way but instead joins/concatenates the two strings together.
   > This demonstrates why JavaScript alone is OK and great but also why JavaScript alone may not always be the best and why having Static Typing could enhance your code and prevent errors such as the above example from occurring.
   > Therefore, in bigger projects with lots of code files and potentially a lot of people working on the code base, you may sometimes call a function or use an object in an unintended way and run into the problem as demonstrated above because nothing is warning you that it is not how you should be using the function or object.
   > This is where TypeScript can help you as a developer.

   TypeScript Statically Typed Language Code Snippet Example:
      addFunction.ts
         function add(a: number, b: number) {
            return a + b;
         };
         const result = add(2, 5);
         console.log(result);

   > Note that TypeScript files have an extension of .ts to indicate the file uses TypeScript syntax.
   > With TypeScript you can add type annotations by simply adding a colon after the parameter followed by the type which should be used by the parameter.
   > You can use type annotations not only on function parameters but also in many other situations as well.
   > The IDE will highlight any errors in the code with a squiggly red underline whenever a Type definition is not being followed. This allows you to catch any errors (any unintended use of a function or object) before you run and test the code, for example, providing a string to a parameter which expected a number type as the value.
   > This allows you to write better code at the end of the day by avoiding such errors and you do not need to track them at runtime because you see such errors when you start writing code.
   > This is the main positive reason for using TypeScript.
   > You can see TypeScript being a pre-compiler to JavaScript like SASS/SCSS is for CSS.

   Installing TypeScript:
   > Now that you know what TypeScript is and how the syntax generally look like, how do you install and use TypeScript?
   > The official webpage for TypeScript can be found on https://www.typescriptlang.org/ where you can learn more about TypeScript and its features as a language as well as how to install TypeScript.
   > Run the following command to instal TypeScript locally on your machine. You would need NodeJS and NPM installed on your machine first before running the command:

      $: npm install typescript

   > Running the command while in a project directory in the terminal will install TypeScript to a specific project.
   > To install TypeScript globally you would need to add the -g (global) flag before typescript (i.e. $: npm install -g typescript).
   > Often installing TypeScript into a specific project is enough so that TypeScript can be used in that project.
   > This will create a standard TypeScript Project (note not a React project).
   > Now that TypeScript has been installed, you can invoke the TypeScript Compiler. This is super important because as you have learnt TypeScript is a superset to JavaScript extending the JavaScript syntax.
   > It is important to note that TypeScript code does not run in the browser i.e. executing TypeScript code in the browser will fail. Thus, you need to compile TypeScript into regular JavaScript code which the browser understands.
   > During that compilation process, all the type annotations will be removed because JavaScript does not know those annotations. It is during the compilation step where you will be notified of the errors in addition to the notification you get with the IDE. Hence, the compilation step which will warn you of potential code problems if you have not spotted them already in the IDE warnings.
   > It is the compiled code that will then run in the browser at the end of the day.
   > To invoke the compiler you need to run the below command:

      $: npx tsc

   > The compiler will throw an error because it expects a TypeScript configuration file in the project folder that will tell TypeScript which files to compile and what version of JavaScript to compile to. We will dive into this configuration file later in more detail.
   > You can modify the terminal command to point at the particular TypeScript file (i.e. $: npx tsc addFunction.ts) and the compiler will create a '.js' file version of the '.ts' file that was compiled (i.e addFunction.js).
   > If there were Type errors in the TypeScript file, the compilation process will display these errors in the terminal. For example, if you used a string value instead of a number then this type error will be displayed. It will still create the compiled JavaScript file because this is the default behaviour i.e. it only warns you of the error but completes the compilation of the JavaScript file.

   Compiled TypeScript File to JavaScript File Example:
      addFunction.ts
         function add(a: number, b: number) {
            return a + b;
         };
         const result = add(2, 5);
         console.log(result);
      addFunction.js:
         function add(a, b) {
            return a + b;
         };
         var result = add(2, 5);
         console.log(result);

   > You will noticed the compiled JavaScript file code is almost exactly the same as the TypeScript file code but without the annotations. You will also notice that the result variable uses var and not const and this is because by default the TypeScript compiler compiles down to ES5 syntax which is recognised by much older web browsers. This can be something that can be overridden with the TypeScript Config file.
   > Therefore, you can continue to work in the TypeScript file and then compile it to run in the browser, you now have Static Type syntax which can help you against these types of errors.
   > We can now dive into the core features you need to know when working with TypeScript before exploring how you can use TypeScript with React.

------------------------------------------------------------------------------------
2. Exploring TypeScript Types:
------------------------------------------------------------------------------------
   TypeScript Types:
      1) Primitive Types:
         - number, string, booleans, null, undefined and symbols

         > To declare a type for a variable you simply add a colon after the variable name followed by the type. For example, 'let age: number' will define the "age" variable with a type of number. Whenever you assign a value to the variable, TypeScript will let you know in the IDE if the value voids the type definition for the variable.
         > Assigning a type number can include whole and floating point numbers i.e. decimals are included. This is because JavaScript treats numbers as any numerical value including decimal values.
         > You can assign a value when you declare a variable, for example, 'let age: number = 12' which will also work perfectly fine.
         > It is important to note that when declaring the type the type name must be in lower case letters i.e. 'number' and not 'Number'. If you used 'Number' this will not error but instead it actually points at the Number object in JavaScript. Therefore, use the lowercase name to point at the primitive type.
         > Number, Strings and Booleans are the core base primitive types you can assign to variables as well as functions parameters. Note that there are more places where you can set type definitions.
         > While you can set types of null and undefined, it is not too useful because whenever you later assign a value to a null/undefined variable, the IDE will error as it expects a null/undefined type. There is a slightly different way in which you can use null and undefined which we will see later.

      2) More Complex Types:
         - arrays and objects

         > To assign a type of an array you simply add opening and closing square brackets. For example, the type ': string[]' will declare an array of strings. You can do this for any other primitive values i.e. for an array of numbers and booleans.
         > To assign a type for an entire object, TypeScript out of the box without configuration is quite forgiving. By default it allows you to assign any values in a variable because it has a special any type. For example, 'let person' will by default have a type of any which will therefore allow you to set the variable as any value including an object i.e. 'person = { name: 'John', age: 32 }'.
         > Note that you can explicitly assign a type of any by using ': any' as the type definition. However, this is a fallback type you do not want to use because it defeats the purpose of using TypeScript. Using the type any takes you back to standard JavaScript.
         > To add a type of object and define the properties the object should have you would use opening and closing curly brackets. For example, ': { name: string, age: number }' will create a object type definition. In this example the properties are given a type definition as well.
         > Therefore, if you try to create an object that has a property not defined in the object definition then the IDE will throw and error as well as assignment the incorrect type for the particular property.
         > You can combine array and object definitions to create a more complex type definition. For example, ': { name: string, age: number }[]' will create an assignment of an array of such objects.
         > This allows you to get a little advanced by combining different TypeScript features and by combining different types.

      3) Function Types and parameters
         > When you work with function there are different places where types can be assigned.
         > One place where types can be assigned in functions are the parameters. Just as you can set types for variables you can also assign types to function parameters. For example:
            function add(a: number, b: number) {
               return a + b;
            };
         > You can also infer a type in the function. In the above add function example, the return value of the sum is inferred a type definition of a number. You can see this inference if you hover over the 'add' function name which the IDE will display the inferred type retuned from the function.
         > You could explicitly set the type definition for example, 'function add(a: number, b: number): number | string' will explicitly define the return type for the function to be a number or string. You should not do this if you do not have a reason for explicitly defining the function's return value type (Refer to the below about Type Inference and Union Types for an explanation as to why).
         > Function not only have inputs but it also has outputs; hence a function can have a return type definition.
            function printOutput(value: any) {
               console.log(value);
            };
         > A function which has not return any value from its codeblock (as demonstrated in the above example) has a special return type definition inferred called void. The type void is comparable to null and undefined but is only used in conjunction with functions. It simply means that the function never returns. Therefore, if you want to work with the returned value from that function, you would work with undefined.
         > This is the special void type definition to work with returned values from a function that does not returns anything.

   Type Inference:
      > Remember: Anything at the right side of a colon is a type assignment and not a assignment of a value which is usually a value on the right side of the equal sign.
      > Typically, in programming you would create a variable and immediately assign an initial value right away in one step. For example, 'let age = 20' will create a variable and assign a number value. If you try to assign a different value for example "twenty" as a string the IDE will throw an error even though you did not specify a type definition.
      > TypeScript uses its powerful feature of Type Inference. By default TypeScript tries to infer as many types as possible i.e. it tries to know which types are used where without you explicitly stating the type definition. Hence, allowing you to write less code.
      > You could set your type (e.g. 'let age: number = 20') but it is a little redundant. This is because if you immediately initialised a variable with a value, TypeScript will look at that value that was stored in the variable and then use that value type as an inferred type for the variable. Therefore, if you try to assign a different type thereafter you will receive an error.
      > It is good practice to embrace the type inference feature i.e. to not unnecessarily specify the type in addition. You can explicitly state the type but it is redundant code and more work from your side.

   Union Types:
      > Sometimes you would want to allow multiple different types to be assigned to a variable. It is not unrealistic that you could have a variable where both a string as well as a number should be allowed to be stored in that variable. The TypeScript feature of Union allows such type definition.
      > A Union Type is a type definition that allows more than one type to be assigned.
      > You would use a pipe symbol (|) after a type definition to add another type after the pipe. You can have as many types as you would like to allow as needed.
      > Therefore, where a variable has been immediately assigned a variable, it is OK to define the type (i.e. ignoring type inference) if the type is a Union. For example, 'let age: number | string = 20' will now allow both a number or a string to be assigned to the variable.
      > You can also use a Union anywhere where you have a type assignment and does not need to be used only when you use Type Inference.

   Type Aliases:
      > The more TypeScript code you write the higher the chances at some point you might be repeating some type definitions.
      > You can, of course, duplicate the type definition but it is more realistic that you want to avoid duplication. For example, you could type define an object and then use the same object but defined as an array of that object. To avoid this duplicate you can create a so called Type Alias.
      > Type Alias allows you to define your own base type in which a more complex type definition is stored and then use that type alias instead of repeating the entire type definitions.
      > You can create a Type Alias by using the 'type' keyword. This is a keyword provided by TypeScript and is not part of standard JavaScript. After the keyword you can choose any name of your choice which will become your new type name (i.e. an alias for your type definition). After the name you use an equal sign to define your type definition for the alias.
      > The equal sign is used because Type Alias is a pure TypeScript feature. This code will be thrown out of the window when the code is compiled to regular JavaScript code.

         type Car = {
            make: string,
            model: string,
            doors: number
         };
         let car1: Car;
         car1 = {
            make: 'BMW',
            model: '4 Series',
            doors: 5
         }
         let cars: Car[];

      > From the example above the type definition was defined once as a Type Alias and that alias could be used wherever that definition is required without repeating the type definition wherever it is needed. This feature can save you a lot of typing work and make your code more concise and easier to maintain by abiding to the DRY principal of programming.

   Generics:
         function insertAtBeginning(array: any[], value: any) {
            const newArray = [value, ...array];
            return newArray;
         };
         const demoArray = [1, 2, 3];
         const updatedArray = insertAtBeginning(demoArray, 0);

      > In the above example, there is a utility function called insertAtBeginning which takes an array of type any and a value of type any. This simply create a newArray inserting the value at the beginning of the array and returning the newArray as the value. However, you will notice that the updatedArray has an inferred type of any[] and not numbers[] even though the items are all numbers. Why is this?
      > The reason is because the array argument/parameter in the insertAtBeginning function has the type of any[] which is used to create the newArray which is returned and so the updatedArray will have an inferred type definition of any[] as well.
      > You could update the array parameter to have a type definition of number[] but this will remove the utility function being used with strings. Therefore, while you would need any[] as the type definition for the flexibility it also at the same time removes all kind of TypeScript support you might be getting after calling the function i.e. there is no good TypeScript support for the updatedArray thereafter.
      > For example, 'updatedArray[0].split('')' would not return an error in the IDE but you would get a runtime error instead because you cannot call split() on a number. TypeScript does not know that the first element in the array is a type number to throw that error in the IDE. To work around such issues you have a feature called Generics.
      > Generics allows you to convert a function into a Generic Function. The special syntax is to add angle brackets between the function name and the opening and closing round brackets. For example, 'function insertAtBeginning<T>(array: T[], value: T)'. Inside of the angle brackets you would define the Generic Type, typically defined with 'T' but the name of the identifier is entirely your choice.
      > This is not a standard JavaScript feature but rather a feature that can only be used in TypeScript.
      > The Generic Type will only be available inside of the function.
      > Therefore, TypeScript is now able to understand that it should look at the concrete values of the arguments/parameter that are being passed into the function and it can now correctly infer updatedArray to be an array of numbers to provide better TypeScript Support to the IDE.
      > The utility function can continue to be used flexibly with different array types and values, for example, 'const stringArray = insertAtBeginning(['b', 'c', 'd'], 'a')' would correctly infer stringArray with the type definition of an array of strings. This is because TypeScript would look at both the concrete array and value passed into the function both being a type of string and so will infer the return type to also be an array of string. The IDE can now warn the developer when the split() function is being used on an array containing numbers before the compilation stage.
      > Therefore, Generics allows you to write functions (in this case) which are type safe yet flexible. The function can work with any type but once a certain type is used for that function execution, that type is locked in and known by TypeScript. This allows you to get the best of both worlds of flexibility and type safety.

   A Closer Look at Generics:
      > Generic Types ("Generics") can be tricky to wrap your head around. But indeed, we are working with them all the time - one of the most prominent examples is an array. Consider the below example array:
         let numbers = [1, 2, 3];
      > Here, the type is inferred, but if we would assign it explicitly, we could do it like this:
         let numbers: number[] = [1, 2, 3];
      > The 'number[]' is the TypeScript notation for saying "this is an array of numbers". But actually, 'number[]' is just syntactic sugar!
      > The actual type is Array. All arrays are of the Array type... BUT, since an array type really only makes sense if we also describe the type of items in the array, Array actually is a generic type.
      > You could also write the above example like the below instead:
         let numbers: Array<number> = [1, 2, 3];
      > Here we have the angle brackets (<>) again! But this time NOT to create our own type (as seen in the previous first Generics example) but instead to tell TypeScript which actual type should be used for the "generic type placeholder" (i.e. 'T' in the previous example). As shown in the first example, TypeScript would be able to infer this as well - we rely on that when we just write:
         let numbers = [1, 2, 3];
      > But if we want to explicitly set a type, we could do it like this:
         let numbers: Array<number> = [1, 2, 3];
      > Of course it can be a bit annoying to write this rather long and clunky type, that is why we have this alternative (syntactic sugar) for arrays:
         let numbers: number[] = [1, 2, 3];
      > If we take the example from the previous first Generics example, we could have also set the concrete type for our placeholder T explicitly:
         const stringArray = insertAtBeginning<string>(['a', 'b', 'c'], 'd');
      > So we can not just use the angle brackets to define a generic type but also to USE a generic type and explicitly set the placeholder type that should be used - sometimes this is required if TypeScript is not able to infer the (correct) type.

   Conclusion:
   > There are more core TypeScript features but the above are the core TypeScript features you should know when working with TypeScript.
   > You can learn more on TypeScript and its features on the official website (https://www.typescriptlang.org/).

------------------------------------------------------------------------------------
3. Creating a React & TypeScript Projects:
------------------------------------------------------------------------------------
   > To use TypeScript with React Projects you need to have React Project configured to use TypeScript instead of vanilla JavaScript.
   > The great thing is that you can continue to use 'create-react-app' to create a new React Project. In the official documentation there is a documentation on how to integrate TypeScript (https://create-react-app.dev/docs/adding-typescript). If the link was to change you could always google "create-react-app typescript" and find the documentation page.
   > It is easy if you start a new project with TypeScript integration, although you do also get instructions on how you can add TypeScript to an existing project. The command to create a new project is:
      $: npx create-react-app [app-name] --template typescript
   > Running this terminal command will create a new React Application with TypeScript integration in the directory that the terminal was 'cd' to.
   > YOu can continue to use 'npm start' to spin up a dev server as you would normally would do. However, you now have a project directory all configured to work with TypeScript.
   > You should notice that you now have '.tsx' files instead of '.jsx' files which will indicate that you are now using TypeScript. The file extension is '.jsx' and not '.js' because React uses JSX syntax which will avoid any unnecessary IDE complaints. The code is exactly the same as before and nothing else special.
   > One thing to note with the dev server is that it now does one thing more behind the scenes than it did before. It is also compiling the TypeScript code to regular JavaScript code. The same would also occur if you were to build your code for production by running the 'npm run build' command.
   > The 'package.json' file has the same dependencies as before but with some extra dependencies; specifically 'typeScript' as well as '@types/' dependencies. The 'typeScript' package is the language/compiler for TypeScript installed in the project.
   > The extra '@types/' packages are extra but important packages. They act as translation bridges between vanilla JavaScript libraries and TypeScript projects. For example, the 'react' and 'react-dom' libraries are written for just JavaScript. In order to work with them in TypeScript (and get TypeScript and IDE support) you need translations between the raw vanilla JavaScript libraries and the TypeScript project i.e. extra type annotations that are added to these JavaScript libraries you could say. This is what '@types/react' and '@types/react-dom' packages provides.
   > Not all libraries need translations because some libraries actually already have built-in type annotations even though you can use them with just JavaScript as well. However, some libraries do need these extra annotations which is why there are some extra packages installed to provide the annotations for those libraries.
   > You can now write React code with TypeScript.

------------------------------------------------------------------------------------
4. Working with Components/Props & TypeScript:
------------------------------------------------------------------------------------
   Working with Components & TypeScript:
      > Generally you continue to write the same code as you did before i.e. nothing has changed. You will notice that the new project does not use any special type annotations because it does not need them. It is generally using TypeScript's built-in type inference feature. Simply the boilerplate starting code does not use a lot of Types. We can now explore where we can use TypeScript to enhance your react application code.

      Component TSX File Example:
         src/components/ToDos.tsx:
            function ToDos() {
               return(
                  <ul>
                     <li>Learn React</li>
                     <li>Learn TypeScript</li>
                  </ul>
               );
            };
            export default ToDos;

      > You continue to build React Components generally as you have learnt it. The above ToDos Component renders a unordered list with two hardcoded list items. The code is exactly the same as using standard JavaScript. It gets slightly more interesting when the Component receives props to output a dynamic list.

   Working with Props & TypeScript:
      Component with Prop TSX File Example:
         src/components/ToDos.tsx:
            function ToDos(props) {
               return(
                  <ul>{}</ul>
               );
            };
            export default ToDos;

      > When you add props as an argument/parameter to a Component you will see a red squiggly line appearing in the IDE. The description when hovered will read as "The prop is declared but its value is never read." and "Parameter 'props' implicitly has an 'any' type". This is a little extra help you would get from TypeScript of which you would not get with regular JavaScript projects.
      > The warning tells you that you have unnecessary code you are not using as well as the implicit type for the 'props' variable. TypeScript warns you that you should not make any implicitly assumptions. You can configure the strictness of TypeScript in the 'tsconfig.json' file. To remove this warning, you need to make it clear which kind of 'props' (i.e. the type of prop) you are getting in the Component function.
      > Therefore, you could assign a type like so 'props: {}' which will assign the props variable of a type object. We know objects have key:value pairs in which case you can assign the type of object you expect to receive for props e.g. 'props: { items: string[] }'. This will define 'props' as and object with an "items" key which then itself stores an array of strings as a value. However, this would not actually be 100% correct.
      > Remember: 'props' does not just have the key:value pairs you add on the Component when you use it in JSX. Instead, 'props' is an object which does have those key:value pairs but it also always has a special 'children' prop. You do not know the type of children yet. You could find out the type and then add it but this will quickly become cumbersome if for every component you are defining that is using props you have to always add those built in props to that object along with your custom props.
      > Since you have that base prop object which you get in every Component, React and TypeScript provides a different way of defining the type. You can use a Generic Type instead. To be precise a functional Component out of the box can be converted into a generic function. This simply means in the end your functional Component will be configured such that you make it clear that it will be a React Component Function and it will have all those base props like children and you can define explicitly you own props e.g. "items" which should be combined into the overall props object.
      > The example code can be written differently as shown below:

         const ToDos: React.FC<{items: string[]}> = (props) => {
            return(
               <ul>{props.children}</ul>
            );
         };

   > The Generic 'FC' Type makes it clear to TypeScript that this function is a function that acts as a functional Component. Depending on the project setup you might not need to import the 'React' package into the Component file to use the 'FC' Generic Type which stands for Functional Component. You will now see the IDE red squiggly lines disappear.
   > If you now use the 'props' object you should now see autocompletion with the children prop. By adding the FC Type annotations, TypeScript and your IDE understands your code is a function that receives a props object as the first argument which will be an object that always has a 'children' property.
   > Since FC is a Generic Type, it allows you to merge your own props the functional Component will get with those built-in base props like 'children'. Hence, you add the angle brackets after 'FC' and between those angle brackets you simply define your own props.
   > The angle brackets are used slightly different to how we have previously seen it with creating your own Generic Types. Here, there 'React.FC' is already a Generic Type (i.e. it describes a type defined by the React package) that is already generic. When you add an angle brackets after 'FC', you are not setting up a new Generic Type with some placeholder type e.g. 'T' but instead you are plugging in a concrete value for that internally used Generic Type (i.e. the type 'T' defined by the React.FC type).
   > You do this because you are not calling some generic function with some parameters where the values then could be used for the inference. Instead, you are defining a function and you want to let TypeScript know how it should then treat this function internally i.e. it should get some props defined by us and merge those with some base props like the 'children' prop which all functional Components have.
   > Therefore, here we are seeing that you use a Generic Type and you explicitly set the concrete type that should be used for this usage of this Generic FC Type. It is generic because different functional Components have different props definitions. Thus, this is how you define the type with React and TypeScript.
   > If you now type "props." in your IDE you should get autocompletion suggestion for the props object. In the above example you would see "children" and "items" as autocompletion suggestions for this props object. It will also tell the type for the items property which should be a string array. This is because your own prop object definition is merged with the base prop object definition.
   > This may seem all confusing to explain the internal workings, but using 'FC' is super simple. You build functional Component with React and TypeScript by using the React.FC Generic Type on your function Component constant. You then use the angle brackets and between those angle brackets you define your own 'props' objects type definition if your Component gets some custom props (omitting the angle brackets means there are no custom props to be merged with the base props object type definition). In the Component you can then use those custom props defined. You will get autocompletion by your IDE as TypeScript will know the types e.g. a prop which has a type of string array can use array methods such as '.map()'.

      src/components/ToDos.tsx:
         const ToDos: React.FC<{items: string[]}> = (props) => {
            return(
               <ul>{props.items.map(item => <li key={item}>{item}</li>)}</ul>
            );
         };
      src/App.tsx:
         import ToDos from './components/ToDos';
            function App() {
               return (
                  <div>
                     <ToDos />
                  </div>
               );
            };
            export default App;

   > The above is the final code for the ToDos Component with proper Type annotations i.e. this Component uses 'props' to dynamically set list items in the unordered list.
   > The great thing about using TypeScript with React is now not just that the code is more descriptive and you get the autocompletion when you work inside of the Component, but you also now see that you have errors in the App Component file which imports the ToDos Component. Due to the Type annotations, the project setup now understands that you are using the ToDos Component in an incorrect way.
   > The above makes it clear that the ToDos Component will have an items prop which holds a string array and that this prop is not optional. To make something optional you simply add a question mark before the colon (e.g 'items?: string[]'). However, if you do this you should also make sure to handle in your JSX the case that you do not necessarily have items if it is optional.
   > Therefore, if the prop is not optional this will indicate that the prop is required when being used as a Component in other files. This is another strong reason for using TypeScript in React projects. You can really describe the shape of your Components and which props they need and therefore using the Component incorrectly is pretty much impossible because you get errors like this directly in the IDE.

      src/App.tsx:
         import ToDos from './components/ToDos';
            function App() {
               return (
                  <div>
                     <ToDos item={['Learn React', 'Learn TypeScript']} />
                  </div>
               );
            };
            export default App;

   > To correct the error in the App.tsx file you would simply define the items prop in the ToDos Component e.g. "<ToDos item={['Learn React', 'Learn TypeScript']} />" which will create the list items dynamically in the Component. All errors should be gone and your project compiles a working React project files.
   > It is the above Type annotation you want to add to every custom Component you are building and if you are using your own props you add the 'FC' Generic Type and describe your custom props between the angle brackets which gets merged with the base props.