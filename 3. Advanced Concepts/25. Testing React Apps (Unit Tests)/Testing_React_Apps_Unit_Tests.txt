Testing React Apps (Unit Tests) - Summary:
1. What & Why and Understanding Different Kinds of Tests
2. Understanding the Technical Setup & Involved Tools

------------------------------------------------------------------------------------
1. What & Why and Understanding Different Kinds of Tests:
------------------------------------------------------------------------------------
   > Testing the application is error-prone; at least if it is the only kind of testing you do. Simply because it is hard to test all possible combinations and scenarios.
   > If you have a very complex React application with a lot of different pages and features and then you add a new feature (or change an aspect of an existing feature) you will probably test that change or new feature but you are not going to test all the other parts of your application all the time.
   > Therefore, you may change something which might break some other feature in your application and since you are not testing everything all the time, that breaking change/bug, might slip through to live production. You may eventually catch the bug later (but it is not guaranteed) and you might catch it too late which may cause some extra work or additional problems.
   > This is where automated testing steps in. This is not a replacement for manual testing but is is an addition.
   > With automated testing you write extra code that runs and tests your other code (i.e. the main application code).
   > This is a standard procedure to do in modern development.
   > Since you write code that test your entire application automatically, you can always test everything no matter what you changed because you will automatically test the entire application (and doesn't cost a lot of time to do the testing).
   > You write such automated test scripts that test the different individual building blocks of your application but where you also then test all those building blocks together whenever you make changes to your code. Therefore, instead of testing parts of your application from time to time, you can test the whole application all the time.
   > Automated testing combined with manual testing will allow you to catch errors way earlier and it allows you to write and ship better code in applications.

   Types of Automated Tests:
   > There are different kinds of automated testing:
      - Unit Tests: test the individual building blocks (e.g. functions, components) in isolation.
      - Integration Tests: test the combination of multiple building blocks.
      - End-to-End (e2e) Tests: test complete workflow scenarios in the application as the user would experience them.
   > These are the three main categories of tests which you can write.
   > Projects typically contain a lot of Unit Tests since you want to test all the units that make up the application. This is the most common and important kind of testing. The idea is that if you test all the individual units in isolation, the overall application will also work.
   > Integration Tests is used typically to verify the overall application really works when you put all those individual units together. Projects typically contain a couple of Integration Tests but not as many as you would have with Unit Tests.
   > The e2e Tests are used to test the entire workflow/scenarios such as logging a user in and navigating to a certain page. This testing is to really re-produce what a rea user would do with the webapp i.e. testing the business logic. This is basically what you would also do with manual test but now automated.
   > Projects typically contain only a few e2e Tests. This is because if the Unit and Integration Tests all pass you can confidently assume the overall application works. The Unit and Integration tests are much more easier to test and are quicker to run and are more focused and way easier to test all possible scenarios compared to thinking of test scenarios if you were testing the application as a whole.
   > So while e2e Tests are important but can be tests which you can do manually. Business would do this manually which is known as UAT testing.

   What to Test & How to Test:
   > When you start writing tests, there are two super important questions you have to answer relatively early:
      - What should you test?
      - How should you test that?

   > So for Unit Tests, what you should test should be the different building blocks that make up your application. You want to make sure to test really small building blocks so that you have small focused tests that only test one main thing. Therefore, you should have a lot of focused tests which would then fail for a clear reason rather than having a few large tests which could fail for all kinds of reasons.
   > The How, is to test the success and error cases that could occur if a user interacts with your application. You also want to test for some rare (but possible) scenarios and results. This will become more clear when you see some example test code.

------------------------------------------------------------------------------------
2. Understanding the Technical Setup & Involved Tools:
------------------------------------------------------------------------------------
   > Now that you have a rough idea why you need tests and that tests are basically code that then test other other code. However, where do you write this code and how do you execute the testing code?
   > You need extra tools and setup. Specifically, you need a tool for running the test code and asserting the results (i.e. whether the result can be seen as a success or a failure to a given result).
   > With React application you need a tool for simulating of rendering your React App/Components for those automated tests to then interact with them. So you could say that you need to simulate the browser.
   > To run the test code and asserting the results you can use a tool called Jest (this is not the only tool but it is a very popular tool for testing React and is easy to use).
   > To simulate and render the Components and the React App you would typically use the React Testing library as the tool.
   > Both these tools are already installed and setup for you when you work in a project created with the 'create-react-app'.
   > In the package.json file you should see the dependency packages already installed.

   Package.json File Testing Dependency Example:
      package.json:
         ...
         "dependencies": {
            "@testing-library/jest-dom": "^5.14.1",
            "@testing-library/react": "^11.2.7",
            "@testing-library/user-event": "^12.8.3",
         },
         ...

   > These libraries are part of the newly created React Projects that were created using the 'create-react-app' i.e. installed automatically and setup right out of the box.
   > While you cannot see 'Jest' in the dependencies list, it is still installed because it is a dependency of the other installed dependency packages.
   > Therefore, everything is all setup for you to run your tests.

   Running First Test:
   > Using the standard code that is created by 'create-react-app' you will find a 'App.test.js' file and a 'setupTests.js' file.
   > The setupTests.js file as the name suggests will do some setup work and you will not need to do anything else with this file (i.e. leave the file as the default).
   > The 'App.test.js' is more interesting. This is a file that contains some testing code. This is a default test file that comes out of the box (but you can write your own test code from scratch). This file is here to test the App.js Component.
   > The naming convention is to name your test files like your Component files but with the word of '.test.js' as the file extension.

   Default App.js Test Code Example:
      src/App.js:
         import React from 'react';
         import logo from './logo.svg';
         import './App.css';
         function App() {
            return (
               <div className="App">
                  <header className="App-header">
                     <img src={logo} className="App-logo" alt="logo" />
                     <p>Edit <code>src/App.js</code> and save to reload.</p>
                     <a className="App-link" href="https://reactjs.org" target="_blank" rel="noopener noreferrer">Learn React</a>
                  </header>
               </div>
            );
         };
         export default App;
      src/App.test.js:
         import { render, screen } from '@testing-library/react';
         import App from './App';
         test('renders learn react link', () => {
            render(<App />);
            const linkElement = screen.getByText(/learn react/i);
            expect(linkElement).toBeInTheDocument();
         });
      package.json:
         ...
         "scripts": {
            "start": "react-scripts start",
            "build": "react-scripts build",
            "test": "react-scripts test",
            "eject": "react-scripts eject"
         },
         ...

   > The 'test' is a function that takes two arguments. The first argument is a string description of the test and is entirely up to you what the description should be (but it should help you identify the test in the testing output). The second argument is an anonymous function which contains the actual test code (i.e. the code that would be executed once you run your test).
   > In the above example, the test code renders (a function from the '@testing-library/react' library) the App Component. It then gets hold of some element on the virtual screen (i.e. simulated browser), in the above the element is identified by the text of "learn react/i" in a case insensitive way (using regular expression) that is rendered inside of it. Finally, it checks if that element actually is in the document.
   > The test will fail if the element is not found and it will succeed if it is found i.e. asserting the pass/fail of the scenario/test code.
   > In the above example, the test should pass because there is a <a> element with the text "Learn React" which will match the test case because the regular expression "learn react/i" is case insensitive (i.e. "Learn React" will be matched to "learn react" regardless of casing of the letters).
   > So how do you run the test? There is a script called 'test' found in the package.json file, a script you can run just as you would have for running the development server.
   > So by opening the terminal and while navigated to the project directory if you were to run the following command below you can test all your test files in your React application.

   Running Test Command Example:
      $: npm test

   > The command will start up the testing environment. This may run automatically for you or you may need to press the 'a' key on your keyboard to run all the '.test.js' files in your React application.
   > This will find all files that contain the '.test.js' extension and execute all test functions that are defined in all those '.test.js' files found. the output of the test files assertions will be displayed in the terminal.
   > The test output would look something like the below:

   Terminal Test Results Example:
         PASS  src/App.test.js
         ✓ renders learn react link (44 ms)

         Test Suites: 1 passed, 1 total
         Tests:       1 passed, 1 total
         Snapshots:   0 total
         Time:        2.71 s
         Ran all test suites.

         Watch Usage
         › Press f to run only failed tests.
         › Press o to only run tests related to changed files.
         › Press q to quit watch mode.
         › Press p to filter by a filename regex pattern.
         › Press t to filter by a test name regex pattern.
         › Press Enter to trigger a test run.

   > So in the above example, one test ran which passed and you can see all the tests files and test function that was run. You can see the test description "renders learn react link" as defined in the test function first argument/parameter is displayed. Again, this helps you identify the test scenario/file that ran the test code and what scenario it was testing.
   > By default the testing tool will watch your project directory for any changes to test files and will re-run the test automatically whenever it detects any saved changes.
   > When a test fails you will see the Test File that failed, the test case that failed, an explanation why the test failed, an output of the actual content that was rendered and finally the testing code and the line of code that failed. As a developer you can either adjust the test or the code that broke.
   > This is the whole idea behind automated testing and how it works.
   > To quit the testing, press both the control and c keys on your keyboard together. This will close the testing server.
   > This is the technical basics of testing your React applications using the tools provided by a 'create-react-app' project.