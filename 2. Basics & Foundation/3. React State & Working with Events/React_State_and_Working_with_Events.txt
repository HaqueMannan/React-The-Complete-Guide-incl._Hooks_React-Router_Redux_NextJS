React State & Working with Events - Summary:
1. Listening to Events & Working with Event Handlers
2. How Component Functions are Executed
3. Working with 'State'
4. A Closer Look at the 'useState' Hook
5. Adding Form Inputs
6. Listening to User Input
7. Working with Multiple States
8. Using One State vs Using Multiple States
9. Updating State that Depends on the Previous State
10. Handling Form Submission
11. Adding Two-Way Binding
12. Child to Parent Component Communication (Bottom-Up)
13. Lifting the State Up
14. Controlled vs Uncontrolled Components & Stateless vs Stateful Components

------------------------------------------------------------------------------------
1. Listening to Events & Working with Event Handlers:
------------------------------------------------------------------------------------
   > On all built-in HTML elements (such as <div>, <h1>, <button>, etc) you have full access to the native DOM events which you can listen to.
   > You can use the Mozilla Developer Web Doc website to search for HTML elements for example the <button> element (https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button) to find an article about the HTML element. You may find a link to the DOM interface for the element (e.g. https://developer.mozilla.org/en-US/docs/Web/API/HTMLButtonElement).
   > You can see from which other elements/classes the element inherits from and you will notice the HTMLButtonElement is a more specific form of the HTMLElement, which is a more specific form of the Element, which is a more specific form of the Node and so on until it reaches the root class.
   > If you click on Elements for instance, you will see that there are a bunch of events (https://developer.mozilla.org/en-US/docs/Web/API/Element#events) you can listen to such as click and blur.
   > For all the default HTML Events there is a 'Prop' equivalent in React.
   > Instead of using the normal JavaScript method for listening to an HTMLElement event for example:

   JavaScript HTML Event Listener Example:
      document.getElementByID('root').addEventListener();

   > In React you would go to the JSX element within the Component file and add a special 'Prop'.
   > The 'Prop' is not a a prop which sets some value for the element but it is instead a prop that starts with the 'on' keyword. React exposes all the default events as props with 'on' keyword in front of the event listener name for example onClick is Reacts equivalent to the default click event (the event listener name must start with a capital letter).

   React HTML Event Listener Example:
      const ExpenseItem = (props) => {
         const clickHandler = () => console.log('Clicked');
         return(
            <button onClick={clickHandler}>Change Title</button>
         );
      };

   > When you add a React 'on' prop event listener to a JSX element, you need to define what should happen when the event occurs. You do this by assigning a value to the event listener 'on Prop'.
   > The value you assign has to be code that should be executed with the event occurs i.e. you would assign a function. All React 'on Prop' event handlers want a function as a value, so that it can execute the function when the event occurs.
   > You can either create the function on the fly using an anonymous function such as: 
      <button onClick={function() {console.log('Clicked!')}}>Change Title</button>
      <button onClick={() => {console.log('Clicked!')}}>Change Title</button>
   > Typically you would not want to work with anonymous inline functions because this could bloat the code within your JSX code within your Component file. Instead, you would want to define your function before the return JSX code. the React event handler 'on Prop' will point to the function and React JSX uses curly brackets to inject basic JavaScript expressions as seen in the above example code.
   > It is important that you point at the function and not execute it (onClick={clickHandler()} would execute the function when you add the round brackets after the function name).
   > The reason you would not add round brackets after the function name when you reference the function in the 'on prop' value is because JavaScript would execute the function when the line of code is being parsed when the JSX code is being returned. This would result in the function being executed too early and is also the reason why you would just point at the function by passing in the pointer to the function. React will memorise the pointer and can execute the function for us whenever the event occurs.
   > This is how you can add Event Listeners and Event Handlers in React Components.
   > Important Note: some events are available on every elements while other events are available on specific elements but it is all based on the default DOM interface behaviour.
   > It is common practice to name your Event Handler functions with 'Handler' at the end of the function name. This will help make it clear that the function is attached and called on an React event handler and will be executed by react when the event occurs. However, this is a preferential naming convention for Event Handler functions which you may follow.

------------------------------------------------------------------------------------
2. How Component Functions are Executed:
------------------------------------------------------------------------------------
   > Reacting to events is an important first step. How can you change what shows up on the screen?
   > Using the previous button example, we want to change the title of an element when the button is clicked. You may think the below example would work:

   (Incorrect) Changing Title Event Handler Example:
      const ExpenseItem = (props) => {
         let title = props.title;
         const clickHandler = () => { title = 'Updated!'};

         return(
            <div>
               <h2>{title}</h2>
               <button onClick={clickHandler}>Change Title</button>
            <div>
         );
      };

   > You would think the onClick event handler would change the <h2> element text value to 'Updated!' when the <button> element is clicked, triggering the onClick event handler function. You would think that by initially storing the props.title value in the variable called title, you can change the value of the variable via the clickHandler function and because the <h2> element points at the title variable this should update what is displayed on screen when the button is clicked. However, this does not work in React. Why is this happening?
   > Note that the clickHandler function is being triggered when the button is clicked (which can be proved by adding a console.log(title) in the Event Handler function). Therefore, there is no issue with the execution of the function. So why do we not see that reflected in the DOM because after all you are displaying the title variable value?
   > It is simply because React does not operate like this.

   > Keep in mind your React Component is a regular JavaScript function. The only special feature of your function is that it returns JSX.
   > Since it is a function someone has to call it. You will notice that you never call your Component function. Instead, you use the Components (functions) like HTML elements in the JSX code. for example <ExpenseItem/>
   > Under the hood this is almost like a function call - by using your Components in the JSX code, you make React aware of your Component functions. Whenever React evaluates the JSX code, it will call the Component functions. The Component functions itself returns JSX code which are also evaluated up until there are no more JSX code (i.e. functions) left to be evaluated.
   > After it has executed all JSX code, React then evaluate the overall results and then translates that into DOM instructions which renders the output to the screen.
   > This is how React works and it is all triggered off with the root index.js file (i.e. the 'main' function execution of the app) where you initially point at the <App /> Component function. The only problem with this is that React never repeats this process. It only executes once when the application is initially rendered but thereafter it is done.
   > We need a way to tell React that something has changed and that a certain Component should be re-evaluated. This is where React introduces a special concept called 'State'.

------------------------------------------------------------------------------------
3. Working with 'State':
------------------------------------------------------------------------------------
   > 'State' is not a React specific concept but it is a key concept in React.
   > When data in a Component changes and that change should result in the Component being re-evaluated in order to re-render what is drawn on the screen when the data changes, State is important.
   > Regular variables does not trigger a re-evaluation. React does not care about changes to regular variables.
   > To tell React that it should run the re-evaluation process again, we would need to import something from the 'react' library.
   > We do this by adding a so-called named import which is done by using curly brackets and selecting specific named things from the library that has been exported.

   Importing Named Import Syntax Example:
      import React, { useState } from 'react';

   > Notice that the 'React' object is the default export for the 'react' library. The single pieces within the curly brackets are named imports i.e. things such as variables, functions, objects, etc. that have been exported by the library.
   > The 'useState' named import is a function provided by the 'react' library. This function allows us to define values as 'State' where changes to these values should reflect in the Component function being called again for re-evaluation. This is the key difference to regular variables that you would define in the Component file.

   Using State Example:
      import React, { useState } from 'react';
      const ExpenseItem = (props) => {
         useState(props.title);
         const clickHandler = () => console.log('Clicked');
         return(
            <button onClick={clickHandler}>Change Title</button>
         );
      };

   > To use the useState function, you simply call the useState() function within your Component function as seen above.
   > The useState is a so-called 'React-Hook' and there are other 'React-Hooks'. React-Hooks can be recognised as they all start with the 'use' keyword in their function names.
   > React-Hook must only be called inside of React Component functions and they should not be called in any nested functions i.e. they can only be called directly inside the Component functions. Below are examples of incorrect calls:

   (Incorrect) Outside Component Functions Example:
      import React, { useState } from 'react';
      useState();
      const ExpenseItem = (props) => {
         ...
      };

   (Incorrect) Inside Nested Component Functions Example:
      import React, { useState } from 'react';
      const ExpenseItem = (props) => {
         const clickHandler = () => {
            useState();
            console.log('Clicked');
         }
         ...
      };

   > The useState should be called inside of the ExpenseItem Component function as correctly demonstrated in the 'Using State Example'. However, there is one exception to this rule which we will revisit later.
   > React-Hooks is a new feature introduced by the React team and is a topic in itself.

   > The useState(); function requires a default state value as an argument/parameter. This is because with the useState() function, you create a special type of variable i.e. a variable where changes would lead to the Component function to be re-called again for re-evaluation. For Example:
      useState(props.title);
   > The useState() function also returns something which gives us access to this special variable but also a special function that you can call to assign a new value to the variable.
   > Therefore, you will no longer be assigning values using the normal assign operator (=) to this special variable as you would with the regular variables, but rather you would use a special function instead. This is how the useState() variable works.
   > The useState() function actually returns an array where the first value is the special variable itself and the second value is the update function.
   > You can therefore use a modern JavaScript feature called array destructuring to store both elements in separate variables (the name of the destructed variables does not matter but the ordering does).

   Destructuring useState Syntax Example:
      import React, { useState } from 'react';
      const ExpenseItem = (props) => {
         const [title, setTitle] = useState(props.title);
         const clickHandler = () => {
            setTitle('Updated!');
            console.log(title);
         };
         return(
            <button onClick={clickHandler}>Change Title</button>
         );
      };

   > The first element is the pointer to the managed variable (i.e. the default state value passed ito the function i.e. props.title) while the second element is the function that you can later call to set a new value to the managed variable.
   > The common naming convention for the destructed variables names is to use something that describes the value for the name of the first element (e.g. title) and then use the 'set' keyword followed by the first element name repeated for the name of the second element (e.g. setTitle).
   > The useState() function always returns exactly two elements where the first element is the current state value and the second element is the function to update that state value.
   > To set a new value, you will call the special function passing in the value as an argument.
   > React manages the special variable somewhere in memory which the special function will update.
   > Calling this special function does not only assign a new value to the special variable, but the Component function in which you called the special function will be executed again. Therefore, the Component function will be recalled again whenever the State changes.
   > This is you would tell React that you want to assign a new value to the 'State' and that then tells React that the Component, in which the 'State' was registered with, should be re-evaluated. This will then execute the Component function again and re-evaluate the JSX code again. This will draw any changes to the text compared to tha last time it evaluated the Component function onto the screen.
   > You will notice when the button is clicked, the console.log(title) will display the previous value for the <ExpenseItem /> before it updated. This is because calling the state updating function actually does not change the value right away but instead schedules the state update. Therefore, the new value is not available yet which is why you would see the previous value being concole.log() even though you updated it (i.e. setTitle('Updated!)) before logging the value. You would see the change on the screen because the Component is eventually re-evaluated and re-drawn to the screen.
   > This is how React State works and is another key concept in React.
   > If you have data which might change and where changes to that data should be reflected on the user interface, you then require State because regular variables will not work in React.

------------------------------------------------------------------------------------
4. A Closer Look at the 'useState' Hook:
------------------------------------------------------------------------------------
   > The useState() function registers some value as a state for the Component instance in which it is being called.
   > For example, if the <ExpenseItem /> Component is being used multiple times with its own separate data (State), the ExpenseItem Component function would then be called each time for each <ExpenseItem /> instance. Everytime the Component function is called a new separate state is created in the same way but managed independently by React.
   > Therefore, if you change the state data in one of the <ExpenseItem /> Component, the other <ExpenseItem /> instances will not be affected since each state is managed independently from one another.
   > It is important to remember that the useState() is on a per Component instance basis.
   > Consequently, whenever a state changes, it is only the Component instance that gets re-evaluated and re-draw that Component change to the screen.
   > When destructuring the useState elements we are assigning it to a const variable. This may seem strange to use a const variable because the state data may eventually be reassigned a new value? However, you need to keep in mind you are not assigning a value with the assignment operator (=). That would indeed fail. The state is updated by calling the special state updating function (e.g. setTitle()) which is managed by React elsewhere. React is managing the value for us and we never see that variable itself. Therefore, using the const variable is perfectly fine.
   > How do you get the latest state data? Keep in mind the Component function is re-executed when the state is updated and therefore the 'const [title, setTitle] = useState(props.title)' line of code is also executed again. React fetches the state data it is managing for us.
   > When React re-executes the Component function, you may think that the 'const [title, setTitle] = useState(props.title)' line of code will always override any state changes with the 'props.title'. However, React will keep track when useState() is called for the first time in a given Component instance.
   > When the useState() is called for the first time it will take the argument/parameter as the initial value but when the Component function is re-evaluated and the line of code is re-executed, React will not re-initialise the state. Instead, React will detect the state initialised in the past and it will grab the latest state and give that state instead.
   > React always provides the latest snapshot of the state whenever the Component function is evaluated and this is how useState() works under the hood.
   > Using State is simple but it is just as important that you understand how React State works under the hood (which will help you avoid running into problems in more complex React applications).
   > Note that the 'State' can be updated in many ways in React and not by user events only! While it is common for state to be updated upon a user event you can update the state for whatever reason for example on a HTTP request completing or because a timer (using setTimeout() JavaScript function) has expired.

------------------------------------------------------------------------------------
5. Adding Form Inputs:
------------------------------------------------------------------------------------
   > To gather user input to allow users to interact and add data into your application you would require to create a Form Input.
   > You would probably create the Form element into a new Component sub-folder to keep your Component building blocks organised.
   > You would use default HTML elements and attributes to build the HTML Form for your Component function in JSX.
   > Note: The <input /> element in React should be in a self-closing tag when you have no value between the <input> element tags. So you should use a self-closing tag.

   Input Form Component Example:
      src/components/NewExpense/NewExpense.js:
         import React from 'react';
         import ExpenseForm from './ExpenseForm';
         const NewExpense = (props) => {
            return (
               <div>
                  <ExpenseForm />
               </div>
            );
         };
         export default NewExpense;

      src/components/NewExpense/ExpenseForm.js:
         import React from 'react';
         import './ExpenseForm.css';
         const ExpenseForm = () => {
            return (
               <form>
                  <div className="new-expense__controls">
                     <div className="new-expense__control">
                        <label>Title</label>
                        <input type="text" />
                     </div>
                     <div className="new-expense__control">
                        <label>Amount</label>
                        <input type="number" min="0.01" step="0.01" />
                     </div>
                     <div className="new-expense__control">
                        <label>Date</label>
                        <input type="date" min="2021-01-01" max="20235-12-31" />
                     </div>
                  </div>
                  <div className="new_expense__actions">
                     <button type="submit">Add Expenses</button>
                  </div>
               </form>
            );
         };
         export default ExpenseForm;

   > Remember that you would need to use the <NewExpense /> Component in either the root App.js JSX code or another file which is called by the App.js JSX, ultimately allowing the NewExpense Component function to be executed in order to be rendered to the screen.
   > This is the first step of allowing users to interact with your application. The next step requires you to gather the user inputs in order to do something with it when the user submits the input form.

------------------------------------------------------------------------------------
6. Listening to User Input:
------------------------------------------------------------------------------------
   > You may wish to gather user input on every change to any of the inputs to your Form. For example on every keystroke you would want to gather the user input value and store that value somewhere to use later (e.g. console log the value to the console).
   > You would need to add listeners to listen for every keystroke or change to the input fields. You can do this by adding Reacts event listener attributes (i.e. Reacts 'on prop') on the input you wish to listen to. The question is what type of event do you want to listen to. For example: '<input type="text" onChange={titleChangeHandler} />'.
   > The onInput event listens to all keystroke events on a text input element. The onChange event is similar to the onInput i.e. it also listens to every keystroke but you are able to use this event listener on all input type.
   > Refer back to '1. Listening to Events & Working with Event Handlers' section on how to use React Events and Event Handlers.
   > Typically, you would want to get the value the user has entered in the input field.

   Vanilla JavaScript Input Gathering Example:
      > document.getElementByID('inputIdName').addEventListener('click', (event) => {...})

   > You would add an event listener to a HTML element which takes in two parameter. The first is an event to listen to e.g. the click event and the second is a function call to trigger on the event. In the anonymous function call, JavaScript provides you an event object which describes the event that occurred. This is the default JavaScript behaviour in the browser when you listen to events.
   > In React you also get this default event object as well and you do not need to do anything to get this event object.
   > When you pass the pointer to your event handler function for your React 'on prop' event listener, React (or more specifically the browser) will ensure that you get an 'event' object whenever the event occurs.

   React Event Handler Example:
      src/components/NewExpense/ExpenseForm.js:
         const ExpenseForm = () => {
            const titleChangeHandler = (event) => {
               consol.log(event);
               consol.log(event.target.value);
            };
            return (...);
         };

   > You can console.log() the event object to see what object is returned from the event. This object will have a bunch of data you can explore but the most interesting data for you is the target property.
   > The target property is an object which points at the DOM element for which the event occurred. The input element (in this instance) has a long list of properties which you can read and set.
   > The input element has a value property and this value property holds the current value of the input at the point in time the event occurred.
   > This allows you to use dot notation to drill into the event object to retrieve the users input value e.g. event.target.value.
   > Now that you can gather the user's input value the next step is to do something with that value when the user submits the input form.

------------------------------------------------------------------------------------
7. Working with Multiple States:
------------------------------------------------------------------------------------
   > To handle multiple states, you can call on the useState hook multiple times i.e. you can have multiple useState pieces per Component.
   > All the states inside of the same Component will also be separated from each other.

   Multiple useState Example:
      src/components/NewExpense/ExpenseForm.js:
         import React, { useState } from 'react';
         const ExpenseForm = () => {
            const [enteredTitle, setEnteredTitle] = useState('');
            const [enteredAmount, setEnteredAmount] = useState('');
            const [enteredDate, setEnteredDate] = useState('');

            const titleChangeHandler = (event) => {
               setEnteredTitle(event.target.value);
            };
            const amountChangeHandler = (event) => {
               setEnteredAmount(event.target.value);
            };
            const dateChangeHandler = (event) => {
               setEnteredDate(event.target.value);
            };
            return (...);
         };

   > You may have more than one state per Component and is perfectly fine to have separate States and manage/update them separately. This is a key part of the entire State concept that React ships with.

------------------------------------------------------------------------------------
8. Using One State vs Using Multiple States:
------------------------------------------------------------------------------------
   > While you can add multiple States to a Component there is an alternative method (which depends on your personal preference).
   > In the previous example, you could argue that all three states are related to the form and is storing user input i.e. the same concept repeated three times. Therefore, you could use one state instead of three separate states whereby you would pass in an object as the default value for the useState parameter.
   > The object is important because you can now group together multiple state values into one State in your Component.

   One State Holding Multiple State Values Example:
      src/components/NewExpense/ExpenseForm.js:
         import React, { useState } from 'react';
         const ExpenseForm = () => {
            const [userInput, setUserInput] =useState({
               enteredTitle: '',
               enteredAmount: '',
               enteredDate: ''
            });

            const titleChangeHandler = (event) => {
               setUserInput({
                  ...userInput,
                  enteredTitle: event.target.value
               });
            };
            const amountChangeHandler = (event) => {
               setUserInput({
                  ...userInput,
                  enteredAmount: event.target.value
               });
            };
            const dateChangeHandler = (event) => {
               setUserInput({
                  ...userInput,
                  enteredDate: event.target.value
               });
            };
            return (...);
         };

   > The difference with this approach is that whenever you update this state you will need to update all properties and not just the one.
   > If you updated only the one property in the object you would end up dumping/losing the previous object properties because React will not merge the new property with the old values (i.e. React will replace the old object State with the new object State value).
   > Therefore, using the One State approach is your responsibility to ensure any other state values are not lost when updating the State.
   > You can use JavaScript spread operator (...) to create a copy of the current object and then update the property that has changed in the copy object and then use the new copy object as the update value for the updated State value. This will ensure other values (which have not changed) are not lost when updating the State.
   > This is an alternative method of storing multiple state values within one useState rather than using multiple useState pieces.

------------------------------------------------------------------------------------
9. Updating State that Depends on the Previous State:
------------------------------------------------------------------------------------
   > In the previous example using the One State method it is not an entirely correct the way the object was being updated using the spread operator approach. While technically the approach would work but there are niche cases the approach would fail; thus, it would not be great practice to update th One State method as seen in the previous example.
   > The problem lies with when you need to depend on the previous State for updating the State. Therefore, whenever you update the State and you depend on the previous State you should use the method below:

   Updating State that Depends on the Previous State Example:
      src/components/NewExpense/ExpenseForm.js:
         import React, { useState } from 'react';
         const ExpenseForm = () => {
            const [userInput, setUserInput] =useState({
               enteredTitle: '',
               enteredAmount: '',
               enteredDate: ''
            });
            const titleChangeHandler = (event) => {
               setUserInput((prevState) => {
                  return { ...prevState, enteredTitle: event.target.value };
               });
            };
            ...
            return (...);
         };

   > You should pass in a function as a parameter to the useState 'set' function call. React will automatically call on this function and this function will receive the previous State snapshot for the State for which you are calling the update function for. You would then return the new State snapshot from your function.
   > You can now copy the previous State snapshot and then override the value that has changed.
   > While both approaches are fine when updating a One State that has multiple State, the latter is the better approach because React schedules State Updates and does not perform them instantly. Therefore, theoretically if you schedule a lot of State updates at the same time, you could end up depending on an old out-dated/incorrect State snapshot if you were to use the former approach.
   > Using the latter approach, React will guarantee that the State snapshot given in the inner anonymous function will always be the latest State snapshot keeping all scheduled State updates in mind.
   > This is the safer method to ensure that you are always operate on the latest State snapshot.
   > Therefore, whenever your state depends on the previous State, you should always use the inner function call syntax approach to update the State object.

------------------------------------------------------------------------------------
10. Handling Form Submission:
------------------------------------------------------------------------------------
   > At this point you should now have a form which can receive input from a user and you can save that input into a State. However, at this point you are not doing much with the State.
   > While you can add a 'onClick' listener on the <button> element it is not the best approach.
   > There is a default behaviour built into browsers and Forms on webpages. If a button with the type 'submit' is clicked inside of a Form, the overall <form> element will emit a 'submit' event to which you can listen to.
   > Therefore, on the form 'onSubmit' event you can execute some function whenever the form is actually submitted using the form's 'submit' button.

   Handling Form Submission Example:
      src/components/NewExpense/ExpenseForm.js:
         import React, { useState } from 'react';
         const ExpenseForm = () => {
            const [enteredTitle, setEnteredTitle] = useState('');
            const [enteredAmount, setEnteredAmount] = useState('');
            const [enteredDate, setEnteredDate] = useState('');
            const titleChangeHandler = (event) => { setEnteredTitle(event.target.value); };
            const amountChangeHandler = (event) => { setEnteredAmount(event.target.value); };
            const dateChangeHandler = (event) => { setEnteredDate(event.target.value); };
            const submitHandler = (event) => {
               event.preventDefault();
               const expenseData = {
                  title: enteredTitle,
                  amount: +enteredAmount,
                  date: new Date(enteredDate)
               };
               console.log(expenseData);
            };
            return (
               <form onSubmit={submitHandler}>
                  <div className="new-expense__controls">
                  ...
                  <div className="new_expense__actions">
                     <button type="submit">Add Expenses</button>
                  </div>
               </form>
            );
         };

   > Note that the above example uses the Multiple State methodology.
   > Unfortunately, a part of the default browser behaviour causes the webpage to reload whenever a form's submit button is clicked. The browser will automatically send a request whenever a form is submitted to the server that is hosting the webpage. This is not a behaviour we would want.
   > Instead, you would want to handle the Form submission with JavaScript to manually collect and combine the data to do something with the data.
   > Using the event object you can cancel the default behaviour using the preventDefault() method which is built into JavaScript by default.
   > The properties in the object can be named whatever you want but ultimately will point to the different useState values.
   > You should now have an object containing the submitted form data which you can now do something with such as the example above printing to the browser's console.
   > The '+' used before 'enteredAmount' is used to ensure JavaScript enforces a number conversion otherwise when adding multiple values, those values would be added as strings instead of numbers.

------------------------------------------------------------------------------------
11. Adding Two-Way Binding:
------------------------------------------------------------------------------------
   > Using State provides an advantage over using global variable inside your Component JavaScript files.
   > State allows you to implement something called 'Two-Way Binding'.
   > 'Two-Way Binding' simply means, for inputs, you do not only listen to changes but you can also pass a new value back into the input.
   > 'Two-Way Binding' allows you to reset or change the input value programmatically.
   > Simply add the 'value' attribute (which is a default HTML attribute property) to the <input> element. This will set the internal input value that every <input> element has.
   > You can use JSX to bind to the State property value.

   Two-Way Binding Example:
      src/components/NewExpense/ExpenseForm.js:
         import React, { useState } from 'react';
         const ExpenseForm = () => {
            const [enteredTitle, setEnteredTitle] = useState('');
            const titleChangeHandler = (event) => { setEnteredTitle(event.target.value); };
            ...
            const submitHandler = (event) => {
               ...
               setEnteredTitle('');
            };
            return (
               <form onSubmit={submitHandler}>
                  <div className="new-expense__control">
                     <label>Title</label>
                     <input type="text" value={enteredTitle} onChange={titleChangeHandler} />
                  </div>
                  ...
                  <div className="new_expense__actions">
                     <button type="submit">Add Expenses</button>
                  </div>
               </form>
            );
         };

   > In the example above, the enteredTitle State property value is being used to Two-Way bind the data to the Title input element.
   > The <input> element not only listens for 'onChange' events to update the 'enteredTitle' State but it now also feeds back into the input so that when you change the input State you are also changing the input 'value' attribute. This may sound like an infinite loop but it is not and will not have a problem with 'Two-Way Binding'.
   > This provides you with the advantage of being able to reset the input fields when the form is submitted as demonstrated in the example with setEnteredTitle(''); in the submitHandler function.
   > 'Two-Way Binding' is another key concept in React when working with Forms.

------------------------------------------------------------------------------------
12. Child to Parent Component Communication (Bottom-Up)
------------------------------------------------------------------------------------
   > Up to this point you should now know how to pass data down from the Parent Component to the Child Component (Top-Down)
      - Refer back to "React Basics & Foundation - 2. React Basics & Working with Components 10. Passing Data via Props".
   > There will be times when you need to pass the data from a Child Component to the Parent Component (Bottom-Up).
   > You can think of the <input> element as a Component i.e it is not one of your own custom Component but rather a pre-built Component provided to us by React and translated to the <input> DOM element. This has a Component character at the end of the day. You can set props on this Component including the special 'onChange' prop which wants a function as a value. Internally, the the input adds a 'change' listener on the rendered input element. This is a pattern you can replicate on your own Components as well.
   > You can create your own event props and expect functions as values which would then allow you to pass a function from a Parent Component to a Child Component and then call that function inside of the Child Component. When you then call the function you can then pass data into the function as a parameter.
   > This pattern allows you to communicate up from the Child Component to the Parent Component.
   > Important to Remember: props can only be passed from Parent to Child and you cannot skip intermediary Components.

   Child To Parent (Bottom-Up) Example:
      src/components/NewExpense/NewExpense.js:
         import React from 'react';
         import ExpenseForm from './ExpenseForm';
         const NewExpense = () => {
            const saveExpenseDataHandler = (enteredExpenseData) => {
               const expenseData = {
                  ...enteredExpenseData,
                  id: Math.random().toString()
               };
               console.log(expenseData);
            };
            return (
               <div className="new-expense">
                  <ExpenseForm onSaveExpenseData={saveExpenseDataHandler} />
               </div>
            );
         };

      src/components/NewExpense/ExpenseForm.js:
         import React, { useState } from 'react';
         import './ExpenseForm.css';
         const ExpenseForm = (props) => {
            ...
            const submitHandler = (event) => {
               event.preventDefault();
               const expenseData = {
                  title: enteredTitle,
                  amount: +enteredAmount,
                  date: new Date(enteredDate)
               };
               props.onSaveExpenseData(expenseData);
               ...
            };
            return (...);
         };

   Parent:
   > The function parameter would expect some data. The parameter can be named anything you want as it is your function but it should be clear what data is being received (e.g. enteredExpenseData).
   > In the example above the saveExpenseDataHandler will receive the enteredExpenseData which will come from the Child Component. We can copy this object data using the spread operator and also add more properties to the new copied object (e.g. the id property).
   > Note: Math.random() is used for demonstration purpose for a random value but will not create unique id values.
   > The naming convention using 'on' (e.g. 'onSaveExpenseData') should clearly indicate the value for the 'prop' is a function which will eventually be triggered when something happens inside of the Component. However, you could name the 'prop' whatever you want and do not need to follow this naming convention of starting with 'on'.
   > The 'prop' should point to the function to be called (and not executed e.g. saveExpenseDataHandler()) when the event is triggered.
   > The second step requires you to use the function inside of the custom component manually.
   > This second step was not required for the <input> Component because these are built-in Components. The 'onChange' prop takes in a function and React internally will add a listener and call the function you pass in whenever the change event occurs.

   Child:
   > Inside of the <ExpenseForm /> Child Component you can now expect the onSaveExpenseData 'prop' because it is being set when you use the <ExpenseForm /> Custom Component.
   > Inside of the ExpenseForm.js file you can now extract the value passed for the 'prop' i.e. the function saveExpenseDataHandler.
   > Inside of the ExpenseForm you now expect to receive some 'props' which is passed as a parameter to the Component function.
   > Inside of the ExpenseForm's submitHandler function you can access from the 'props' parameter object the 'onSaveExpenseData' to execute the event.
   > The saveExpenseDataHandler function defined in the NewExpense Parent Component file will execute from a different Component file i.e. when the ExpenseForm Child Component's submitHandler function is triggered via the Forms submit event.
   > The saveExpenseDataHandler can be executed from the ExpenseForm Child Component file because you are passing a pointer to the function through the onSaveExpenseData prop.
   > The saveExpenseDataHandler function expects to receive a argument/parameter which you can pass the data from the Child Component i.e. the expenseData object from ExpenseForm.
   > The Parent now has the data from the Child.

   > This is a very important pattern to remember because you will use this pattern a lot in React. This is how you can communicate between Components in both Top-Down and Bottom-Up directions.
   > The importance of the pattern relies on passing a pointer at the Parent's function to the Child Component which allows the function to be called by the Child Component which can then pass the data to this function.
   > The chain can continue up the Component Tree as seen below between NewExpense,js and App.js Component files.

   Child To Parent (Bottom-Up) Chaining Example:
      src/App.js:
         import React from 'react';
         import Expenses from './components/Expenses/Expenses';
         import NewExpense from './components/NewExpense/NewExpense';
         const App = () => {
            ...
            const addExpenseHandler = expense => {
               console.log('In App.js');
               console.log(expense);
            };
            return (
               <div>
                  <NewExpense onAddExpense={addExpenseHandler} />
                  <Expenses items={expenses} />
               </div>
            );
         };

      src/components/NewExpense/NewExpense.js:
         import React from 'react';
         import ExpenseForm from './ExpenseForm';
         const NewExpense = (props) => {
            const saveExpenseDataHandler = (enteredExpenseData) => {
               const expenseData = {
                  ...enteredExpenseData,
                  id: Math.random().toString()
               };
               props.onAddExpense(expenseData);
            };
            return (
               <div className="new-expense">
                  <ExpenseForm onSaveExpenseData={saveExpenseDataHandler} />
               </div>
            );
         };

      src/components/NewExpense/ExpenseForm.js:
         import React, { useState } from 'react';
         import './ExpenseForm.css';
         const ExpenseForm = (props) => {
            ...
            const submitHandler = (event) => {
               event.preventDefault();
               const expenseData = {
                  title: enteredTitle,
                  amount: +enteredAmount,
                  date: new Date(enteredDate)
               };
               props.onSaveExpenseData(expenseData);
               ...
            };
            return (...);
         };

------------------------------------------------------------------------------------
13. Lifting the State Up
------------------------------------------------------------------------------------
   > 'The Child to Parent Component Communication' concept is very important in React and it is closely related to another concept called 'Lifting the State Up'.

   Example Component Tree:
                                                [This component has access
                                                to both involved components]
                                                         App.js
                              -------------------------- [State] <---------------------------|
                              |           __________________|__________________              |
    Pass State Data via Props |           |                                   |              | "Lifting the state up"
                              |      <Expenses />                        <NewExpense />      |
                              |---> [Data/State is                      [Data/State is  _____|
                                    needed here]                        generated here]

   > Consider the above basic component tree where the App Component which in turn renders an Expenses Component and a NewExpense Component.
   > The NewExpense Component is a component which generates some data/state (i.e. fetching some user input). 
   > It is quite common that you generate or fetch data in a Component but you might not need that data in that Component. Instead, you need that data in another Component (e.g. in the Expenses Component).
   > Naturally you would like to hand that data over across to the other Component. However, it does not work like this because there is no direct connection between two sibling Components.
   > You can only communicate from Parent to Child and vice versa.
   > Therefore, you would utilise the closest Parent Component which has direct or indirect access to both involved Components.
   > The App Component has direct access to both the Expenses and NewExpense Components because it renders both Components in it's returned JSX code.
   > You can store the State in the closest involved component by "lifting the state up".
   > This is done by utilising 'props' i.e by calling on a function and then by passing the data into the called function. This lifts the data/state up.
   > The data can then be passed down to another Component from the Parent Component via props.
   > 'Lifting the State Up' is another very important concept/term to understand when working with React.
   > Remember: 'Lifting the State Up' term is all about moving Data/State from a Child Component to some Parent Component to either use it in the Parent Component or to then pass it down to some other Child Component.
   > It is not always the root App Component to which you want to lift your Data/State up. Instead, the goal is to lift the Data/State up as high as necessary in your Component Tree until you have a Component which has both access to the Components that generates the Data/State as well as the Component that needs that data.

------------------------------------------------------------------------------------
14. Controlled vs Uncontrolled Components & Stateless vs Stateful Components
------------------------------------------------------------------------------------
   Component Terminology:
      Controlled Components:
         > Whenever you use 'Two-Way Binding' on your Component, this is known as Controlling a Component (i.e. Controlled Component).
         > Controlled Component means both the value and changes to the value are not handled in the Component itself but rather in a Parent Component.
         > Therefore, where a value is used in a Component (e.g. a value from a dropdown) is passed on to a Parent Component through 'props' and is received from a Parent Component. Both the currently set value as well as the function that handles the selected value is not part of that Component. The Component (i.e. Child Component) is really just a Component which presents the the value (e.g. the dropdown) and attaches a couple of listeners and/or 'props'. The real logic resides in the Parent Component. This turns the Child Component into what is known as a Controlled Component.
         > For example, the child <ExpensesFilter /> component which is responsible for the dropdown selection of year filter is turned into a Controlled Component to the parent <Expenses /> Component.
         > Controlled Component is just a special term used to describe a Component type within React.

      Uncontrolled Components:
         > The Component's is independent from any other Components i.e. it does not use "Two-Way Binding".

      Presentational/Stateless/Dumb Components:
         > Components which do not manage some Data/State are known as Stateless or Dumb Components. The Component is purely presentational to output some data.

         Stateless Component Example:
            src/components/Expenses/ExpenseItem.js:
               import React from 'react';
               import ExpenseDate from './ExpenseDate';
               import Card from '../UI/Card';
               const ExpenseItem = (props) => {
                  return (
                     <Card className="expense-item">
                        <ExpenseDate date={props.date} />
                        <div className="expense-item__description">
                           <h2>{props.title}</h2>
                           <div className="expense-item__price">£{props.amount}</div>
                        </div>
                     </Card>
                  );
               };

      Stateful/Smart Components:
         > Components which manages some Data/State are known as Stateful or Smart Components.
         > Any Component that uses the useState hook is known as a Stateful Component because it is now managing some Data/State within the Component.
         > You may pass these Data/State to other Components (i.e. Stateless Components) to display the values.

         Stateful Component Example:
            src/components/Expenses/Expenses.js:
               import React, {useState} from 'react';
               import ExpenseItem from './ExpenseItem';
               import ExpensesFilter from './ExpensesFilter';
               import Card from '../UI/Card';
               const Expenses = (props) => {
                  const [filteredYear, setFilteredYear] = useState('2021');
                  const filterChangeHandler = selectedYear => {
                     setFilteredYear(selectedYear);
                  };
                  return (
                     <div>
                        <Card className="expenses">
                           <ExpensesFilter selected={filteredYear} onFilterChange={filterChangeHandler} />
                           <ExpenseItem title={ props.items[0].title} amount={props.items[0].amount} date={props.items[0].date } />
                           <ExpenseItem title={ props.items[1].title} amount={props.items[1].amount} date={props.items[1].date } />
                        </Card>
                     </div>
                  );
               };

   Stateless vs Stateful Components:
      > In most React applications you will have more Stateless/Dumb Components. While 'Dumb' may seem negative and that Stateful Components may be better this is not the case. These are just terms to describe Components within your React application.
      > Typically you will end up with less Stateful Components than Stateless Components because you would want to split up your application into small re-usable pieces and most pieces/components will only focus on outputting something.