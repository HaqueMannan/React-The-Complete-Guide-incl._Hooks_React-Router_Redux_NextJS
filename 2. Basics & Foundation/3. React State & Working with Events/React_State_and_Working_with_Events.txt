React State & Working with Events - Summary:
1. Listening to Events & Working with Event Handlers
2. How Component Functions are Executed
3. Working with 'State'

------------------------------------------------------------------------------------
1. Listening to Events & Working with Event Handlers:
------------------------------------------------------------------------------------
   > On all built-in HTML elements (such as <div>, <h1>, <button>, etc) you have full access to the native DOM events which you can listen to.
   > You can use the Mozilla Developer Web Doc website to search for HTML elements for example the <button> element (https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button) to find an article about the HTML element. You may find a link to the DOM interface for the element (e.g. https://developer.mozilla.org/en-US/docs/Web/API/HTMLButtonElement).
   > You can see from which other elements/classes the element inherits from and you will notice the HTMLButtonElement is a more specific form of the HTMLElement, which is a more specific form of the Element, which is a more specific form of the Node and so on until it reaches the root class.
   > If you click on Elements for instance, you will see that there are a bunch of events (https://developer.mozilla.org/en-US/docs/Web/API/Element#events) you can listen to such as click and blur.
   > For all the default HTML Events there is a 'Prop' equivalent in React.
   > Instead of using the normal JavaScript method for listening to an HTMLElement event for example:

   JavaScript HTML Event Listener Example:
      document.getElementByID('root').addEventListener();

   > In React you would go to the JSX element within the Component file and add a special 'Prop'.
   > The 'Prop' is not a a prop which sets some value for the element but it is instead a prop that starts with the 'on' keyword. React exposes all the default events as props with 'on' keyword in front of the event listener name for example onClick is Reacts equivalent to the default click event (the event listener name must start with a capital letter).

   React HTML Event Listener Example:
      const ExpenseItem = (props) => {
         const clickHandler = () => console.log('Clicked');
         return(
            <button onClick={clickHandler}>Change Title</button>
         );
      };

   > When you add a React 'on' prop event listener to a JSX element, you need to define what should happen when the event occurs. You do this by assigning a value to the event listener 'on Prop'.
   > The value you assign has to be code that should be executed with the event occurs i.e. you would assign a function. All React 'on Prop' event handlers want a function as a value, so that it can execute the function when the event occurs.
   > You can either create the function on the fly using an anonymous function such as: 
      <button onClick={function() {console.log('Clicked!')}}>Change Title</button>
      <button onClick={() => {console.log('Clicked!')}}>Change Title</button>
   > Typically you would not want to work with anonymous inline functions because this could bloat the code within your JSX code within your Component file. Instead, you would want to define your function before the return JSX code. the React event handler 'on Prop' will point to the function and React JSX uses curly brackets to inject basic JavaScript expressions as seen in the above example code.
   > It is important that you point at the function and not execute it (onClick={clickHandler()} would execute the function when you add the round brackets after the function name).
   > The reason you would not add round brackets after the function name when you reference the function in the 'on prop' value is because JavaScript would execute the function when the line of code is being parsed when the JSX code is being returned. This would result in the function being executed too early and is also the reason why you would just point at the function by passing in the pointer to the function. React will memorise the pointer and can execute the function for us whenever the event occurs.
   > This is how you can add Event Listeners and Event Handlers in React Components.
   > Important Note: some events are available on every elements while other events are available on specific elements but it is all based on the default DOM interface behaviour.
   > It is common practice to name your Event Handler functions with 'Handler' at the end of the function name. This will help make it clear that the function is attached and called on an React event handler and will be executed by react when the event occurs. However, this is a preferential naming convention for Event Handler functions which you may follow.

------------------------------------------------------------------------------------
2. How Component Functions are Executed:
------------------------------------------------------------------------------------
   > Reacting to events is an important first step. How can you change what shows up on the screen?
   > Using the previous button example, we want to change the title of an element when the button is clicked. You may think the below example would work:

   (Incorrect) Changing Title Event Handler Example:
      const ExpenseItem = (props) => {
         let title = props.title;
         const clickHandler = () => { title = 'Updated!'};

         return(
            <div>
               <h2>{title}</h2>
               <button onClick={clickHandler}>Change Title</button>
            <div>
         );
      };

   > You would think the onClick event handler would change the <h2> element text value to 'Updated!' when the <button> element is clicked, triggering the onClick event handler function. You would think that by initially storing the props.title value in the variable called title, you can change the value of the variable via the clickHandler function and because the <h2> element points at the title variable this should update what is displayed on screen when the button is clicked. However, this does not work in React. Why is this happening?
   > Note that the clickHandler function is being triggered when the button is clicked (which can be proved by adding a console.log(title) in the Event Handler function). Therefore, there is no issue with the execution of the function. So why do we not see that reflected in the DOM because after all you are displaying the title variable value?
   > It is simply because React does not operate like this.

   > Keep in mind your React Component is a regular JavaScript function. The only special feature of your function is that it returns JSX.
   > Since it is a function someone has to call it. You will notice that you never call your Component function. Instead, you use the Components (functions) like HTML elements in the JSX code. for example <ExpenseItem/>
   > Under the hood this is almost like a function call - by using your Components in the JSX code, you make React aware of your Component functions. Whenever React evaluates the JSX code, it will call the Component functions. The Component functions itself returns JSX code which are also evaluated up until there are no more JSX code (i.e. functions) left to be evaluated.
   > After it has executed all JSX code, React then evaluate the overall results and then translates that into DOM instructions which renders the output to the screen.
   > This is how React works and it is all triggered off with the root index.js file (i.e. the 'main' function execution of the app) where you initially point at the <App /> Component function. The only problem with this is that React never repeats this process. It only executes once when the application is initially rendered but thereafter it is done.
   > We need a way to tell React that something has changed and that a certain Component should be re-evaluated. This is where React introduces a special concept called 'State'.

------------------------------------------------------------------------------------
3. Working with 'State':
------------------------------------------------------------------------------------
   > 'State' is not a React specific concept but it is a key concept in React.
   > When data in a Component changes and that change should result in the Component being re-evaluated in order to re-render what is drawn on the screen when the data changes, State is important.
   > Regular variables does not trigger a re-evaluation. React does not care about changes to regular variables.
   > To tell React that it should run the re-evaluation process again, we would need to import something from the 'react' library.
   > We do this by adding a so-called named import which is done by using curly brackets and selecting specific named things from the library that has been exported.

   Importing Named Import Syntax Example:
      import React, { useState } from 'react';

   > Notice that the 'React' object is the default export for the 'react' library. The single pieces within the curly brackets are named imports i.e. things such as variables, functions, objects, etc. that have been exported by the library.
   > The 'useState' named import is a function provided by the 'react' library. This function allows us to define values as 'State' where changes to these values should reflect in the Component function being called again for re-evaluation. This is the key difference to regular variables that you would define in the Component file.

   Using State Example:
      import React, { useState } from 'react';
      const ExpenseItem = (props) => {
         useState(props.title);
         const clickHandler = () => console.log('Clicked');
         return(
            <button onClick={clickHandler}>Change Title</button>
         );
      };

   > To use the useState function, you simply call the useState() function within your Component function as seen above.
   > The useState is a so-called 'React-Hook' and there are other 'React-Hooks'. React-Hooks can be recognised as they all start with the 'use' keyword in their function names.
   > React-Hook must only be called inside of React Component functions and they should not be called in any nested functions i.e. they can only be called directly inside the Component functions. Below are examples of incorrect calls:

   (Incorrect) Outside Component Functions Example:
      import React, { useState } from 'react';
      useState();
      const ExpenseItem = (props) => {
         ...
      };

   (Incorrect) Inside Nested Component Functions Example:
      import React, { useState } from 'react';
      const ExpenseItem = (props) => {
         const clickHandler = () => {
            useState();
            console.log('Clicked');
         }
         ...
      };

   > The useState should be called inside of the ExpenseItem Component function as correctly demonstrated in the 'Using State Example'. However, there is one exception to this rule which we will revisit later.
   > React-Hooks is a new feature introduced by the React team and is a topic in itself.

   > The useState(); function requires a default state value as an argument/parameter. This is because with the useState() function, you create a special type of variable i.e. a variable where changes would lead to the Component function to be re-called again for re-evaluation. For Example:
      useState(props.title);
   > The useState() function also returns something which gives us access to this special variable but also a special function that you can call to assign a new value to the variable.
   > Therefore, you will no longer be assigning values using the normal assign operator (=) to this special variable as you would with the regular variables, but rather you would use a special function instead. This is how the useState() variable works.
   > The useState() function actually returns an array where the first value is the special variable itself and the second value is the update function.
   > You can therefore use a modern JavaScript feature called array destructuring to store both elements in separate variables (the name of the destructed variables does not matter but the ordering does).

   Destructuring useState Syntax Example:
      import React, { useState } from 'react';
      const ExpenseItem = (props) => {
         const [title, setTitle] = useState(props.title);
         const clickHandler = () => {
            setTitle('Updated!');
            console.log(title);
         };
         return(
            <button onClick={clickHandler}>Change Title</button>
         );
      };

   > The first element is the pointer to the managed variable (i.e. the default state value passed ito the function i.e. props.title) while the second element is the function that you can later call to set a new value to the managed variable.
   > The common naming convention for the destructed variables names is to use something that describes the value for the name of the first element (e.g. title) and then use the 'set' keyword followed by the first element name repeated for the name of the second element (e.g. setTitle).
   > The useState() function always returns exactly two elements where the first element is the current state value and the second element is the function to update that state value.
   > To set a new value, you will call the special function passing in the value as an argument.
   > React manages the special variable somewhere in memory which the special function will update.
   > Calling this special function does not only assign a new value to the special variable, but the Component function in which you called the special function will be executed again. Therefore, the Component function will be recalled again whenever the State changes.
   > This is you would tell React that you want to assign a new value to the 'State' and that then tells React that the Component, in which the 'State' was registered with, should be re-evaluated. This will then execute the Component function again and re-evaluate the JSX code again. This will draw any changes to the text compared to tha last time it evaluated the Component function onto the screen.
   > You will notice when the button is clicked, the console.log(title) will display the previous value for the <ExpenseItem /> before it updated. This is because calling the state updating function actually does not change the value right away but instead schedules the state update. Therefore, the new value is not available yet which is why you would see the previous value being concole.log() even though you updated it (i.e. setTitle('Updated!)) before logging the value. You would see the change on the screen because the Component is eventually re-evaluated and re-drawn to the screen.
   > This is how React State works and is another key concept in React.
   > If you have data which might change and where changes to that data should be reflected on the user interface, you then require State because regular variables will not work in React.