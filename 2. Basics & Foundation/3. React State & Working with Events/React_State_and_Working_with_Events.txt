React State & Working with Events - Summary:
1. Listening to Events & Working with Event Handlers
2. How Component Functions are Executed
3. Working with 'State'
4. A Closer Look at the 'useState' Hook
5. Adding Form Inputs
6. Listening to User Input
7. Working with Multiple States
8. Using One State vs Using Multiple States

------------------------------------------------------------------------------------
1. Listening to Events & Working with Event Handlers:
------------------------------------------------------------------------------------
   > On all built-in HTML elements (such as <div>, <h1>, <button>, etc) you have full access to the native DOM events which you can listen to.
   > You can use the Mozilla Developer Web Doc website to search for HTML elements for example the <button> element (https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button) to find an article about the HTML element. You may find a link to the DOM interface for the element (e.g. https://developer.mozilla.org/en-US/docs/Web/API/HTMLButtonElement).
   > You can see from which other elements/classes the element inherits from and you will notice the HTMLButtonElement is a more specific form of the HTMLElement, which is a more specific form of the Element, which is a more specific form of the Node and so on until it reaches the root class.
   > If you click on Elements for instance, you will see that there are a bunch of events (https://developer.mozilla.org/en-US/docs/Web/API/Element#events) you can listen to such as click and blur.
   > For all the default HTML Events there is a 'Prop' equivalent in React.
   > Instead of using the normal JavaScript method for listening to an HTMLElement event for example:

   JavaScript HTML Event Listener Example:
      document.getElementByID('root').addEventListener();

   > In React you would go to the JSX element within the Component file and add a special 'Prop'.
   > The 'Prop' is not a a prop which sets some value for the element but it is instead a prop that starts with the 'on' keyword. React exposes all the default events as props with 'on' keyword in front of the event listener name for example onClick is Reacts equivalent to the default click event (the event listener name must start with a capital letter).

   React HTML Event Listener Example:
      const ExpenseItem = (props) => {
         const clickHandler = () => console.log('Clicked');
         return(
            <button onClick={clickHandler}>Change Title</button>
         );
      };

   > When you add a React 'on' prop event listener to a JSX element, you need to define what should happen when the event occurs. You do this by assigning a value to the event listener 'on Prop'.
   > The value you assign has to be code that should be executed with the event occurs i.e. you would assign a function. All React 'on Prop' event handlers want a function as a value, so that it can execute the function when the event occurs.
   > You can either create the function on the fly using an anonymous function such as: 
      <button onClick={function() {console.log('Clicked!')}}>Change Title</button>
      <button onClick={() => {console.log('Clicked!')}}>Change Title</button>
   > Typically you would not want to work with anonymous inline functions because this could bloat the code within your JSX code within your Component file. Instead, you would want to define your function before the return JSX code. the React event handler 'on Prop' will point to the function and React JSX uses curly brackets to inject basic JavaScript expressions as seen in the above example code.
   > It is important that you point at the function and not execute it (onClick={clickHandler()} would execute the function when you add the round brackets after the function name).
   > The reason you would not add round brackets after the function name when you reference the function in the 'on prop' value is because JavaScript would execute the function when the line of code is being parsed when the JSX code is being returned. This would result in the function being executed too early and is also the reason why you would just point at the function by passing in the pointer to the function. React will memorise the pointer and can execute the function for us whenever the event occurs.
   > This is how you can add Event Listeners and Event Handlers in React Components.
   > Important Note: some events are available on every elements while other events are available on specific elements but it is all based on the default DOM interface behaviour.
   > It is common practice to name your Event Handler functions with 'Handler' at the end of the function name. This will help make it clear that the function is attached and called on an React event handler and will be executed by react when the event occurs. However, this is a preferential naming convention for Event Handler functions which you may follow.

------------------------------------------------------------------------------------
2. How Component Functions are Executed:
------------------------------------------------------------------------------------
   > Reacting to events is an important first step. How can you change what shows up on the screen?
   > Using the previous button example, we want to change the title of an element when the button is clicked. You may think the below example would work:

   (Incorrect) Changing Title Event Handler Example:
      const ExpenseItem = (props) => {
         let title = props.title;
         const clickHandler = () => { title = 'Updated!'};

         return(
            <div>
               <h2>{title}</h2>
               <button onClick={clickHandler}>Change Title</button>
            <div>
         );
      };

   > You would think the onClick event handler would change the <h2> element text value to 'Updated!' when the <button> element is clicked, triggering the onClick event handler function. You would think that by initially storing the props.title value in the variable called title, you can change the value of the variable via the clickHandler function and because the <h2> element points at the title variable this should update what is displayed on screen when the button is clicked. However, this does not work in React. Why is this happening?
   > Note that the clickHandler function is being triggered when the button is clicked (which can be proved by adding a console.log(title) in the Event Handler function). Therefore, there is no issue with the execution of the function. So why do we not see that reflected in the DOM because after all you are displaying the title variable value?
   > It is simply because React does not operate like this.

   > Keep in mind your React Component is a regular JavaScript function. The only special feature of your function is that it returns JSX.
   > Since it is a function someone has to call it. You will notice that you never call your Component function. Instead, you use the Components (functions) like HTML elements in the JSX code. for example <ExpenseItem/>
   > Under the hood this is almost like a function call - by using your Components in the JSX code, you make React aware of your Component functions. Whenever React evaluates the JSX code, it will call the Component functions. The Component functions itself returns JSX code which are also evaluated up until there are no more JSX code (i.e. functions) left to be evaluated.
   > After it has executed all JSX code, React then evaluate the overall results and then translates that into DOM instructions which renders the output to the screen.
   > This is how React works and it is all triggered off with the root index.js file (i.e. the 'main' function execution of the app) where you initially point at the <App /> Component function. The only problem with this is that React never repeats this process. It only executes once when the application is initially rendered but thereafter it is done.
   > We need a way to tell React that something has changed and that a certain Component should be re-evaluated. This is where React introduces a special concept called 'State'.

------------------------------------------------------------------------------------
3. Working with 'State':
------------------------------------------------------------------------------------
   > 'State' is not a React specific concept but it is a key concept in React.
   > When data in a Component changes and that change should result in the Component being re-evaluated in order to re-render what is drawn on the screen when the data changes, State is important.
   > Regular variables does not trigger a re-evaluation. React does not care about changes to regular variables.
   > To tell React that it should run the re-evaluation process again, we would need to import something from the 'react' library.
   > We do this by adding a so-called named import which is done by using curly brackets and selecting specific named things from the library that has been exported.

   Importing Named Import Syntax Example:
      import React, { useState } from 'react';

   > Notice that the 'React' object is the default export for the 'react' library. The single pieces within the curly brackets are named imports i.e. things such as variables, functions, objects, etc. that have been exported by the library.
   > The 'useState' named import is a function provided by the 'react' library. This function allows us to define values as 'State' where changes to these values should reflect in the Component function being called again for re-evaluation. This is the key difference to regular variables that you would define in the Component file.

   Using State Example:
      import React, { useState } from 'react';
      const ExpenseItem = (props) => {
         useState(props.title);
         const clickHandler = () => console.log('Clicked');
         return(
            <button onClick={clickHandler}>Change Title</button>
         );
      };

   > To use the useState function, you simply call the useState() function within your Component function as seen above.
   > The useState is a so-called 'React-Hook' and there are other 'React-Hooks'. React-Hooks can be recognised as they all start with the 'use' keyword in their function names.
   > React-Hook must only be called inside of React Component functions and they should not be called in any nested functions i.e. they can only be called directly inside the Component functions. Below are examples of incorrect calls:

   (Incorrect) Outside Component Functions Example:
      import React, { useState } from 'react';
      useState();
      const ExpenseItem = (props) => {
         ...
      };

   (Incorrect) Inside Nested Component Functions Example:
      import React, { useState } from 'react';
      const ExpenseItem = (props) => {
         const clickHandler = () => {
            useState();
            console.log('Clicked');
         }
         ...
      };

   > The useState should be called inside of the ExpenseItem Component function as correctly demonstrated in the 'Using State Example'. However, there is one exception to this rule which we will revisit later.
   > React-Hooks is a new feature introduced by the React team and is a topic in itself.

   > The useState(); function requires a default state value as an argument/parameter. This is because with the useState() function, you create a special type of variable i.e. a variable where changes would lead to the Component function to be re-called again for re-evaluation. For Example:
      useState(props.title);
   > The useState() function also returns something which gives us access to this special variable but also a special function that you can call to assign a new value to the variable.
   > Therefore, you will no longer be assigning values using the normal assign operator (=) to this special variable as you would with the regular variables, but rather you would use a special function instead. This is how the useState() variable works.
   > The useState() function actually returns an array where the first value is the special variable itself and the second value is the update function.
   > You can therefore use a modern JavaScript feature called array destructuring to store both elements in separate variables (the name of the destructed variables does not matter but the ordering does).

   Destructuring useState Syntax Example:
      import React, { useState } from 'react';
      const ExpenseItem = (props) => {
         const [title, setTitle] = useState(props.title);
         const clickHandler = () => {
            setTitle('Updated!');
            console.log(title);
         };
         return(
            <button onClick={clickHandler}>Change Title</button>
         );
      };

   > The first element is the pointer to the managed variable (i.e. the default state value passed ito the function i.e. props.title) while the second element is the function that you can later call to set a new value to the managed variable.
   > The common naming convention for the destructed variables names is to use something that describes the value for the name of the first element (e.g. title) and then use the 'set' keyword followed by the first element name repeated for the name of the second element (e.g. setTitle).
   > The useState() function always returns exactly two elements where the first element is the current state value and the second element is the function to update that state value.
   > To set a new value, you will call the special function passing in the value as an argument.
   > React manages the special variable somewhere in memory which the special function will update.
   > Calling this special function does not only assign a new value to the special variable, but the Component function in which you called the special function will be executed again. Therefore, the Component function will be recalled again whenever the State changes.
   > This is you would tell React that you want to assign a new value to the 'State' and that then tells React that the Component, in which the 'State' was registered with, should be re-evaluated. This will then execute the Component function again and re-evaluate the JSX code again. This will draw any changes to the text compared to tha last time it evaluated the Component function onto the screen.
   > You will notice when the button is clicked, the console.log(title) will display the previous value for the <ExpenseItem /> before it updated. This is because calling the state updating function actually does not change the value right away but instead schedules the state update. Therefore, the new value is not available yet which is why you would see the previous value being concole.log() even though you updated it (i.e. setTitle('Updated!)) before logging the value. You would see the change on the screen because the Component is eventually re-evaluated and re-drawn to the screen.
   > This is how React State works and is another key concept in React.
   > If you have data which might change and where changes to that data should be reflected on the user interface, you then require State because regular variables will not work in React.

------------------------------------------------------------------------------------
4. A Closer Look at the 'useState' Hook:
------------------------------------------------------------------------------------
   > The useState() function registers some value as a state for the Component instance in which it is being called.
   > For example, if the <ExpenseItem /> Component is being used multiple times with its own separate data (State), the ExpenseItem Component function would then be called each time for each <ExpenseItem /> instance. Everytime the Component function is called a new separate state is created in the same way but managed independently by React.
   > Therefore, if you change the state data in one of the <ExpenseItem /> Component, the other <ExpenseItem /> instances will not be affected since each state is managed independently from one another.
   > It is important to remember that the useState() is on a per Component instance basis.
   > Consequently, whenever a state changes, it is only the Component instance that gets re-evaluated and re-draw that Component change to the screen.
   > When destructuring the useState elements we are assigning it to a const variable. This may seem strange to use a const variable because the state data may eventually be reassigned a new value? However, you need to keep in mind you are not assigning a value with the assignment operator (=). That would indeed fail. The state is updated by calling the special state updating function (e.g. setTitle()) which is managed by React elsewhere. React is managing the value for us and we never see that variable itself. Therefore, using the const variable is perfectly fine.
   > How do you get the latest state data? Keep in mind the Component function is re-executed when the state is updated and therefore the 'const [title, setTitle] = useState(props.title)' line of code is also executed again. React fetches the state data it is managing for us.
   > When React re-executes the Component function, you may think that the 'const [title, setTitle] = useState(props.title)' line of code will always override any state changes with the 'props.title'. However, React will keep track when useState() is called for the first time in a given Component instance.
   > When the useState() is called for the first time it will take the argument/parameter as the initial value but when the Component function is re-evaluated and the line of code is re-executed, React will not re-initialise the state. Instead, React will detect the state initialised in the past and it will grab the latest state and give that state instead.
   > React always provides the latest snapshot of the state whenever the Component function is evaluated and this is how useState() works under the hood.
   > Using State is simple but it is just as important that you understand how React State works under the hood (which will help you avoid running into problems in more complex React applications).
   > Note that the 'State' can be updated in many ways in React and not by user events only! While it is common for state to be updated upon a user event you can update the state for whatever reason for example on a HTTP request completing or because a timer (using setTimeout() JavaScript function) has expired.

------------------------------------------------------------------------------------
5. Adding Form Inputs:
------------------------------------------------------------------------------------
   > To gather user input to allow users to interact and add data into your application you would require to create a Form Input.
   > You would probably create the Form element into a new Component sub-folder to keep your Component building blocks organised.
   > You would use default HTML elements and attributes to build the HTML Form for your Component function in JSX.
   > Note: The <input /> element in React should be in a self-closing tag when you have no value between the <input> element tags. So you should use a self-closing tag.

   Input Form Component Example:
      src/components/NewExpense/NewExpense.js:
         import React from 'react';
         import ExpenseForm from './ExpenseForm';
         const NewExpense = (props) => {
            return (
               <div>
                  <ExpenseForm />
               </div>
            );
         };
         export default NewExpense;

      src/components/NewExpense/ExpenseForm.js:
         import React from 'react';
         import './ExpenseForm.css';
         const ExpenseForm = () => {
            return (
               <form>
                  <div className="new-expense__controls">
                     <div className="new-expense__control">
                        <label>Title</label>
                        <input type="text" />
                     </div>
                     <div className="new-expense__control">
                        <label>Amount</label>
                        <input type="number" min="0.01" step="0.01" />
                     </div>
                     <div className="new-expense__control">
                        <label>Date</label>
                        <input type="date" min="2021-01-01" max="20235-12-31" />
                     </div>
                  </div>
                  <div className="new_expense__actions">
                     <button type="submit">Add Expenses</button>
                  </div>
               </form>
            );
         };
         export default ExpenseForm;

   > Remember that you would need to use the <NewExpense /> Component in either the root App.js JSX code or another file which is called by the App.js JSX, ultimately allowing the NewExpense Component function to be executed in order to be rendered to the screen.
   > This is the first step of allowing users to interact with your application. The next step requires you to gather the user inputs in order to do something with it when the user submits the input form.

------------------------------------------------------------------------------------
6. Listening to User Input:
------------------------------------------------------------------------------------
   > You may wish to gather user input on every change to any of the inputs to your Form. For example on every keystroke you would want to gather the user input value and store that value somewhere to use later (e.g. console log the value to the console).
   > You would need to add listeners to listen for every keystroke or change to the input fields. You can do this by adding Reacts event listener attributes (i.e. Reacts 'on prop') on the input you wish to listen to. The question is what type of event do you want to listen to. For example: '<input type="text" onChange={titleChangeHandler} />'.
   > The onInput event listens to all keystroke events on a text input element. The onChange event is similar to the onInput i.e. it also listens to every keystroke but you are able to use this event listener on all input type.
   > Refer back to '1. Listening to Events & Working with Event Handlers' section on how to use React Events and Event Handlers.
   > Typically, you would want to get the value the user has entered in the input field.

   Vanilla JavaScript Input Gathering Example:
      > document.getElementByID('inputIdName').addEventListener('click', (event) => {...})

   > You would add an event listener to a HTML element which takes in two parameter. The first is an event to listen to e.g. the click event and the second is a function call to trigger on the event. In the anonymous function call, JavaScript provides you an event object which describes the event that occurred. This is the default JavaScript behaviour in the browser when you listen to events.
   > In React you also get this default event object as well and you do not need to do anything to get this event object.
   > When you pass the pointer to your event handler function for your React 'on prop' event listener, React (or more specifically the browser) will ensure that you get an 'event' object whenever the event occurs.

   React Event Handler Example:
      src/components/NewExpense/ExpenseForm.js:
         const ExpenseForm = () => {
            const titleChangeHandler = (event) => {
               consol.log(event);
               consol.log(event.target.value);
            };
            return (...);
         };

   > You can console.log() the event object to see what object is returned from the event. This object will have a bunch of data you can explore but the most interesting data for you is the target property.
   > The target property is an object which points at the DOM element for which the event occurred. The input element (in this instance) has a long list of properties which you can read and set.
   > The input element has a value property and this value property holds the current value of the input at the point in time the event occurred.
   > This allows you to use dot notation to drill into the event object to retrieve the users input value e.g. event.target.value.
   > Now that you can gather the user's input value the next step is to do something with that value when the user submits the input form.

------------------------------------------------------------------------------------
7. Working with Multiple States:
------------------------------------------------------------------------------------
   > To handle multiple states, you can call on the useState hook multiple times i.e. you can have multiple useState pieces per Component.
   > All the states inside of the same Component will also be separated from each other.

   Multiple useState Example:
      import React, { useState } from 'react';
      const ExpenseForm = () => {
         const [enteredTitle, setEnteredTitle] = useState('');
         const [enteredAmount, setEnteredAmount] = useState('');
         const [enteredDate, setEnteredDate] = useState('');

         const titleChangeHandler = (event) => {
            setEnteredTitle(event.target.value);
         };
         const amountChangeHandler = (event) => {
            setEnteredAmount(event.target.value);
         };
         const dateChangeHandler = (event) => {
            setEnteredDate(event.target.value);
         };
         return (...);
      };

   > You may have more than one state per Component and is perfectly fine to have separate States and manage/update them separately. This is a key part of the entire State concept that React ships with.

------------------------------------------------------------------------------------
8. Using One State vs Using Multiple States:
------------------------------------------------------------------------------------
   > While you can add multiple States to a Component there is an alternative method (which depends on your personal preference).
   > In the previous example, you could argue that all three states are related to the form and is storing user input i.e. the same concept repeated three times. Therefore, you could use one state instead of three separate states whereby you would pass in an object as the default value for the useState parameter.
   > The object is important because you can now group together multiple state values into one State in your Component.

   One State Holding Multiple State Values Example:
      import React, { useState } from 'react';
      const ExpenseForm = () => {
         const [userInput, setUserInput] =useState({
            enteredTitle: '',
            enteredAmount: '',
            enteredDate: ''
         });

         const titleChangeHandler = (event) => {
            setUserInput({
               ...userInput,
               enteredTitle: event.target.value
            });
         };
         const amountChangeHandler = (event) => {
            setUserInput({
               ...userInput,
               enteredAmount: event.target.value
            });
         };
         const dateChangeHandler = (event) => {
            setUserInput({
               ...userInput,
               enteredDate: event.target.value
            });
         };
         return (...);
      };

   > The difference with this approach is that whenever you update this state you will need to update all properties and not just the one.
   > If you updated only the one property in the object you would end up dumping/losing the previous object properties because React will not merge the new property with the old values (i.e. React will replace the old object State with the new object State value).
   > Therefore, using the One State approach is your responsibility to ensure any other state values are not lost when updating the State.
   > You can use JavaScript spread operator (...) to create a copy of the current object and then update the property that has changed in the copy object and then use the new copy object as the update value for the updated State value. This will ensure other values (which have not changed) are not lost when updating the State.
   > This is an alternative method of storing multiple state values within one useState rather than using multiple useState pieces.