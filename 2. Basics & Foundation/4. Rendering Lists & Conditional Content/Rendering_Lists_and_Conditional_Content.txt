Rendering Lists & Conditional Content - Summary:
1. Rendering Lists of Data
2. Understanding Keys

------------------------------------------------------------------------------------
1. Rendering Lists of Data:
------------------------------------------------------------------------------------
   > In most web applications you will not know in advance how many items you would want to render. Therefore, hardcoding the number of occurrence of a Component Element is not the way to go.
   > To render a list dynamically you would first need to pass the data that requires to be rendered down to the Component which needs it via 'props'.
   > Once the Component gets the list of data required you can then use that data to dynamically render one Component Element per item within the data list/array.

   Rendering a Dynamic List Example:
      src/app.js:
         import React from 'react';
         import Expenses from './components/Expenses/Expenses';
         import NewExpense from './components/NewExpense/NewExpense';
         const App = () => {
            const expenses = [
               {id: 'e1', title: 'Toilet Paper', amount: 12.00, date: new Date(2021, 4, 16)},
               {id: 'e2', title: 'TV', amount: 345.99, date: new Date(2021, 3, 30)},
            ];
            const addExpenseHandler = expense => console.log(expense);
            return (
               <div>
                  <NewExpense onAddExpense={addExpenseHandler} />
                  <Expenses items={expenses} />
               </div>
            );
         };

      src/components/Expenses/Expenses.js:
         import React, {useState} from 'react';
         import ExpenseItem from './ExpenseItem';
         import ExpensesFilter from './ExpensesFilter';
         import Card from '../UI/Card';
         const Expenses = (props) => {
            const [filteredYear, setFilteredYear] = useState('2021');
            const filterChangeHandler = selectedYear => setFilteredYear(selectedYear);
            return (
               <div>
                  <Card className="expenses">
                     <ExpensesFilter selected={filteredYear} onFilterChange={filterChangeHandler} />
                     {props.items.map((expense) => (
                        <ExpenseItem title={expense.title} amount={expense.amount} date={expense.date} />
                     ))}
                  </Card>
               </div>
            );
         };

   > The <App /> Parent Component passes on the expenses array data via 'props' to the <Expenses /> Child Component. The <Expenses /> Child Component can now use this data to loop through the list to render dynamically multiple <ExpenseItem /> Components required to display each item within the array.
   > You would use curly brackets {} to execute a dynamic expression in your JSX code (i.e. curly brackets are used in React JSX to execute JavaScript expressions).
   > Accessing the 'props.items' allows you to access the array data passed from App to Expenses via 'props' (which the array was named 'items'). You can now use the built-in vanilla JavaScript array method called map() which allows you to create a new array based on another array. This allows you to transform every element in the original array.
   > The map() array method takes in a function as an argument/parameter which is called/executed on each item within the original array allowing you to transform the data and store the results in the newly created array. You can then use this new array to dynamically create the <ExpenseItem /> JSX Component Element to render and display the dynamic list.
   > If you have an array of JSX element, React is capable of rendering each element within the array side by side.
   > The 'expense' object is used to extract the 'title', 'amount' and 'date' values. The 'expense' represents each item within the array and the data changes on each iteration loop.
   > This will now dynamically list each array item as an <ExpenseItem /> JSX element. You will notice a warning message of "Warning: Each child in a list should have a unique "key" prop." within the browser's console which you can ignore for now. You can now change this array and those changes will now be reflected in the list display.
   > The App.js file can be updated to become a Stateful Component so that it holds the latest list data. This can be seen in the below example code:

   Rendering a Dynamic List Update to App.js Example:
      src/app.js:
         import React, { useState } from 'react';
         import Expenses from './components/Expenses/Expenses';
         import NewExpense from './components/NewExpense/NewExpense';
         const dummy_expenses = [
            {id: 'e1', title: 'Toilet Paper', amount: 12.00, date: new Date(2021, 4, 16)},
            {id: 'e2', title: 'TV', amount: 345.99, date: new Date(2021, 3, 30)},
         ];
         const App = () => {
            const [expenses, setExpenses] = useState(dummy_expenses);
            const addExpenseHandler = expense => {
               setExpenses(previousExpenses => {
                  return [expense, ...previousExpenses];
               });
            };
            return (
               <div>
                  <NewExpense onAddExpense={addExpenseHandler} />
                  <Expenses items={expenses} />
               </div>
            );
         };

   > The useState is imported to manage the State within the App.js file. The 'dummy_expenses' array is stored outside of the Component function because it is some dummy data to initialise the state with. Inside of the App Component function you can call on useState to pass in that 'dummy_expenses' array as the initial array value.
   > Using destructuring you can get access to the useState data and the special 'set' updating function.
   > The 'addExpenseHandler' function can now call the 'setExpenses' function you destructed from the 'useState' to set a new array using the new 'expense' received by the 'addExpenseHandler' function when it is called.
   > You would use the special function form to get the current snapshot of the 'previousExpenses' array passed into the 'setExpenses' function.
   > When you return a new array containing the new 'expense' item received by the 'addExpenseHandler' function, the special function form will allow you to user the spread operator on the 'previousExpenses' array snapshot to populate the rest of the new array with the existing elements (i.e. preserving the existing elements).
   > The spread operator can be used on both objects and arrays within vanilla JavaScript.
   > Now that the 'expenses' data is being used by the App Component to pass the Data/State to the Expenses Component via 'props', you will now have a dynamic list which automatically updates and renders to the screen when new expense items are added.
   > You now have a truly dynamic list rendered using State and the array map() method.

------------------------------------------------------------------------------------
2. Understanding Keys:
------------------------------------------------------------------------------------
   > React has a special concept when it comes to rendering a list of data. This concept exists to ensure that React is able to update and render such lists efficiently without performance loss or bugs which may occur.
   > To understand the issue with performance loss, if you were to open the JavaScript Console within the browser and navigate to the Elements tab to inspect the list of div elements. When you add a new ExpenseItem, React creates a new div element as the last item in the list of div elements and it then updates all the div items and replaces their contents such that it matches the oder in the array. This causes performance loss issues.
   > While the final result is correct, from a performance perspective this is not great because all items are visited again and updated which can also lead to bugs (e.g. state changes causing loss to the original state to a State Components i.e. the old first state item overridden by the new first state item causing state loss and unexpected bugs).
   > React behaves like the above because it has no other way to behave when updating a list. React simply checks the length of the array and then has a look at the number of elements already rendered to the DOM. The individual elements all look the same to React and it cannot know where the new item should be added.
   > This is the reason behind the "Warning: Each child in a list should have a unique "key" prop." warning message in the browser's JavaScript Console because you have a way of telling React where the new item should be added.
   > You would add a special 'prop' called 'key' to the area that is rendering the list.

   Special Key Prop with Unique Key Value Example:
      {props.items.map((expense) => (
         <ExpenseItem key={expense.id} title={expense.title} amount={expense.amount} date={expense.date} />
      ))}

   Special Key Prop using Map's Index as the Unique Key Value Example:
      {props.items.map((expense, index) => (
         <ExpenseItem key=index title={expense.title} amount={expense.amount} date={expense.date} />
      ))}

   > The 'key' prop can be added to any Component (i.e. Default HTML or Custom JSX Component Elements).
   > This helps React identify the individual items.
   > The 'key' prop value must be set to a unique value per list item. In the above example this was the 'expense.id' value.
   > If you have no unique id, you can ue the second argument/parameter from the function you pass to the map() array method which is an automatically managed index. However, it is discouraged to use the map() method's index argument/parameter because you can still run into some bugs because the index of a given item is always the same and not directly attached to the content of the item.
   > In most scenarios you will have a unique id because typically you will render some data that comes from a Database which will have a unique identifiers that you can use. You can use any primitive values as a unique id value i.e. numbers or strings.
   > The warning message should now disappear from the browser's JavaScript Console and React will now have a much efficient way to update a list using the 'keys' prop.
   > You should always use the 'keys' props when mapping out list of items.