React Basics & Working with Components - Summary:
1. What are Components?
2. How are Components Built?
3. Creating a New React Project
4. Analysing a Standard React Project
5. Introducing JSX
6. Building a Custom Component
7. Writing a more Complex JSX Code
8. Adding Basic CSS Styling
9. Outputting Dynamic Data & Working with Expressions in JSX
10. Passing Data via Props
11. Adding "Normal" JavaScript Logic to Components
12. Splitting Components into Multiple Components
13. The Concept of Composition (Props.Children)
14. A Closer Look at JSX
15. Organising Component Files
16. An Alternative Function Syntax (Arrow Functions)

------------------------------------------------------------------------------------
1. What are Components?:
------------------------------------------------------------------------------------
   > HTML, CSS and JavaScript are web technologies for building User Interfaces.
   > React is a JavaScript library for building User Interfaces (UI).
   > React makes building complex interactive and reactive UI simpler.
   > React embraces a concept called "Components".
   > React is all above components because all UI at the end of the day are made up of components.
   > Components are a combination of HTML for structure, CSS for styling and possibly JavScript for logic.
   > Components have a trait of being reusable.
   > This creates individual building blocks which can be combined together to build a UI.
   > React embraces Components because of reusability (DRY principal) and separation of concerns (functions Single-Responsibility principle). Both concepts are important in programming in general.

------------------------------------------------------------------------------------
2. How are Components Built?:
------------------------------------------------------------------------------------
   > When you work with React and build components, you are simply combining HTML, CSS and JavaScript. You then combine all these components together to build the entire UI.
   > The CSS is the least important aspect when building components in React.
   > Vanilla JavaScript requires you to tell it where a certain HTML element should be created and inserted at a pacific place on the UI (if you were creating HTML using vanilla JavaScript).
   > React uses a 'Declarative Approach' for building components. This means with React, you would define the desired end state i.e. target state(s) and let React figure out the actual JavaScript DOM instructions under the hood.
   > Therefore, you can say that with React, you build your own custom HMTL Elements which you combine together to build a UI.

------------------------------------------------------------------------------------
3. Creating a New React Project:
------------------------------------------------------------------------------------
   > Create-React-App is a console tool that allows you to quickly generate a boiler plate react project (https://create-react-app.dev/).
   > Further documentation resource: https://reactjs.org/docs/create-a-new-react-app.html
   > This will create pre-configured folders, basic react code files and most importantly a bunch of configuration files to help build the react application for production as well as provide a local development environment.
   > To execute the Create-React-App tool, you will require Node.js to be installed on your machine which is a runtime for JavaScript which will allow you to run JavaScript code.
   > Node.js comes bundled with the Node Package Manager (NPM) which allows you to install external packages.
   > https://nodejs.org/en/
   > Within the terminal, navigate to the desired path you wish to create a new React Project using the 'cd' (change directory) command.
   > Execute the following commands to create the new React Project within the current directory path:

   Terminal Commands:
      $: npx create-react-app [app-name]
      $: cd [app-name]
      $: npm start

   > Replace [app-name] with the name of your React application e.g. 'npx create-react-app my-app'
   > Important Note: NPM naming restrictions restricts you from using capital letters within the app name, thus, you cannot use camelCase naming of the App file.
   > Your new project files will be created in the destination. The 'npm start' command will run your React app in your local development environment i.e. localhost:3000 (you must be in the directory before you run the command).
   > You are now ready to start editing the base dummy code and creating your React Application.
   > To stop the React local web server from running, hold down the control key and press the c button on your keyboard in the terminal that is running the server.

------------------------------------------------------------------------------------
4. Analysing a Standard React Project:
------------------------------------------------------------------------------------
   > The src folder within your React Project is the main source folder where you would write your React code.
   > React code is just JavaScript code, but you would use special syntax code introduced by React.
   > The index.js file is the first code file that will be executed whenever the root page is loaded.
   > Important Note: the index.js code will actually be a transformed/optimised version of the code which is generated behind the scenes. For example the below codes are not valid JavaScript syntax but will be converted to be valid JavaScript code:
      "import './index.css';" and 
      "ReactDOM.render(<React.StrictMode><App /></React.StrictMode>, document.getElementById('root'));"
   > This allows you to write code in a nice and easily readable developer friendly way but have transformed valid code at the end of the day that can run in the browser.

   > The public/index.html file is the single HTML file that is loaded in the browser. React creates a so-called single page application typically. This means it creates one single HTML file that is delivered and rendered to the browser and the finished React (JavaScript) code that is what we actually see on the screen that manipulates the DOM.
   > The <div id="root"></div> is the single HTML element within the file. This element has the id of 'root'. It is this element that is selected by the index.js ReactDOM.render() snippet i.e. 'document.getElementById('root')'.
   > The <noscript> HTML element is used to load the React JavaScript code into the HTML.

   > The <App /> is the JavaScript file (i.e. 'import App from './App';') that we would have imported into the index.js file.
   > Using the ReactDOM.render() function from the 'react-dom' library we are injecting the <App /> (i.e. the App.js JavaScript code) into the <div id="root"> element which ultimately gets rendered to the screen.
   > This is not regular JavaScript syntax but something called JSX syntax which we will revisit in 5. Introducing JSX.
   > The <App /> is the first React Component which we render inside of the 'root' <div> element.

   > The App.js is the file that holds a function called App() which is then exported. This allows you to use the App function in the index.js file.
   > The App() function returns something which is a HTML code inside of a JavaScript file. This is not a valid JavaScript code; however, it works because of the JSX feature which is a special syntax invented and introduced by the React team. This syntax works due to the overall project setup and the behind the scenes transformations that convert the code into valid JavaScript code.

------------------------------------------------------------------------------------
5. Introducing JSX:
------------------------------------------------------------------------------------
   > JSX stands for JavaScript XML because you could say HTML in the end is XML.
   > There are transformation steps working behind the scenes which transforms the JSX JavaScript code to a more browser friendly code before everything is actually served to the browser.
   > You can view the transformed code by opening the Developer tool within your browser for the React App and within the Sources tab you can see all the scripts and files downloaded by the browser to render the page on the screen.
   > The static/js folder will hold the transformed JavaScript code which looks like some cryptic JavaScript code which you have not written in your project code which is a more simple and developer friendly code.
   > The code in these files are not only your code but also the entire React Package code.

------------------------------------------------------------------------------------
6. Building a Custom Component:
------------------------------------------------------------------------------------
   > It is considered best practice to place new components into new files. To organise the source code, you can create a new 'src/components' folder which will hold all the components source files.
   > The App.js will not move into the components directory because this will act as a special kind of component (not regarding its code but rather it's role within the application).
   > The App.js will be the root component which will be the main component rendered in the main index.js file.
   > All other components will either be nested inside of App.js or other Component files which will eventually be nested into the App.js file.
   > With React you are building a "Component Tree", for example:

   Component Tree Example:
                  <App />
            _________|_________
            |                 |
         <Header />        <Tasks />
                              |
                  ____________|____________
                  |           |           |
               <Task />    <Task />    <Task />

   > Big Applications can result in large Component Trees where only the topmost (i.e. <App />) component is rendered into the single HTML page with the help of the ReactDOM.render() function.
   > It is a common naming convention to name your component JavaScript files using PascalCase (i.e. the first letter of each word is capitalised and the first character must always be capitalised).
   > The name of the component should tell the developer what kind of logic and HTML code will live inside of the file.
   > A component code in React is simply a function that will be exported. It is a special type of function in terms of what it returns i.e. JSX code. Other than that it is just a regular JavaScript function.

   React Component Example:
      src/components/ExpenseItem.js:
         function ExpenseItem() {
            return <h2>Expense Item</h2>;
         };
         export default ExpenseItem;

   > The convention is to name the function the same as the component name without the .js extension name.
   > You must return something in a function by calling the return() method. Note in the example above, since we are returning a <h2> element, we can write this onto a single line without wrapping it in the round brackets.
   > The round brackets signals to JavaScript that the return statement/code are one and the same statement even if they should span across multiple lines.
   > To use the component you must export it, otherwise it is only useable within the file itself which is not helpful.
   > The 'export default' keyword is used to export the function as the default function for this component file.
   > This component can now be imported in another file.
   > You will use this component like a regular HTML element inside of the html code written in the App.js component file.

   Importing React Component Example:
      src/App.js:
         import ExpenseItem from './components/ExpenseItem';
         function App() {
            return (
               <div>
                  <ExpenseItem></ExpenseItem>
               </div>
            );
         };
         export default App;
   
   > The 'import' keyword tells JavaScript the relative file path from App.js to the exported component function file to import from.
   > The imported function can now be used in the App.js like a regular HTML element.
   > The element name must be the same as the imported default function name which must be in PascalCase. This allows for the connection of the imported component function.
   > You can use either opening and closing tags or self closing tags e.g. <ExpenseItem></ExpenseItem> or <ExpenseItem />.
   > If you have a component element with no content inside of the opening and closing tags you can use the self-closing syntax (e.g. <ExpenseItem />).
   > Lowercase Elements are default HTML elements while PascalCase Elements are custom made components created by the developer. This allows for React to detect the custom component from regular HTML elements.

------------------------------------------------------------------------------------
7. Writing a more Complex JSX Code:
------------------------------------------------------------------------------------
   > React has one important rule regarding JSX code that is returned from the Component function.
   > You must only have one root element per return statement / JSX code snippet.

   Incorrect JSX Code:
      return (
         <div>Date</div>
         <div>
            <h2>Title</h2>
            <div>Amount</div>
         </div>
      );

   > The above is invalid because there are two side by side <div> elements (both being root elements being returned by the function).
   > One of the simplest work workaround fix is to wrap the whole code in a single root <div> element which abides by the rule that a component can only return a single root element.

   Valid JSX Code:
      return (
         <div>
            <div>Date</div>
            <div>
               <h2>Title</h2>
               <div>Amount</div>
            </div>
         </div>
      );

   > The single parent <div> element can have multiple div elements inside it that can be side by side. This demonstrates that you should only return a root/parent element that must be a single element from your component function.

------------------------------------------------------------------------------------
8. Adding Basic CSS Styling:
------------------------------------------------------------------------------------
   > To add styling to React Components you would still use regular CSS.
   > Typically you would create a new CSS file next to the Component file by using the same name but with the .css extension name.

   CSS Code for Component Example:
      src/components/ExpenseItem.css:
         .expense-item {
            display: flex;
            background-color: #4b4b4b;
         }

   > In ExpenseItem.js Component file, you need to make the overall build process aware of the CSS file and tell it that the CSS file should be considered and injected it into the finished application transformation build.
   > You simply import the CSS file into the Component file which will then tell the React process when building the final app code.

   Importing CSS Code in the Component File Example:
      src/components/ExpenseItem.js:
         import './ExpenseItem.css';
         function ExpenseItem() {
            return (
               <div className="expense-item">
                  ...
               </div>
            );
         };

   > To apply the CSS styling to an element we would need to provide an id/class property to the element. To add a class property to an element in JSX, you would use className instead of class.
   > Remember JSX may look like HTML but is a syntax created by the React team. JSX in the end is JavaScript code and also the reason for why most attributes are the same as HTML but not all (class being one of these). This is because class is a reserved keyword within JavaScript.
   > Other than the above, it is really just standard CSS code which is then added to your custom element.

------------------------------------------------------------------------------------
9. Outputting Dynamic Data & Working with Expressions in JSX:
------------------------------------------------------------------------------------
   > It was mentioned that Components are a combination of HTML, CSS and JavaScript. Thus far we have seen HTML and CSS in action but have not seen JavaScript other than the component being a function.
   > You can add JavaScript code inside of the function before it returns the HTML output.

   Outputting Dynamic Data Example:
      src/components/ExpenseItem.js:
         function ExpenseItem() {
            const expenseDate = new Date(2021, 4, 15);
            const expenseTitle = 'Car Insurance';
            const expenseAmount = 745.36

            return (
               <div className="expense-item">
                  <div>{expenseDate.toISOString()}</div>
                  <div className="expense-item__description">
                     <h2>{expenseTitle}</h2>
                     <div className="expense-item__price">£{expenseAmount}</div>
                  </div>
               </div>
            );
         };

   > Note that later on we will explore how you can use dynamic data coming from for example an API or Database or a React Form etc.
   > However, the concept is the same that you would use regular JavaScript to grab data which you can then return in the HTML i.e. JSX syntax.
   > JSX provides the opening and closing curly braces syntax to inject basic JavaScript expressions. The result of the expression is what will appear on the screen. For example the JavaScript expression of {1+1} will display 2 on the screen or {Math.random()} which will generate a random number on the screen.
   > By repeating the name of the variable is a valid JavaScript expression which simply points at a variable.
   > Important Note: the date is a Date Object and cannot be output as text which would break the App. Instead, you can call on the .toISOString() which is a built in JavaScript method available on all Date Objects to output the date as a string and avoid the breaking code.
   > Note that the date will not be in a easily readable string but is a first step for converting Date Objects into a string representation.
   > Using this method allows you to inject dynamic data into the JSX (HTML) code so that the values are not hardcoded.
   > The above example would still output the same hardcoded values as before but it is now injected into the JSX code and is the first step towards dynamic data output.
   > You can now have the concrete value to be the result of a calculation, HTTP/HTTPS request or a value stored in a variable (as demonstrated above).

------------------------------------------------------------------------------------
10. Passing Data via Props:
------------------------------------------------------------------------------------
   > To make a component reusable you would simply copy the component element within the JSX code.

   Example of Reusing a Component:
      src/App.js:
         import ExpenseItem from './components/ExpenseItem';
         function App() {
            return (
               <div>
                  <ExpenseItem></ExpenseItem>
                  <ExpenseItem></ExpenseItem>
               </div>
            );
         };

   > In the above example the ExpenseItem component is reused and repeated two times.
   > the component is not actually reusable at the moment because the data inside of the ExpenseItem component is baked in displaying the same data inside of the component.
   > In regular JavaScript, you would have functions to split functionality across multiple smaller code bases and also have reusable functions that you can call multiple times. Functions have parameters which allows you to reuse functions with different argument/parameter values.
   > React has the same concept built-in. To make components reusable you would use parameters and a concept called 'Props'.

   > As a hypothetical example, the <App /> component has a goalItem variable which holds a string of "Finished!" (i.e. const goalItem = 'Finished!'). You then have a custom component called <CourseGoalItem /> which stores a list item where the goalItem value should be outputted dynamically (i.e. <li>{goalItem}</li>). The issue here is that the goalItem variable lives in the <App /> component and not in the <CourseGoalItem /> component.
   > This is good because the CourseGoalItem component is made independent and does not store the concrete value internally.
   > Components cannot have access to use data stored in other components. Instead, you can utilise a concept called 'Props' to pass data to a custom component by adding an attribute. Inside of that component you can get access to all the attributes which might have been set on the custom component.
   > Again, you are building your own custom HTML elements and just as HTML elements can have attributes, so can Reacts custom Components. This concept is called 'Props' which stands for properties which is the same as the HTML elements attributes concept.

   Props Example:
      src/App.js:
         import ExpenseItem from './components/ExpenseItem';
         function App() {
            const expenses = [
               {id: 'e1', title: 'Toilet Paper', amount: 12.00, date: new Date(2021, 4, 16)},
               {id: 'e2', title: 'TV', amount: 345.99, date: new Date(2021, 3, 30)},
               {id: 'e3', title: 'Car Insurance', amount: 745.36, date: new Date(2021, 4, 15)},
               {id: 'e4', title: 'New Desk (Wood)', amount: 400.00, date: new Date(2021, 4, 12)},
            ];
            return (
               <div>
                  <ExpenseItem title={expenses[0].title} amount={expenses[0].amount} date={expenses[0].date}></ExpenseItem>
                  <ExpenseItem title={expenses[1].title} amount={expenses[1].amount} date={expenses[1].date}></ExpenseItem>
                  <ExpenseItem title={expenses[2].title} amount={expenses[2].amount} date={expenses[2].date}></ExpenseItem>
                  <ExpenseItem title={expenses[3].title} amount={expenses[3].amount} date={expenses[3].date}></ExpenseItem>
               </div>
            );
         };

      src/components/ExpenseItem.js:
         function ExpenseItem(props) {
            return (
               <div className="expense-item">
                  <div>{props.date.toISOString()}</div>
                  <div className="expense-item__description">
                     <h2>{props.title}</h2>
                     <div className="expense-item__price">£{props.amount}</div>
                  </div>
               </div>
            );
         };

   > In the above example, the expenses data is stored as an array of objects within the App.js component file. These objects can be passed to the different ExpenseItem components.
   > The ExpenseItem components require to be made configurable from outside the component file itself. This is achieved by the App.js file passing the object values as attributes/props to the ExpenseItem component.
   > You can use JavaScript Expressions to pass the value as an attribute value using the curly brackets (refer to 9. Outputting Dynamic Data & Working with Expressions in JSX).
   > The name of the attributes/props is entirely up to you but should be meaningful for readability of your code.
   > Remember that JavaScript arrays uses zero indexing.
   > Within the Component file itself that is receiving 'Props' you need to do something with these attributes/props which is the second part of the process.
   > React ensures that the Component will receive one argument/parameter to the custom Component function. This function argument/parameter will be an object that holds all of the attributes that is passed as properties. Hence, the name of 'Props' for the overall concept.
   > You can name this function argument/parameter whatever you want because it is your function. Therefore, you can call it data, but typically it is called props to make it clear that this argument/parameter holds all the values that you get from the attributes on the custom component element.
   > You get key:value pairs from this argument/parameter object which is passed in via React automatically. The keys will be the attributes names passed to the component element and the values will be the set values of those attributes.
   > To access the value you would use the argument/parameter name followed by the key name you wish to access (e.g. {props.title} will return the title's key value coming from the attribute/props passed into the Component element). Remember that the key name is the name of the attribute/prop you passed into the component element.
   > You should ensure the attribute/prop names you choose are self-explanatory and makes sense as good practice so that other developers understand your Component's code.
   > The data now comes outside the component and you no longer need to define them within the component function itself. This helps you step one step closer to truly dynamic data and reusable components.
   > This is how you share data between React Components. Props is a key/important concept in React and you should become familiar with this concept before moving on.
   > Important Note: 'Props' are not limited to dynamically set values and you can pass in hardcoded values.

------------------------------------------------------------------------------------
11. Adding "Normal" JavaScript Logic to Components:
------------------------------------------------------------------------------------
   > You will notice that the date values using the JavaScript .toString method does not provide a human readable data format.
   > You can use normal JavaScript functions to Components since a component is simply JavaScript code that returns a JSX (HTML).
   > JavaScript has some built-in date conversion methods such as .toISOString(), .toLocaleString() and .getFullYear() which you can use to format dates using normal JavaScript logic.

   Adding "Normal" JavaScript Logic Example:
      src/components/ExpenseItem.js:
         function ExpenseItem(props) {
            const day = props.date.toLocaleString('en-GB', { day: '2-digit' });
            const month = props.date.toLocaleString('en-GB', { month: 'long' });
            const year = props.date.getFullYear();

            return (
               <div className="expense-item">
                  <div>
                     <div{day}></div>
                     <div{month}></div>
                     <div{year}></div>
                  </div>
                  <div className="expense-item__description">
                     <h2>{props.title}</h2>
                     <div className="expense-item__price">£{props.amount}</div>
                  </div>
               </div>
            );
         };

------------------------------------------------------------------------------------
12. Splitting Components into Multiple Components:
------------------------------------------------------------------------------------
   > React has the concept of Components because it allows you to split your application into smaller building blocks where every component is focused on one core task/aspect. You then build your overall User Interface (UI) by combining these Component building blocks. This helps you keep your Component code small and manageable while being able to build more complex UI.
   > There is no hard and fast rule when to break your components into smaller components.

   Splitting Components Example:
      src/components/ExpenseItem.js:
         import ExpenseDate from './ExpenseDate';
         function ExpenseItem(props) {
            return (
               <div className="expense-item">
                  <ExpenseDate date={props.date} />
                  <div className="expense-item__description">
                     <h2>{props.title}</h2>
                     <div className="expense-item__price">£{props.amount}</div>
                  </div>
               </div>
            );
         };

      src/components/ExpenseDate.js:
         function ExpenseDate(props) {
            const day = props.date.toLocaleString('en-GB', { day: '2-digit' });
            const month = props.date.toLocaleString('en-GB', { month: 'long' });
            const year = props.date.getFullYear();

            return (
               <div>
                  <div>{day}</div>
                  <div>{month}</div>
                  <div>{year}</div>
               </div>
            );
         };

   > In the above example, the date logic has been split into it's own component file. This now makes the ExpenseItem Component more lean.
   > Remember: the file that is using the Component as an custom HTML element must import the Component first. This can be seend with ExpenseItem.js importing the ExpenseDate.js Component file.
   > The ExpenseDate component receives a props argument/parameter in order to receive properties from other Components.
   > Remember: you would need to pass the date as a 'Prop' attribute for the ExpenseDate component element in order to extract the date and format it.
   > You will now notice the data value for date is passing down multiple component i.e. from the <App /> Component to the <ExpenseItem /> Component and finally reaching the <ExpenseDate /> Component.
   > The ExpenseDate Component can now be used by any other Components that require this component.

------------------------------------------------------------------------------------
13. The Concept of Composition (Props.Children):
------------------------------------------------------------------------------------
   > So far, this approach of building a User Interface from smaller building blocks is called "Composition".
   > What if we want to create a Component which actually just serves as a shell around any other content?
   > Sometimes you want a Component where you do not configure everything through 'Props' but you are instead able to pass content between the opening and closing tags of that Component.
   > For Example, your application code could have a container/boxes that have rounded corners and a slight box-shadows around UI elements. The whole point of having building blocks (Components) is to avoid code duplications. In this example, there is a HTML structure and style duplication.
   > You can extract the styles Components have in common into a separate Component. Below is a sample code:

   Composition (Children Props) Example:
      src/components/Card.js:
         import './Card.css';
         function Card(props) {
            const classes = 'card' + props.className
            return <div className={classes}>{props.children}</div>
         };
         export default Card;

      src/components/Card.css:
         .card {
            border-radius: 12px;
            box-shadow: 0 1px 8px rgba(0, 0, 0, 0.25);
         }

      src/components/ExpenseItem.js:
         import ExpenseDate from './ExpenseDate';
         import Card from './Card';
         import './ExpenseItem.css';
         function ExpenseItem(props) {
            return (
               <Card className="expense-item">
                  <ExpenseDate date={props.date} />
                  <div className="expense-item__description">
                     <h2>{props.title}</h2>
                     <div className="expense-item__price">£{props.amount}</div>
                  </div>
               </Card>
            );
         };
         export default ExpenseItem;

      src/components/ExpenseItem.css:
         .expense-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem;
            margin: 1rem 0;
            background-color: #4b4b4b;
         }

      src/components/Expenses.css:
         import ExpenseItem from './ExpenseItem';
         import Card from './Card';
         import './Expenses.css';
         function Expenses(props) {
            return (
               <Card className="expenses">
                  <ExpenseItem title={ props.items[0].title} amount={props.items[0].amount} date={props.items[0].date } />
                  <ExpenseItem title={ props.items[1].title} amount={props.items[1].amount} date={props.items[1].date } />
                  <ExpenseItem title={ props.items[2].title} amount={props.items[2].amount} date={props.items[2].date } />
                  <ExpenseItem title={ props.items[3].title} amount={props.items[3].amount} date={props.items[3].date } />
               </Card>
            );
         };
         export default Expenses;

   > The Card Component acts as a shell around other components that require the .card container styling.
   > The ExpenseItem can import the Card Component and wrap its content using the shell (e.g. <Shell>Content</Shell>).
   > However, out-of-the-box you cannot use your Components as wrappers around other kind of content i.e. having contents between the opening and closing custom Component element does not work out-of-the-box unlike built in HTML such as the <div> or <h2> element tags.
   > To make it work with our custom Component, the Card Component would have to use the 'Props' argument/property provided by React.
   > There is one special property built into React which every component receives even if it is not set explicitly called the 'props.children'.
   > The '.children' property is a reserved name and the value of this .children property will always be the content between the opening and closing tags of the custom Component. Therefore, in the above example, the content between the opening and closing <Card><Card/> component wrapper will be available on the {props.children} property.
   > Important Note: This may break the styling defined in other CSS files such as ExpenseItem.css file. You must not forget that the custom Component is defined by you. While all the default HTML elements support className for adding CSS classes to the rendered HTML elements, custom Components only support what you tell them to support.
   > To ensure that a className can be set on your custom Component and has an affect you would need to create a const variable and set its value adding the 'props.className' which would take in anything that is received as a className outside of the component. The className for the custom Component can then point at this dynamically set const variable value.
   > The 'const classes = 'card' + props.className' code ensures the "card" class name is combined with any other external classNames (e.g. ".expense-item").
   > You now have a reusable Component shell/wrapper that can now be used anywhere it is required (as seen in the above example being used in the Expenses Component).
   > This Composition concept allows you to save on code duplication especially with more complex wrapper Components such as Modals. You would use Composition all the time with React and it is an important concept to understand and learn as part of the basic fundamentals of React.

------------------------------------------------------------------------------------
14. A Closer Look at JSX:
------------------------------------------------------------------------------------
   > JSX is syntactical sugar which gets transformed into regular HTML code behind the scenes.
   > In the package.json file you will find all the dependencies with most handling the behind the scenes transformations.
   > There are two dependencies which are related to React which are 'react' and 'react-dom'.
   > The 'react-dom' library is imported and being used within the index.js file. However, we never import/use the 'react' library anywhere in our code. This setup works all modern React project setups using the create-react-app CLI tool.
   > In the past in older React projects you actually needed to import React from the 'react' library in all of your Component files (i.e. in all files that you use JSX). There are a lot of React projects out in the wild which have the import statement for bringing in the 'react' library into their Component file.
   > The import of the 'react' library in the Component can be omitted in modern React projects because there are some special things occurring behind the scenes to make it all work.
   > The 'react' library is responsible for making JSX code transform into methods called on the React object which is why you needed to import React from 'react'; in the past.
   > the React.createElement() method at the end of the day is what is being called and this method takes in three arguments/parameters. The first argument is the element to be created e.g. a <div>. The second is an object that configures the element, specifically the attributes of the element. The third and final argument is the content within the opening and closing element tags. The final argument can be an infinite list of arguments which are the different content pieces within the opening and closing tags.

   React Object's createElement Method Example:
      import React from 'react';
      import Expenses from './components/Expenses';
      return React.createElement('div', {}, 'Hello World');
      return React.createElement('div', {}, React.createElement('h2', {}, 'Let\'s get started!'), React.createElement(Expenses, {items: expenses}));

   > The first return createElement method would return the HTML element: <div>Hello World</div>
   > The second return createElement method would return the HTML element: <div><h2>Let\'s get started!</h2>...</div>
   > Pointing at a custom element at the end of the day is simply pointing to an imported function (i.e. the imported Component which is a function).
   > The Expenses custom element would be all the HTML elements that was defined in that file (represented by ... i.e. it could be <div>Expenses</div>);
   > You could write your whole React applications as seen in the above example; however, it would be much cumbersome to write that code compared to writing using JSX code.
   > This is the reason for why in the past you were required to import the React object from the 'react' library into your Component files because it is the under the hood code which gets created automatically when you use JSX.
   > Modern React projects can omit the import statement because the setup allows the transformation without the import needing to be added.
   > If you are working on projects where it uses the import of the 'react' library just note that this was a past requirement.
   > You can now appreciate the reason for why JSX requires a single root element and cannot have two root elements side by side. There is no way JSX can convert the code into the code that is required by the .createElement method. You cannot return more than one thing unless it is an array of elements but this is not the case. In the React world, you would create one wrapper root element which may have more child elements.

------------------------------------------------------------------------------------
15. Organising Component Files:
------------------------------------------------------------------------------------
   > As your project grows, you would want to organise your Component files. Typically, you would create sub-folders within the 'components' folder.
   > You may have a component folder for generic UI elements that is not tied to a specific feature.
   > You may have a component folder for more specific feature components.
   > This will help you keep your files organised as your project grows in size and the files are not in one big folder. Ultimately, it is up to you as the developer how you would like to organise your project files. If working within a team then you would want to follow the teams organising files pattern.

------------------------------------------------------------------------------------
16. An Alternative Function Syntax (Arrow Functions):
------------------------------------------------------------------------------------
   > This is not specific to React. ES6 introduces arrow functions as an alternative syntax for functions which resolves some JavaScript issues with the 'this' keyword scope and makes writing functions shorter.

   React Component with Arrow Function Example:
      const App = () => {
         const expenses = [
            {id: 'e2', title: 'TV', amount: 345.99, date: new Date(2021, 3, 30)},
         ];

         return (
            <div>
               <h2>Hello World</h2>
               <Expenses items={expenses} />
            </div>
         );
      };

   > You store the function within a variable. This is standard JavaScript code and it is up to you as the developer which syntax you are comfortable using.
   > If working on a larger code base within a team/organisation then you would need to conform to the team's syntax style.